(window.webpackJsonp = window.webpackJsonp || []).push([[1], { 0: function (t, e, n) { t.exports = n("zUnb") }, yLV6: function (t, e, n) { var r; !function (s, i, o, a) { "use strict"; var l, c = ["", "webkit", "Moz", "MS", "ms", "o"], h = i.createElement("div"), u = Math.round, d = Math.abs, p = Date.now; function f(t, e, n) { return setTimeout(w(t, n), e) } function m(t, e, n) { return !!Array.isArray(t) && (g(t, n[e], n), !0) } function g(t, e, n) { var r; if (t) if (t.forEach) t.forEach(e, n); else if (void 0 !== t.length) for (r = 0; r < t.length;)e.call(n, t[r], r, t), r++; else for (r in t) t.hasOwnProperty(r) && e.call(n, t[r], r, t) } function y(t, e, n) { var r = "DEPRECATED METHOD: " + e + "\n" + n + " AT \n"; return function () { var e = new Error("get-stack-trace"), n = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace", i = s.console && (s.console.warn || s.console.log); return i && i.call(s.console, r, n), t.apply(this, arguments) } } l = "function" != typeof Object.assign ? function (t) { if (null == t) throw new TypeError("Cannot convert undefined or null to object"); for (var e = Object(t), n = 1; n < arguments.length; n++) { var r = arguments[n]; if (null != r) for (var s in r) r.hasOwnProperty(s) && (e[s] = r[s]) } return e } : Object.assign; var _ = y((function (t, e, n) { for (var r = Object.keys(e), s = 0; s < r.length;)(!n || n && void 0 === t[r[s]]) && (t[r[s]] = e[r[s]]), s++; return t }), "extend", "Use `assign`."), v = y((function (t, e) { return _(t, e, !0) }), "merge", "Use `assign`."); function b(t, e, n) { var r, s = e.prototype; (r = t.prototype = Object.create(s)).constructor = t, r._super = s, n && l(r, n) } function w(t, e) { return function () { return t.apply(e, arguments) } } function S(t, e) { return "function" == typeof t ? t.apply(e && e[0] || void 0, e) : t } function E(t, e) { return void 0 === t ? e : t } function C(t, e, n) { g(A(e), (function (e) { t.addEventListener(e, n, !1) })) } function x(t, e, n) { g(A(e), (function (e) { t.removeEventListener(e, n, !1) })) } function T(t, e) { for (; t;) { if (t == e) return !0; t = t.parentNode } return !1 } function k(t, e) { return t.indexOf(e) > -1 } function A(t) { return t.trim().split(/\s+/g) } function R(t, e, n) { if (t.indexOf && !n) return t.indexOf(e); for (var r = 0; r < t.length;) { if (n && t[r][n] == e || !n && t[r] === e) return r; r++ } return -1 } function P(t) { return Array.prototype.slice.call(t, 0) } function I(t, e, n) { for (var r = [], s = [], i = 0; i < t.length;) { var o = e ? t[i][e] : t[i]; R(s, o) < 0 && r.push(t[i]), s[i] = o, i++ } return n && (r = e ? r.sort((function (t, n) { return t[e] > n[e] })) : r.sort()), r } function O(t, e) { for (var n, r, s = e[0].toUpperCase() + e.slice(1), i = 0; i < c.length;) { if ((r = (n = c[i]) ? n + s : e) in t) return r; i++ } } var N = 1; function D(t) { var e = t.ownerDocument || t; return e.defaultView || e.parentWindow || s } var F = "ontouchstart" in s, M = void 0 !== O(s, "PointerEvent"), L = F && /mobile|tablet|ip(ad|hone|od)|android/i.test(navigator.userAgent), j = ["x", "y"], U = ["clientX", "clientY"]; function B(t, e) { var n = this; this.manager = t, this.callback = e, this.element = t.element, this.target = t.options.inputTarget, this.domHandler = function (e) { S(t.options.enable, [t]) && n.handler(e) }, this.init() } function H(t, e, n) { var r = n.pointers.length, s = n.changedPointers.length, i = 1 & e && r - s == 0, o = 12 & e && r - s == 0; n.isFirst = !!i, n.isFinal = !!o, i && (t.session = {}), n.eventType = e, function (t, e) { var n = t.session, r = e.pointers, s = r.length; n.firstInput || (n.firstInput = V(e)), s > 1 && !n.firstMultiple ? n.firstMultiple = V(e) : 1 === s && (n.firstMultiple = !1); var i = n.firstInput, o = n.firstMultiple, a = o ? o.center : i.center, l = e.center = z(r); e.timeStamp = p(), e.deltaTime = e.timeStamp - i.timeStamp, e.angle = K(a, l), e.distance = Q(a, l), function (t, e) { var n = e.center, r = t.offsetDelta || {}, s = t.prevDelta || {}, i = t.prevInput || {}; 1 !== e.eventType && 4 !== i.eventType || (s = t.prevDelta = { x: i.deltaX || 0, y: i.deltaY || 0 }, r = t.offsetDelta = { x: n.x, y: n.y }), e.deltaX = s.x + (n.x - r.x), e.deltaY = s.y + (n.y - r.y) }(n, e), e.offsetDirection = W(e.deltaX, e.deltaY); var c, h, u = q(e.deltaTime, e.deltaX, e.deltaY); e.overallVelocityX = u.x, e.overallVelocityY = u.y, e.overallVelocity = d(u.x) > d(u.y) ? u.x : u.y, e.scale = o ? (c = o.pointers, Q((h = r)[0], h[1], U) / Q(c[0], c[1], U)) : 1, e.rotation = o ? function (t, e) { return K(e[1], e[0], U) + K(t[1], t[0], U) }(o.pointers, r) : 0, e.maxPointers = n.prevInput ? e.pointers.length > n.prevInput.maxPointers ? e.pointers.length : n.prevInput.maxPointers : e.pointers.length, function (t, e) { var n, r, s, i, o = t.lastInterval || e, a = e.timeStamp - o.timeStamp; if (8 != e.eventType && (a > 25 || void 0 === o.velocity)) { var l = e.deltaX - o.deltaX, c = e.deltaY - o.deltaY, h = q(a, l, c); r = h.x, s = h.y, n = d(h.x) > d(h.y) ? h.x : h.y, i = W(l, c), t.lastInterval = e } else n = o.velocity, r = o.velocityX, s = o.velocityY, i = o.direction; e.velocity = n, e.velocityX = r, e.velocityY = s, e.direction = i }(n, e); var f = t.element; T(e.srcEvent.target, f) && (f = e.srcEvent.target), e.target = f }(t, n), t.emit("hammer.input", n), t.recognize(n), t.session.prevInput = n } function V(t) { for (var e = [], n = 0; n < t.pointers.length;)e[n] = { clientX: u(t.pointers[n].clientX), clientY: u(t.pointers[n].clientY) }, n++; return { timeStamp: p(), pointers: e, center: z(e), deltaX: t.deltaX, deltaY: t.deltaY } } function z(t) { var e = t.length; if (1 === e) return { x: u(t[0].clientX), y: u(t[0].clientY) }; for (var n = 0, r = 0, s = 0; s < e;)n += t[s].clientX, r += t[s].clientY, s++; return { x: u(n / e), y: u(r / e) } } function q(t, e, n) { return { x: e / t || 0, y: n / t || 0 } } function W(t, e) { return t === e ? 1 : d(t) >= d(e) ? t < 0 ? 2 : 4 : e < 0 ? 8 : 16 } function Q(t, e, n) { n || (n = j); var r = e[n[0]] - t[n[0]], s = e[n[1]] - t[n[1]]; return Math.sqrt(r * r + s * s) } function K(t, e, n) { return n || (n = j), 180 * Math.atan2(e[n[1]] - t[n[1]], e[n[0]] - t[n[0]]) / Math.PI } B.prototype = { handler: function () { }, init: function () { this.evEl && C(this.element, this.evEl, this.domHandler), this.evTarget && C(this.target, this.evTarget, this.domHandler), this.evWin && C(D(this.element), this.evWin, this.domHandler) }, destroy: function () { this.evEl && x(this.element, this.evEl, this.domHandler), this.evTarget && x(this.target, this.evTarget, this.domHandler), this.evWin && x(D(this.element), this.evWin, this.domHandler) } }; var Z = { mousedown: 1, mousemove: 2, mouseup: 4 }; function G() { this.evEl = "mousedown", this.evWin = "mousemove mouseup", this.pressed = !1, B.apply(this, arguments) } b(G, B, { handler: function (t) { var e = Z[t.type]; 1 & e && 0 === t.button && (this.pressed = !0), 2 & e && 1 !== t.which && (e = 4), this.pressed && (4 & e && (this.pressed = !1), this.callback(this.manager, e, { pointers: [t], changedPointers: [t], pointerType: "mouse", srcEvent: t })) } }); var Y = { pointerdown: 1, pointermove: 2, pointerup: 4, pointercancel: 8, pointerout: 8 }, X = { 2: "touch", 3: "pen", 4: "mouse", 5: "kinect" }, $ = "pointerdown", J = "pointermove pointerup pointercancel"; function tt() { this.evEl = $, this.evWin = J, B.apply(this, arguments), this.store = this.manager.session.pointerEvents = [] } s.MSPointerEvent && !s.PointerEvent && ($ = "MSPointerDown", J = "MSPointerMove MSPointerUp MSPointerCancel"), b(tt, B, { handler: function (t) { var e = this.store, n = !1, r = t.type.toLowerCase().replace("ms", ""), s = Y[r], i = X[t.pointerType] || t.pointerType, o = "touch" == i, a = R(e, t.pointerId, "pointerId"); 1 & s && (0 === t.button || o) ? a < 0 && (e.push(t), a = e.length - 1) : 12 & s && (n = !0), a < 0 || (e[a] = t, this.callback(this.manager, s, { pointers: e, changedPointers: [t], pointerType: i, srcEvent: t }), n && e.splice(a, 1)) } }); var et = { touchstart: 1, touchmove: 2, touchend: 4, touchcancel: 8 }; function nt() { this.evTarget = "touchstart", this.evWin = "touchstart touchmove touchend touchcancel", this.started = !1, B.apply(this, arguments) } function rt(t, e) { var n = P(t.touches), r = P(t.changedTouches); return 12 & e && (n = I(n.concat(r), "identifier", !0)), [n, r] } b(nt, B, { handler: function (t) { var e = et[t.type]; if (1 === e && (this.started = !0), this.started) { var n = rt.call(this, t, e); 12 & e && n[0].length - n[1].length == 0 && (this.started = !1), this.callback(this.manager, e, { pointers: n[0], changedPointers: n[1], pointerType: "touch", srcEvent: t }) } } }); var st = { touchstart: 1, touchmove: 2, touchend: 4, touchcancel: 8 }; function it() { this.evTarget = "touchstart touchmove touchend touchcancel", this.targetIds = {}, B.apply(this, arguments) } function ot(t, e) { var n = P(t.touches), r = this.targetIds; if (3 & e && 1 === n.length) return r[n[0].identifier] = !0, [n, n]; var s, i, o = P(t.changedTouches), a = [], l = this.target; if (i = n.filter((function (t) { return T(t.target, l) })), 1 === e) for (s = 0; s < i.length;)r[i[s].identifier] = !0, s++; for (s = 0; s < o.length;)r[o[s].identifier] && a.push(o[s]), 12 & e && delete r[o[s].identifier], s++; return a.length ? [I(i.concat(a), "identifier", !0), a] : void 0 } function at() { B.apply(this, arguments); var t = w(this.handler, this); this.touch = new it(this.manager, t), this.mouse = new G(this.manager, t), this.primaryTouch = null, this.lastTouches = [] } function lt(t, e) { 1 & t ? (this.primaryTouch = e.changedPointers[0].identifier, ct.call(this, e)) : 12 & t && ct.call(this, e) } function ct(t) { var e = t.changedPointers[0]; if (e.identifier === this.primaryTouch) { var n = { x: e.clientX, y: e.clientY }; this.lastTouches.push(n); var r = this.lastTouches; setTimeout((function () { var t = r.indexOf(n); t > -1 && r.splice(t, 1) }), 2500) } } function ht(t) { for (var e = t.srcEvent.clientX, n = t.srcEvent.clientY, r = 0; r < this.lastTouches.length; r++) { var s = this.lastTouches[r], i = Math.abs(e - s.x), o = Math.abs(n - s.y); if (i <= 25 && o <= 25) return !0 } return !1 } b(it, B, { handler: function (t) { var e = st[t.type], n = ot.call(this, t, e); n && this.callback(this.manager, e, { pointers: n[0], changedPointers: n[1], pointerType: "touch", srcEvent: t }) } }), b(at, B, { handler: function (t, e, n) { var r = "mouse" == n.pointerType; if (!(r && n.sourceCapabilities && n.sourceCapabilities.firesTouchEvents)) { if ("touch" == n.pointerType) lt.call(this, e, n); else if (r && ht.call(this, n)) return; this.callback(t, e, n) } }, destroy: function () { this.touch.destroy(), this.mouse.destroy() } }); var ut = O(h.style, "touchAction"), dt = void 0 !== ut, pt = function () { if (!dt) return !1; var t = {}, e = s.CSS && s.CSS.supports; return ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach((function (n) { t[n] = !e || s.CSS.supports("touch-action", n) })), t }(); function ft(t, e) { this.manager = t, this.set(e) } function mt(t) { this.options = l({}, this.defaults, t || {}), this.id = N++, this.manager = null, this.options.enable = E(this.options.enable, !0), this.state = 1, this.simultaneous = {}, this.requireFail = [] } function gt(t) { return 16 & t ? "cancel" : 8 & t ? "end" : 4 & t ? "move" : 2 & t ? "start" : "" } function yt(t) { return 16 == t ? "down" : 8 == t ? "up" : 2 == t ? "left" : 4 == t ? "right" : "" } function _t(t, e) { var n = e.manager; return n ? n.get(t) : t } function vt() { mt.apply(this, arguments) } function bt() { vt.apply(this, arguments), this.pX = null, this.pY = null } function wt() { vt.apply(this, arguments) } function St() { mt.apply(this, arguments), this._timer = null, this._input = null } function Et() { vt.apply(this, arguments) } function Ct() { vt.apply(this, arguments) } function xt() { mt.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0 } function Tt(t, e) { return (e = e || {}).recognizers = E(e.recognizers, Tt.defaults.preset), new kt(t, e) } function kt(t, e) { var n; this.options = l({}, Tt.defaults, e || {}), this.options.inputTarget = this.options.inputTarget || t, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = t, this.input = new ((n = this).options.inputClass || (M ? tt : L ? it : F ? at : G))(n, H), this.touchAction = new ft(this, this.options.touchAction), At(this, !0), g(this.options.recognizers, (function (t) { var e = this.add(new t[0](t[1])); t[2] && e.recognizeWith(t[2]), t[3] && e.requireFailure(t[3]) }), this) } function At(t, e) { var n, r = t.element; r.style && (g(t.options.cssProps, (function (s, i) { n = O(r.style, i), e ? (t.oldCssProps[n] = r.style[n], r.style[n] = s) : r.style[n] = t.oldCssProps[n] || "" })), e || (t.oldCssProps = {})) } ft.prototype = { set: function (t) { "compute" == t && (t = this.compute()), dt && this.manager.element.style && pt[t] && (this.manager.element.style[ut] = t), this.actions = t.toLowerCase().trim() }, update: function () { this.set(this.manager.options.touchAction) }, compute: function () { var t = []; return g(this.manager.recognizers, (function (e) { S(e.options.enable, [e]) && (t = t.concat(e.getTouchAction())) })), function (t) { if (k(t, "none")) return "none"; var e = k(t, "pan-x"), n = k(t, "pan-y"); return e && n ? "none" : e || n ? e ? "pan-x" : "pan-y" : k(t, "manipulation") ? "manipulation" : "auto" }(t.join(" ")) }, preventDefaults: function (t) { var e = t.srcEvent, n = t.offsetDirection; if (this.manager.session.prevented) e.preventDefault(); else { var r = this.actions, s = k(r, "none") && !pt.none, i = k(r, "pan-y") && !pt["pan-y"], o = k(r, "pan-x") && !pt["pan-x"]; if (s && 1 === t.pointers.length && t.distance < 2 && t.deltaTime < 250) return; if (!o || !i) return s || i && 6 & n || o && 24 & n ? this.preventSrc(e) : void 0 } }, preventSrc: function (t) { this.manager.session.prevented = !0, t.preventDefault() } }, mt.prototype = { defaults: {}, set: function (t) { return l(this.options, t), this.manager && this.manager.touchAction.update(), this }, recognizeWith: function (t) { if (m(t, "recognizeWith", this)) return this; var e = this.simultaneous; return e[(t = _t(t, this)).id] || (e[t.id] = t, t.recognizeWith(this)), this }, dropRecognizeWith: function (t) { return m(t, "dropRecognizeWith", this) ? this : (t = _t(t, this), delete this.simultaneous[t.id], this) }, requireFailure: function (t) { if (m(t, "requireFailure", this)) return this; var e = this.requireFail; return -1 === R(e, t = _t(t, this)) && (e.push(t), t.requireFailure(this)), this }, dropRequireFailure: function (t) { if (m(t, "dropRequireFailure", this)) return this; t = _t(t, this); var e = R(this.requireFail, t); return e > -1 && this.requireFail.splice(e, 1), this }, hasRequireFailures: function () { return this.requireFail.length > 0 }, canRecognizeWith: function (t) { return !!this.simultaneous[t.id] }, emit: function (t) { var e = this, n = this.state; function r(n) { e.manager.emit(n, t) } n < 8 && r(e.options.event + gt(n)), r(e.options.event), t.additionalEvent && r(t.additionalEvent), n >= 8 && r(e.options.event + gt(n)) }, tryEmit: function (t) { if (this.canEmit()) return this.emit(t); this.state = 32 }, canEmit: function () { for (var t = 0; t < this.requireFail.length;) { if (!(33 & this.requireFail[t].state)) return !1; t++ } return !0 }, recognize: function (t) { var e = l({}, t); if (!S(this.options.enable, [this, e])) return this.reset(), void (this.state = 32); 56 & this.state && (this.state = 1), this.state = this.process(e), 30 & this.state && this.tryEmit(e) }, process: function (t) { }, getTouchAction: function () { }, reset: function () { } }, b(vt, mt, { defaults: { pointers: 1 }, attrTest: function (t) { var e = this.options.pointers; return 0 === e || t.pointers.length === e }, process: function (t) { var e = this.state, n = t.eventType, r = 6 & e, s = this.attrTest(t); return r && (8 & n || !s) ? 16 | e : r || s ? 4 & n ? 8 | e : 2 & e ? 4 | e : 2 : 32 } }), b(bt, vt, { defaults: { event: "pan", threshold: 10, pointers: 1, direction: 30 }, getTouchAction: function () { var t = this.options.direction, e = []; return 6 & t && e.push("pan-y"), 24 & t && e.push("pan-x"), e }, directionTest: function (t) { var e = this.options, n = !0, r = t.distance, s = t.direction, i = t.deltaX, o = t.deltaY; return s & e.direction || (6 & e.direction ? (s = 0 === i ? 1 : i < 0 ? 2 : 4, n = i != this.pX, r = Math.abs(t.deltaX)) : (s = 0 === o ? 1 : o < 0 ? 8 : 16, n = o != this.pY, r = Math.abs(t.deltaY))), t.direction = s, n && r > e.threshold && s & e.direction }, attrTest: function (t) { return vt.prototype.attrTest.call(this, t) && (2 & this.state || !(2 & this.state) && this.directionTest(t)) }, emit: function (t) { this.pX = t.deltaX, this.pY = t.deltaY; var e = yt(t.direction); e && (t.additionalEvent = this.options.event + e), this._super.emit.call(this, t) } }), b(wt, vt, { defaults: { event: "pinch", threshold: 0, pointers: 2 }, getTouchAction: function () { return ["none"] }, attrTest: function (t) { return this._super.attrTest.call(this, t) && (Math.abs(t.scale - 1) > this.options.threshold || 2 & this.state) }, emit: function (t) { 1 !== t.scale && (t.additionalEvent = this.options.event + (t.scale < 1 ? "in" : "out")), this._super.emit.call(this, t) } }), b(St, mt, { defaults: { event: "press", pointers: 1, time: 251, threshold: 9 }, getTouchAction: function () { return ["auto"] }, process: function (t) { var e = this.options, n = t.pointers.length === e.pointers, r = t.distance < e.threshold, s = t.deltaTime > e.time; if (this._input = t, !r || !n || 12 & t.eventType && !s) this.reset(); else if (1 & t.eventType) this.reset(), this._timer = f((function () { this.state = 8, this.tryEmit() }), e.time, this); else if (4 & t.eventType) return 8; return 32 }, reset: function () { clearTimeout(this._timer) }, emit: function (t) { 8 === this.state && (t && 4 & t.eventType ? this.manager.emit(this.options.event + "up", t) : (this._input.timeStamp = p(), this.manager.emit(this.options.event, this._input))) } }), b(Et, vt, { defaults: { event: "rotate", threshold: 0, pointers: 2 }, getTouchAction: function () { return ["none"] }, attrTest: function (t) { return this._super.attrTest.call(this, t) && (Math.abs(t.rotation) > this.options.threshold || 2 & this.state) } }), b(Ct, vt, { defaults: { event: "swipe", threshold: 10, velocity: .3, direction: 30, pointers: 1 }, getTouchAction: function () { return bt.prototype.getTouchAction.call(this) }, attrTest: function (t) { var e, n = this.options.direction; return 30 & n ? e = t.overallVelocity : 6 & n ? e = t.overallVelocityX : 24 & n && (e = t.overallVelocityY), this._super.attrTest.call(this, t) && n & t.offsetDirection && t.distance > this.options.threshold && t.maxPointers == this.options.pointers && d(e) > this.options.velocity && 4 & t.eventType }, emit: function (t) { var e = yt(t.offsetDirection); e && this.manager.emit(this.options.event + e, t), this.manager.emit(this.options.event, t) } }), b(xt, mt, { defaults: { event: "tap", pointers: 1, taps: 1, interval: 300, time: 250, threshold: 9, posThreshold: 10 }, getTouchAction: function () { return ["manipulation"] }, process: function (t) { var e = this.options, n = t.pointers.length === e.pointers, r = t.distance < e.threshold, s = t.deltaTime < e.time; if (this.reset(), 1 & t.eventType && 0 === this.count) return this.failTimeout(); if (r && s && n) { if (4 != t.eventType) return this.failTimeout(); var i = !this.pTime || t.timeStamp - this.pTime < e.interval, o = !this.pCenter || Q(this.pCenter, t.center) < e.posThreshold; if (this.pTime = t.timeStamp, this.pCenter = t.center, o && i ? this.count += 1 : this.count = 1, this._input = t, 0 == this.count % e.taps) return this.hasRequireFailures() ? (this._timer = f((function () { this.state = 8, this.tryEmit() }), e.interval, this), 2) : 8 } return 32 }, failTimeout: function () { return this._timer = f((function () { this.state = 32 }), this.options.interval, this), 32 }, reset: function () { clearTimeout(this._timer) }, emit: function () { 8 == this.state && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input)) } }), Tt.VERSION = "2.0.7", Tt.defaults = { domEvents: !1, touchAction: "compute", enable: !0, inputTarget: null, inputClass: null, preset: [[Et, { enable: !1 }], [wt, { enable: !1 }, ["rotate"]], [Ct, { direction: 6 }], [bt, { direction: 6 }, ["swipe"]], [xt], [xt, { event: "doubletap", taps: 2 }, ["tap"]], [St]], cssProps: { userSelect: "none", touchSelect: "none", touchCallout: "none", contentZooming: "none", userDrag: "none", tapHighlightColor: "rgba(0,0,0,0)" } }, kt.prototype = { set: function (t) { return l(this.options, t), t.touchAction && this.touchAction.update(), t.inputTarget && (this.input.destroy(), this.input.target = t.inputTarget, this.input.init()), this }, stop: function (t) { this.session.stopped = t ? 2 : 1 }, recognize: function (t) { var e = this.session; if (!e.stopped) { var n; this.touchAction.preventDefaults(t); var r = this.recognizers, s = e.curRecognizer; (!s || s && 8 & s.state) && (s = e.curRecognizer = null); for (var i = 0; i < r.length;)n = r[i], 2 === e.stopped || s && n != s && !n.canRecognizeWith(s) ? n.reset() : n.recognize(t), !s && 14 & n.state && (s = e.curRecognizer = n), i++ } }, get: function (t) { if (t instanceof mt) return t; for (var e = this.recognizers, n = 0; n < e.length; n++)if (e[n].options.event == t) return e[n]; return null }, add: function (t) { if (m(t, "add", this)) return this; var e = this.get(t.options.event); return e && this.remove(e), this.recognizers.push(t), t.manager = this, this.touchAction.update(), t }, remove: function (t) { if (m(t, "remove", this)) return this; if (t = this.get(t)) { var e = this.recognizers, n = R(e, t); -1 !== n && (e.splice(n, 1), this.touchAction.update()) } return this }, on: function (t, e) { if (void 0 !== t && void 0 !== e) { var n = this.handlers; return g(A(t), (function (t) { n[t] = n[t] || [], n[t].push(e) })), this } }, off: function (t, e) { if (void 0 !== t) { var n = this.handlers; return g(A(t), (function (t) { e ? n[t] && n[t].splice(R(n[t], e), 1) : delete n[t] })), this } }, emit: function (t, e) { this.options.domEvents && function (t, e) { var n = i.createEvent("Event"); n.initEvent(t, !0, !0), n.gesture = e, e.target.dispatchEvent(n) }(t, e); var n = this.handlers[t] && this.handlers[t].slice(); if (n && n.length) { e.type = t, e.preventDefault = function () { e.srcEvent.preventDefault() }; for (var r = 0; r < n.length;)n[r](e), r++ } }, destroy: function () { this.element && At(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null } }, l(Tt, { INPUT_START: 1, INPUT_MOVE: 2, INPUT_END: 4, INPUT_CANCEL: 8, STATE_POSSIBLE: 1, STATE_BEGAN: 2, STATE_CHANGED: 4, STATE_ENDED: 8, STATE_RECOGNIZED: 8, STATE_CANCELLED: 16, STATE_FAILED: 32, DIRECTION_NONE: 1, DIRECTION_LEFT: 2, DIRECTION_RIGHT: 4, DIRECTION_UP: 8, DIRECTION_DOWN: 16, DIRECTION_HORIZONTAL: 6, DIRECTION_VERTICAL: 24, DIRECTION_ALL: 30, Manager: kt, Input: B, TouchAction: ft, TouchInput: it, MouseInput: G, PointerEventInput: tt, TouchMouseInput: at, SingleTouchInput: nt, Recognizer: mt, AttrRecognizer: vt, Tap: xt, Pan: bt, Swipe: Ct, Pinch: wt, Rotate: Et, Press: St, on: C, off: x, each: g, merge: v, extend: _, assign: l, inherit: b, bindFn: w, prefixed: O }), (void 0 !== s ? s : "undefined" != typeof self ? self : {}).Hammer = Tt, void 0 === (r = (function () { return Tt }).call(e, n, e, t)) || (t.exports = r) }(window, document) }, zUnb: function (t, e, n) { "use strict"; function r(t) { return "function" == typeof t } n.r(e), n("yLV6"); let s = !1; const i = { Promise: void 0, set useDeprecatedSynchronousErrorHandling(t) { if (t) { const t = new Error; console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n" + t.stack) } else s && console.log("RxJS: Back to a better error behavior. Thank you. <3"); s = t }, get useDeprecatedSynchronousErrorHandling() { return s } }; function o(t) { setTimeout(() => { throw t }) } const a = { closed: !0, next(t) { }, error(t) { if (i.useDeprecatedSynchronousErrorHandling) throw t; o(t) }, complete() { } }, l = Array.isArray || (t => t && "number" == typeof t.length); function c(t) { return null !== t && "object" == typeof t } function h(t) { return Error.call(this), this.message = t ? "".concat(t.length, " errors occurred during unsubscription:\n").concat(t.map((t, e) => "".concat(e + 1, ") ").concat(t.toString())).join("\n  ")) : "", this.name = "UnsubscriptionError", this.errors = t, this } h.prototype = Object.create(Error.prototype); const u = h; let d = (() => { class t { constructor(t) { this.closed = !1, this._parent = null, this._parents = null, this._subscriptions = null, t && (this._unsubscribe = t) } unsubscribe() { let t, e = !1; if (this.closed) return; let { _parent: n, _parents: s, _unsubscribe: i, _subscriptions: o } = this; this.closed = !0, this._parent = null, this._parents = null, this._subscriptions = null; let a = -1, h = s ? s.length : 0; for (; n;)n.remove(this), n = ++a < h && s[a] || null; if (r(i)) try { i.call(this) } catch (d) { e = !0, t = d instanceof u ? p(d.errors) : [d] } if (l(o)) for (a = -1, h = o.length; ++a < h;) { const n = o[a]; if (c(n)) try { n.unsubscribe() } catch (d) { e = !0, t = t || [], d instanceof u ? t = t.concat(p(d.errors)) : t.push(d) } } if (e) throw new u(t) } add(e) { let n = e; switch (typeof e) { case "function": n = new t(e); case "object": if (n === this || n.closed || "function" != typeof n.unsubscribe) return n; if (this.closed) return n.unsubscribe(), n; if (!(n instanceof t)) { const e = n; n = new t, n._subscriptions = [e] } break; default: if (!e) return t.EMPTY; throw new Error("unrecognized teardown " + e + " added to Subscription.") }if (n._addParent(this)) { const t = this._subscriptions; t ? t.push(n) : this._subscriptions = [n] } return n } remove(t) { const e = this._subscriptions; if (e) { const n = e.indexOf(t); -1 !== n && e.splice(n, 1) } } _addParent(t) { let { _parent: e, _parents: n } = this; return e !== t && (e ? n ? -1 === n.indexOf(t) && (n.push(t), !0) : (this._parents = [t], !0) : (this._parent = t, !0)) } } return t.EMPTY = function (t) { return t.closed = !0, t }(new t), t })(); function p(t) { return t.reduce((t, e) => t.concat(e instanceof u ? e.errors : e), []) } const f = "function" == typeof Symbol ? Symbol("rxSubscriber") : "@@rxSubscriber_" + Math.random(); class m extends d { constructor(t, e, n) { switch (super(), this.syncErrorValue = null, this.syncErrorThrown = !1, this.syncErrorThrowable = !1, this.isStopped = !1, arguments.length) { case 0: this.destination = a; break; case 1: if (!t) { this.destination = a; break } if ("object" == typeof t) { t instanceof m ? (this.syncErrorThrowable = t.syncErrorThrowable, this.destination = t, t.add(this)) : (this.syncErrorThrowable = !0, this.destination = new g(this, t)); break } default: this.syncErrorThrowable = !0, this.destination = new g(this, t, e, n) } } [f]() { return this } static create(t, e, n) { const r = new m(t, e, n); return r.syncErrorThrowable = !1, r } next(t) { this.isStopped || this._next(t) } error(t) { this.isStopped || (this.isStopped = !0, this._error(t)) } complete() { this.isStopped || (this.isStopped = !0, this._complete()) } unsubscribe() { this.closed || (this.isStopped = !0, super.unsubscribe()) } _next(t) { this.destination.next(t) } _error(t) { this.destination.error(t), this.unsubscribe() } _complete() { this.destination.complete(), this.unsubscribe() } _unsubscribeAndRecycle() { const { _parent: t, _parents: e } = this; return this._parent = null, this._parents = null, this.unsubscribe(), this.closed = !1, this.isStopped = !1, this._parent = t, this._parents = e, this } } class g extends m { constructor(t, e, n, s) { let i; super(), this._parentSubscriber = t; let o = this; r(e) ? i = e : e && (i = e.next, n = e.error, s = e.complete, e !== a && (o = Object.create(e), r(o.unsubscribe) && this.add(o.unsubscribe.bind(o)), o.unsubscribe = this.unsubscribe.bind(this))), this._context = o, this._next = i, this._error = n, this._complete = s } next(t) { if (!this.isStopped && this._next) { const { _parentSubscriber: e } = this; i.useDeprecatedSynchronousErrorHandling && e.syncErrorThrowable ? this.__tryOrSetError(e, this._next, t) && this.unsubscribe() : this.__tryOrUnsub(this._next, t) } } error(t) { if (!this.isStopped) { const { _parentSubscriber: e } = this, { useDeprecatedSynchronousErrorHandling: n } = i; if (this._error) n && e.syncErrorThrowable ? (this.__tryOrSetError(e, this._error, t), this.unsubscribe()) : (this.__tryOrUnsub(this._error, t), this.unsubscribe()); else if (e.syncErrorThrowable) n ? (e.syncErrorValue = t, e.syncErrorThrown = !0) : o(t), this.unsubscribe(); else { if (this.unsubscribe(), n) throw t; o(t) } } } complete() { if (!this.isStopped) { const { _parentSubscriber: t } = this; if (this._complete) { const e = () => this._complete.call(this._context); i.useDeprecatedSynchronousErrorHandling && t.syncErrorThrowable ? (this.__tryOrSetError(t, e), this.unsubscribe()) : (this.__tryOrUnsub(e), this.unsubscribe()) } else this.unsubscribe() } } __tryOrUnsub(t, e) { try { t.call(this._context, e) } catch (n) { if (this.unsubscribe(), i.useDeprecatedSynchronousErrorHandling) throw n; o(n) } } __tryOrSetError(t, e, n) { if (!i.useDeprecatedSynchronousErrorHandling) throw new Error("bad call"); try { e.call(this._context, n) } catch (r) { return i.useDeprecatedSynchronousErrorHandling ? (t.syncErrorValue = r, t.syncErrorThrown = !0, !0) : (o(r), !0) } return !1 } _unsubscribe() { const { _parentSubscriber: t } = this; this._context = null, this._parentSubscriber = null, t.unsubscribe() } } const y = "function" == typeof Symbol && Symbol.observable || "@@observable"; function _() { } function v(...t) { return b(t) } function b(t) { return t ? 1 === t.length ? t[0] : function (e) { return t.reduce((t, e) => e(t), e) } : _ } let w = (() => { class t { constructor(t) { this._isScalar = !1, t && (this._subscribe = t) } lift(e) { const n = new t; return n.source = this, n.operator = e, n } subscribe(t, e, n) { const { operator: r } = this, s = function (t, e, n) { if (t) { if (t instanceof m) return t; if (t[f]) return t[f]() } return t || e || n ? new m(t, e, n) : new m(a) }(t, e, n); if (s.add(r ? r.call(s, this.source) : this.source || i.useDeprecatedSynchronousErrorHandling && !s.syncErrorThrowable ? this._subscribe(s) : this._trySubscribe(s)), i.useDeprecatedSynchronousErrorHandling && s.syncErrorThrowable && (s.syncErrorThrowable = !1, s.syncErrorThrown)) throw s.syncErrorValue; return s } _trySubscribe(t) { try { return this._subscribe(t) } catch (e) { i.useDeprecatedSynchronousErrorHandling && (t.syncErrorThrown = !0, t.syncErrorValue = e), function (t) { for (; t;) { const { closed: e, destination: n, isStopped: r } = t; if (e || r) return !1; t = n && n instanceof m ? n : null } return !0 }(t) ? t.error(e) : console.warn(e) } } forEach(t, e) { return new (e = S(e))((e, n) => { let r; r = this.subscribe(e => { try { t(e) } catch (s) { n(s), r && r.unsubscribe() } }, n, e) }) } _subscribe(t) { const { source: e } = this; return e && e.subscribe(t) } [y]() { return this } pipe(...t) { return 0 === t.length ? this : b(t)(this) } toPromise(t) { return new (t = S(t))((t, e) => { let n; this.subscribe(t => n = t, t => e(t), () => t(n)) }) } } return t.create = e => new t(e), t })(); function S(t) { if (t || (t = i.Promise || Promise), !t) throw new Error("no Promise impl found"); return t } function E() { return Error.call(this), this.message = "object unsubscribed", this.name = "ObjectUnsubscribedError", this } E.prototype = Object.create(Error.prototype); const C = E; class x extends d { constructor(t, e) { super(), this.subject = t, this.subscriber = e, this.closed = !1 } unsubscribe() { if (this.closed) return; this.closed = !0; const t = this.subject, e = t.observers; if (this.subject = null, !e || 0 === e.length || t.isStopped || t.closed) return; const n = e.indexOf(this.subscriber); -1 !== n && e.splice(n, 1) } } class T extends m { constructor(t) { super(t), this.destination = t } } let k = (() => { class t extends w { constructor() { super(), this.observers = [], this.closed = !1, this.isStopped = !1, this.hasError = !1, this.thrownError = null } [f]() { return new T(this) } lift(t) { const e = new A(this, this); return e.operator = t, e } next(t) { if (this.closed) throw new C; if (!this.isStopped) { const { observers: e } = this, n = e.length, r = e.slice(); for (let s = 0; s < n; s++)r[s].next(t) } } error(t) { if (this.closed) throw new C; this.hasError = !0, this.thrownError = t, this.isStopped = !0; const { observers: e } = this, n = e.length, r = e.slice(); for (let s = 0; s < n; s++)r[s].error(t); this.observers.length = 0 } complete() { if (this.closed) throw new C; this.isStopped = !0; const { observers: t } = this, e = t.length, n = t.slice(); for (let r = 0; r < e; r++)n[r].complete(); this.observers.length = 0 } unsubscribe() { this.isStopped = !0, this.closed = !0, this.observers = null } _trySubscribe(t) { if (this.closed) throw new C; return super._trySubscribe(t) } _subscribe(t) { if (this.closed) throw new C; return this.hasError ? (t.error(this.thrownError), d.EMPTY) : this.isStopped ? (t.complete(), d.EMPTY) : (this.observers.push(t), new x(this, t)) } asObservable() { const t = new w; return t.source = this, t } } return t.create = (t, e) => new A(t, e), t })(); class A extends k { constructor(t, e) { super(), this.destination = t, this.source = e } next(t) { const { destination: e } = this; e && e.next && e.next(t) } error(t) { const { destination: e } = this; e && e.error && this.destination.error(t) } complete() { const { destination: t } = this; t && t.complete && this.destination.complete() } _subscribe(t) { const { source: e } = this; return e ? this.source.subscribe(t) : d.EMPTY } } function R(t) { return t && "function" == typeof t.schedule } class P extends m { constructor(t, e, n) { super(), this.parent = t, this.outerValue = e, this.outerIndex = n, this.index = 0 } _next(t) { this.parent.notifyNext(this.outerValue, t, this.outerIndex, this.index++, this) } _error(t) { this.parent.notifyError(t, this), this.unsubscribe() } _complete() { this.parent.notifyComplete(this), this.unsubscribe() } } const I = t => e => { for (let n = 0, r = t.length; n < r && !e.closed; n++)e.next(t[n]); e.closed || e.complete() }, O = t => e => (t.then(t => { e.closed || (e.next(t), e.complete()) }, t => e.error(t)).then(null, o), e); const N = "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator", D = t => e => { const n = t[N](); for (; ;) { const t = n.next(); if (t.done) { e.complete(); break } if (e.next(t.value), e.closed) break } return "function" == typeof n.return && e.add(() => { n.return && n.return() }), e }, F = t => e => { const n = t[y](); if ("function" != typeof n.subscribe) throw new TypeError("Provided object does not correctly implement Symbol.observable"); return n.subscribe(e) }, M = t => t && "number" == typeof t.length && "function" != typeof t; function L(t) { return !!t && "function" != typeof t.subscribe && "function" == typeof t.then } const j = t => { if (t instanceof w) return e => t._isScalar ? (e.next(t.value), void e.complete()) : t.subscribe(e); if (t && "function" == typeof t[y]) return F(t); if (M(t)) return I(t); if (L(t)) return O(t); if (t && "function" == typeof t[N]) return D(t); { const e = c(t) ? "an invalid object" : "'".concat(t, "'"); throw new TypeError("You provided ".concat(e, " where a stream was expected.") + " You can provide an Observable, Promise, Array, or Iterable.") } }; function U(t, e, n, r, s = new P(t, n, r)) { if (!s.closed) return j(e)(s) } class B extends m { notifyNext(t, e, n, r, s) { this.destination.next(e) } notifyError(t, e) { this.destination.error(t) } notifyComplete(t) { this.destination.complete() } } function H(t, e) { return function (n) { if ("function" != typeof t) throw new TypeError("argument is not a function. Are you looking for `mapTo()`?"); return n.lift(new V(t, e)) } } class V { constructor(t, e) { this.project = t, this.thisArg = e } call(t, e) { return e.subscribe(new z(t, this.project, this.thisArg)) } } class z extends m { constructor(t, e, n) { super(t), this.project = e, this.count = 0, this.thisArg = n || this } _next(t) { let e; try { e = this.project.call(this.thisArg, t, this.count++) } catch (n) { return void this.destination.error(n) } this.destination.next(e) } } function q(t, e) { return new w(e ? n => { const r = new d; let s = 0; return r.add(e.schedule((function () { s !== t.length ? (n.next(t[s++]), n.closed || r.add(this.schedule())) : n.complete() }))), r } : I(t)) } function W(t, e) { if (!e) return t instanceof w ? t : new w(j(t)); if (null != t) { if (function (t) { return t && "function" == typeof t[y] }(t)) return function (t, e) { return new w(e ? n => { const r = new d; return r.add(e.schedule(() => { const s = t[y](); r.add(s.subscribe({ next(t) { r.add(e.schedule(() => n.next(t))) }, error(t) { r.add(e.schedule(() => n.error(t))) }, complete() { r.add(e.schedule(() => n.complete())) } })) })), r } : F(t)) }(t, e); if (L(t)) return function (t, e) { return new w(e ? n => { const r = new d; return r.add(e.schedule(() => t.then(t => { r.add(e.schedule(() => { n.next(t), r.add(e.schedule(() => n.complete())) })) }, t => { r.add(e.schedule(() => n.error(t))) }))), r } : O(t)) }(t, e); if (M(t)) return q(t, e); if (function (t) { return t && "function" == typeof t[N] }(t) || "string" == typeof t) return function (t, e) { if (!t) throw new Error("Iterable cannot be null"); return new w(e ? n => { const r = new d; let s; return r.add(() => { s && "function" == typeof s.return && s.return() }), r.add(e.schedule(() => { s = t[N](), r.add(e.schedule((function () { if (n.closed) return; let t, e; try { const n = s.next(); t = n.value, e = n.done } catch (r) { return void n.error(r) } e ? n.complete() : (n.next(t), this.schedule()) }))) })), r } : D(t)) }(t, e) } throw new TypeError((null !== t && typeof t || t) + " is not observable") } function Q(t, e, n = Number.POSITIVE_INFINITY) { return "function" == typeof e ? r => r.pipe(Q((n, r) => W(t(n, r)).pipe(H((t, s) => e(n, t, r, s))), n)) : ("number" == typeof e && (n = e), e => e.lift(new K(t, n))) } class K { constructor(t, e = Number.POSITIVE_INFINITY) { this.project = t, this.concurrent = e } call(t, e) { return e.subscribe(new Z(t, this.project, this.concurrent)) } } class Z extends B { constructor(t, e, n = Number.POSITIVE_INFINITY) { super(t), this.project = e, this.concurrent = n, this.hasCompleted = !1, this.buffer = [], this.active = 0, this.index = 0 } _next(t) { this.active < this.concurrent ? this._tryNext(t) : this.buffer.push(t) } _tryNext(t) { let e; const n = this.index++; try { e = this.project(t, n) } catch (r) { return void this.destination.error(r) } this.active++, this._innerSub(e, t, n) } _innerSub(t, e, n) { const r = new P(this, void 0, void 0); this.destination.add(r), U(this, t, e, n, r) } _complete() { this.hasCompleted = !0, 0 === this.active && 0 === this.buffer.length && this.destination.complete(), this.unsubscribe() } notifyNext(t, e, n, r, s) { this.destination.next(e) } notifyComplete(t) { const e = this.buffer; this.remove(t), this.active--, e.length > 0 ? this._next(e.shift()) : 0 === this.active && this.hasCompleted && this.destination.complete() } } function G(t) { return t } function Y(t = Number.POSITIVE_INFINITY) { return Q(G, t) } function X(...t) { let e = Number.POSITIVE_INFINITY, n = null, r = t[t.length - 1]; return R(r) ? (n = t.pop(), t.length > 1 && "number" == typeof t[t.length - 1] && (e = t.pop())) : "number" == typeof r && (e = t.pop()), null === n && 1 === t.length && t[0] instanceof w ? t[0] : Y(e)(q(t, n)) } function $() { return function (t) { return t.lift(new J(t)) } } class J { constructor(t) { this.connectable = t } call(t, e) { const { connectable: n } = this; n._refCount++; const r = new tt(t, n), s = e.subscribe(r); return r.closed || (r.connection = n.connect()), s } } class tt extends m { constructor(t, e) { super(t), this.connectable = e } _unsubscribe() { const { connectable: t } = this; if (!t) return void (this.connection = null); this.connectable = null; const e = t._refCount; if (e <= 0) return void (this.connection = null); if (t._refCount = e - 1, e > 1) return void (this.connection = null); const { connection: n } = this, r = t._connection; this.connection = null, !r || n && r !== n || r.unsubscribe() } } const et = class extends w { constructor(t, e) { super(), this.source = t, this.subjectFactory = e, this._refCount = 0, this._isComplete = !1 } _subscribe(t) { return this.getSubject().subscribe(t) } getSubject() { const t = this._subject; return t && !t.isStopped || (this._subject = this.subjectFactory()), this._subject } connect() { let t = this._connection; return t || (this._isComplete = !1, t = this._connection = new d, t.add(this.source.subscribe(new rt(this.getSubject(), this))), t.closed ? (this._connection = null, t = d.EMPTY) : this._connection = t), t } refCount() { return $()(this) } }.prototype, nt = { operator: { value: null }, _refCount: { value: 0, writable: !0 }, _subject: { value: null, writable: !0 }, _connection: { value: null, writable: !0 }, _subscribe: { value: et._subscribe }, _isComplete: { value: et._isComplete, writable: !0 }, getSubject: { value: et.getSubject }, connect: { value: et.connect }, refCount: { value: et.refCount } }; class rt extends T { constructor(t, e) { super(t), this.connectable = e } _error(t) { this._unsubscribe(), super._error(t) } _complete() { this.connectable._isComplete = !0, this._unsubscribe(), super._complete() } _unsubscribe() { const t = this.connectable; if (t) { this.connectable = null; const e = t._connection; t._refCount = 0, t._subject = null, t._connection = null, e && e.unsubscribe() } } } function st(t, e) { return function (n) { let r; if (r = "function" == typeof t ? t : function () { return t }, "function" == typeof e) return n.lift(new it(r, e)); const s = Object.create(n, nt); return s.source = n, s.subjectFactory = r, s } } class it { constructor(t, e) { this.subjectFactory = t, this.selector = e } call(t, e) { const { selector: n } = this, r = this.subjectFactory(), s = n(r).subscribe(t); return s.add(e.subscribe(r)), s } } function ot() { return new k } function at(t, e, n) { const r = function (t) { return function (...e) { if (t) { const n = t(...e); for (const t in n) this[t] = n[t] } } }(e); function s(...t) { if (this instanceof s) return r.apply(this, t), this; const e = new s(...t); return n.annotation = e, n; function n(t, n, r) { const s = t.hasOwnProperty("__parameters__") ? t.__parameters__ : Object.defineProperty(t, "__parameters__", { value: [] }).__parameters__; for (; s.length <= r;)s.push(null); return (s[r] = s[r] || []).push(e), t } } return n && (s.prototype = Object.create(n.prototype)), s.prototype.ngMetadataName = t, s.annotationCls = s, s } const lt = at("Inject", t => ({ token: t })), ct = at("Optional"), ht = at("Self"), ut = at("SkipSelf"); var dt = function (t) { return t[t.Default = 0] = "Default", t[t.Host = 1] = "Host", t[t.Self = 2] = "Self", t[t.SkipSelf = 4] = "SkipSelf", t[t.Optional = 8] = "Optional", t }({}); function pt(t) { for (let e in t) if (t[e] === pt) return e; throw Error("Could not find renamed property on target object.") } function ft(t) { return { token: t.token, providedIn: t.providedIn || null, factory: t.factory, value: void 0 } } function mt(t) { const e = t[gt]; return e && e.token === t ? e : null } const gt = pt({ ngInjectableDef: pt }); function yt(t) { if ("string" == typeof t) return t; if (t instanceof Array) return "[" + t.map(yt).join(", ") + "]"; if (null == t) return "" + t; if (t.overriddenName) return "".concat(t.overriddenName); if (t.name) return "".concat(t.name); const e = t.toString(); if (null == e) return "" + e; const n = e.indexOf("\n"); return -1 === n ? e : e.substring(0, n) } const _t = pt({ __forward_ref__: pt }); function vt(t) { return t.__forward_ref__ = vt, t.toString = function () { return yt(this()) }, t } function bt(t) { const e = t; return "function" == typeof e && e.hasOwnProperty(_t) && e.__forward_ref__ === vt ? e() : t } const wt = "undefined" != typeof globalThis && globalThis, St = "undefined" != typeof window && window, Et = "undefined" != typeof self && "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && self, Ct = "undefined" != typeof global && global, xt = wt || Ct || St || Et; class Tt { constructor(t, e) { this._desc = t, this.ngMetadataName = "InjectionToken", this.ngInjectableDef = void 0, "number" == typeof e ? this.__NG_ELEMENT_ID__ = e : void 0 !== e && (this.ngInjectableDef = ft({ token: this, providedIn: e.providedIn || "root", factory: e.factory })) } toString() { return "InjectionToken ".concat(this._desc) } } const kt = new Tt("INJECTOR", -1), At = new Object, Rt = /\n/gm, Pt = pt({ provide: String, useValue: pt }); let It = void 0; function Ot(t) { const e = It; return It = t, e } function Nt(t, e = dt.Default) { return function (t, e = dt.Default) { if (void 0 === It) throw new Error("inject() must be called from an injection context"); return null === It ? function (t, e, n) { const r = mt(t); if (r && "root" == r.providedIn) return void 0 === r.value ? r.value = r.factory() : r.value; if (n & dt.Optional) return null; throw new Error("Injector: NOT_FOUND [".concat(yt(t), "]")) }(t, 0, e) : It.get(t, e & dt.Optional ? null : void 0, e) }(t, e) } const Dt = Nt; class Ft { get(t, e = At) { if (e === At) { const e = new Error("NullInjectorError: No provider for ".concat(yt(t), "!")); throw e.name = "NullInjectorError", e } return e } } function Mt(t, e, n, r = null) { t = t && "\n" === t.charAt(0) && "\u0275" == t.charAt(1) ? t.substr(2) : t; let s = yt(e); if (e instanceof Array) s = e.map(yt).join(" -> "); else if ("object" == typeof e) { let t = []; for (let n in e) if (e.hasOwnProperty(n)) { let r = e[n]; t.push(n + ":" + ("string" == typeof r ? JSON.stringify(r) : yt(r))) } s = "{".concat(t.join(", "), "}") } return "".concat(n).concat(r ? "(" + r + ")" : "", "[").concat(s, "]: ").concat(t.replace(Rt, "\n  ")) } class Lt { } class jt { } function Ut(t, e, n) { e >= t.length ? t.push(n) : t.splice(e, 0, n) } function Bt(t, e) { return e >= t.length - 1 ? t.pop() : t.splice(e, 1)[0] } const Ht = function () { var t = { Emulated: 0, Native: 1, None: 2, ShadowDom: 3 }; return t[t.Emulated] = "Emulated", t[t.Native] = "Native", t[t.None] = "None", t[t.ShadowDom] = "ShadowDom", t }(), Vt = ("undefined" != typeof requestAnimationFrame && requestAnimationFrame || setTimeout).bind(xt); function zt(t) { return t.ngDebugContext } function qt(t) { return t.ngOriginalError } function Wt(t, ...e) { t.error(...e) } class Qt { constructor() { this._console = console } handleError(t) { const e = this._findOriginalError(t), n = this._findContext(t), r = function (t) { return t.ngErrorLogger || Wt }(t); r(this._console, "ERROR", t), e && r(this._console, "ORIGINAL ERROR", e), n && r(this._console, "ERROR CONTEXT", n) } _findContext(t) { return t ? zt(t) ? zt(t) : this._findContext(qt(t)) : null } _findOriginalError(t) { let e = qt(t); for (; e && qt(e);)e = qt(e); return e } } let Kt = !0, Zt = !1; function Gt() { return Zt = !0, Kt } class Yt { constructor(t) { if (this.defaultDoc = t, this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert"), this.inertBodyElement = this.inertDocument.body, null == this.inertBodyElement) { const t = this.inertDocument.createElement("html"); this.inertDocument.appendChild(t), this.inertBodyElement = this.inertDocument.createElement("body"), t.appendChild(this.inertBodyElement) } this.inertBodyElement.innerHTML = '<svg><g onload="this.parentNode.remove()"></g></svg>', !this.inertBodyElement.querySelector || this.inertBodyElement.querySelector("svg") ? (this.inertBodyElement.innerHTML = '<svg><p><style><img src="</style><img src=x onerror=alert(1)//">', this.getInertBodyElement = this.inertBodyElement.querySelector && this.inertBodyElement.querySelector("svg img") && function () { try { return !!window.DOMParser } catch (t) { return !1 } }() ? this.getInertBodyElement_DOMParser : this.getInertBodyElement_InertDocument) : this.getInertBodyElement = this.getInertBodyElement_XHR } getInertBodyElement_XHR(t) { t = "<body><remove></remove>" + t + "</body>"; try { t = encodeURI(t) } catch (r) { return null } const e = new XMLHttpRequest; e.responseType = "document", e.open("GET", "data:text/html;charset=utf-8," + t, !1), e.send(void 0); const n = e.response.body; return n.removeChild(n.firstChild), n } getInertBodyElement_DOMParser(t) { t = "<body><remove></remove>" + t + "</body>"; try { const e = (new window.DOMParser).parseFromString(t, "text/html").body; return e.removeChild(e.firstChild), e } catch (e) { return null } } getInertBodyElement_InertDocument(t) { const e = this.inertDocument.createElement("template"); return "content" in e ? (e.innerHTML = t, e) : (this.inertBodyElement.innerHTML = t, this.defaultDoc.documentMode && this.stripCustomNsAttrs(this.inertBodyElement), this.inertBodyElement) } stripCustomNsAttrs(t) { const e = t.attributes; for (let r = e.length - 1; 0 < r; r--) { const n = e.item(r).name; "xmlns:ns1" !== n && 0 !== n.indexOf("ns1:") || t.removeAttribute(n) } let n = t.firstChild; for (; n;)n.nodeType === Node.ELEMENT_NODE && this.stripCustomNsAttrs(n), n = n.nextSibling } } const Xt = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi, $t = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i; function Jt(t) { return (t = String(t)).match(Xt) || t.match($t) ? t : (Gt() && console.warn("WARNING: sanitizing unsafe URL value ".concat(t, " (see http://g.co/ng/security#xss)")), "unsafe:" + t) } function te(t) { const e = {}; for (const n of t.split(",")) e[n] = !0; return e } function ee(...t) { const e = {}; for (const n of t) for (const t in n) n.hasOwnProperty(t) && (e[t] = !0); return e } const ne = te("area,br,col,hr,img,wbr"), re = te("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"), se = te("rp,rt"), ie = ee(se, re), oe = ee(ne, ee(re, te("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")), ee(se, te("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")), ie), ae = te("background,cite,href,itemtype,longdesc,poster,src,xlink:href"), le = te("srcset"), ce = ee(ae, le, te("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"), te("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext")), he = te("script,style,template"); class ue { constructor() { this.sanitizedSomething = !1, this.buf = [] } sanitizeChildren(t) { let e = t.firstChild, n = !0; for (; e;)if (e.nodeType === Node.ELEMENT_NODE ? n = this.startElement(e) : e.nodeType === Node.TEXT_NODE ? this.chars(e.nodeValue) : this.sanitizedSomething = !0, n && e.firstChild) e = e.firstChild; else for (; e;) { e.nodeType === Node.ELEMENT_NODE && this.endElement(e); let t = this.checkClobberedElement(e, e.nextSibling); if (t) { e = t; break } e = this.checkClobberedElement(e, e.parentNode) } return this.buf.join("") } startElement(t) { const e = t.nodeName.toLowerCase(); if (!oe.hasOwnProperty(e)) return this.sanitizedSomething = !0, !he.hasOwnProperty(e); this.buf.push("<"), this.buf.push(e); const n = t.attributes; for (let s = 0; s < n.length; s++) { const t = n.item(s), e = t.name, i = e.toLowerCase(); if (!ce.hasOwnProperty(i)) { this.sanitizedSomething = !0; continue } let o = t.value; ae[i] && (o = Jt(o)), le[i] && (r = o, o = (r = String(r)).split(",").map(t => Jt(t.trim())).join(", ")), this.buf.push(" ", e, '="', fe(o), '"') } var r; return this.buf.push(">"), !0 } endElement(t) { const e = t.nodeName.toLowerCase(); oe.hasOwnProperty(e) && !ne.hasOwnProperty(e) && (this.buf.push("</"), this.buf.push(e), this.buf.push(">")) } chars(t) { this.buf.push(fe(t)) } checkClobberedElement(t, e) { if (e && (t.compareDocumentPosition(e) & Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY) throw new Error("Failed to sanitize html because the element is clobbered: ".concat(t.outerHTML)); return e } } const de = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, pe = /([^\#-~ |!])/g; function fe(t) { return t.replace(/&/g, "&amp;").replace(de, (function (t) { return "&#" + (1024 * (t.charCodeAt(0) - 55296) + (t.charCodeAt(1) - 56320) + 65536) + ";" })).replace(pe, (function (t) { return "&#" + t.charCodeAt(0) + ";" })).replace(/</g, "&lt;").replace(/>/g, "&gt;") } let me; function ge(t) { return "content" in t && function (t) { return t.nodeType === Node.ELEMENT_NODE && "TEMPLATE" === t.nodeName }(t) ? t.content : null } const ye = function () { var t = { NONE: 0, HTML: 1, STYLE: 2, SCRIPT: 3, URL: 4, RESOURCE_URL: 5 }; return t[t.NONE] = "NONE", t[t.HTML] = "HTML", t[t.STYLE] = "STYLE", t[t.SCRIPT] = "SCRIPT", t[t.URL] = "URL", t[t.RESOURCE_URL] = "RESOURCE_URL", t }(); class _e { } const ve = new RegExp("^([-,.\"'%_!# a-zA-Z0-9]+|(?:(?:matrix|translate|scale|rotate|skew|perspective)(?:X|Y|Z|3d)?|(?:rgb|hsl)a?|(?:repeating-)?(?:linear|radial)-gradient|(?:calc|attr))\\([-0-9.%, #a-zA-Z]+\\))$", "g"), be = /^url\(([^)]+)\)$/, we = /([A-Z])/g; function Se(t) { try { return null != t ? t.toString().slice(0, 30) : t } catch (e) { return "[ERROR] Exception while trying to serialize the value" } } let Ee = (() => { class t { } return t.__NG_ELEMENT_ID__ = () => Ce(), t })(); const Ce = (...t) => { }, xe = new Tt("The presence of this token marks an injector as being the root injector."), Te = function (t, e, n) { return new Oe(t, e, n) }; let ke = (() => { class t { static create(t, e) { return Array.isArray(t) ? Te(t, e, "") : Te(t.providers, t.parent, t.name || "") } } return t.THROW_IF_NOT_FOUND = At, t.NULL = new Ft, t.ngInjectableDef = ft({ token: t, providedIn: "any", factory: () => Nt(kt) }), t.__NG_ELEMENT_ID__ = -1, t })(); const Ae = function (t) { return t }, Re = [], Pe = Ae, Ie = function () { return Array.prototype.slice.call(arguments) }; class Oe { constructor(t, e = ke.NULL, n = null) { this.parent = e, this.source = n; const r = this._records = new Map; r.set(ke, { token: ke, fn: Ae, deps: Re, value: this, useNew: !1 }), r.set(kt, { token: kt, fn: Ae, deps: Re, value: this, useNew: !1 }), function t(e, n) { if (n) if ((n = bt(n)) instanceof Array) for (let r = 0; r < n.length; r++)t(e, n[r]); else { if ("function" == typeof n) throw De("Function/Class not supported", n); if (!n || "object" != typeof n || !n.provide) throw De("Unexpected provider", n); { let t = bt(n.provide); const r = function (t) { const e = function (t) { let e = Re; const n = t.deps; if (n && n.length) { e = []; for (let t = 0; t < n.length; t++) { let r = 6, s = bt(n[t]); if (s instanceof Array) for (let t = 0, e = s; t < e.length; t++) { const n = e[t]; n instanceof ct || n == ct ? r |= 1 : n instanceof ut || n == ut ? r &= -3 : n instanceof ht || n == ht ? r &= -5 : s = n instanceof lt ? n.token : bt(n) } e.push({ token: s, options: r }) } } else if (t.useExisting) e = [{ token: bt(t.useExisting), options: 6 }]; else if (!(n || Pt in t)) throw De("'deps' required", t); return e }(t); let n = Ae, r = Re, s = !1, i = bt(t.provide); if (Pt in t) r = t.useValue; else if (t.useFactory) n = t.useFactory; else if (t.useExisting); else if (t.useClass) s = !0, n = bt(t.useClass); else { if ("function" != typeof i) throw De("StaticProvider does not have [useValue|useFactory|useExisting|useClass] or [provide] is not newable", t); s = !0, n = i } return { deps: e, fn: n, useNew: s, value: r } }(n); if (!0 === n.multi) { let r = e.get(t); if (r) { if (r.fn !== Ie) throw Ne(t) } else e.set(t, r = { token: n.provide, deps: [], useNew: !1, fn: Ie, value: Re }); t = n, r.deps.push({ token: t, options: 6 }) } const s = e.get(t); if (s && s.fn == Ie) throw Ne(t); e.set(t, r) } } }(r, t) } get(t, e, n = dt.Default) { const r = this._records.get(t); try { return function t(e, n, r, s, i, o) { try { return function (e, n, r, s, i, o) { let a; if (!n || o & dt.SkipSelf) o & dt.Self || (a = s.get(e, i, dt.Default)); else { if (a = n.value, a == Pe) throw Error("\u0275Circular dependency"); if (a === Re) { n.value = Pe; let e = void 0, i = n.useNew, o = n.fn, l = n.deps, c = Re; if (l.length) { c = []; for (let e = 0; e < l.length; e++) { const n = l[e], i = n.options, o = 2 & i ? r.get(n.token) : void 0; c.push(t(n.token, o, r, o || 4 & i ? s : ke.NULL, 1 & i ? null : ke.THROW_IF_NOT_FOUND, dt.Default)) } } n.value = a = i ? new o(...c) : o.apply(e, c) } } return a }(e, n, r, s, i, o) } catch (a) { throw a instanceof Error || (a = new Error(a)), (a.ngTempTokenPath = a.ngTempTokenPath || []).unshift(e), n && n.value == Pe && (n.value = Re), a } }(t, r, this._records, this.parent, e, n) } catch (s) { return function (t, e, n, r) { const s = t.ngTempTokenPath; throw e.__source && s.unshift(e.__source), t.message = Mt("\n" + t.message, s, "StaticInjectorError", r), t.ngTokenPath = s, t.ngTempTokenPath = null, t }(s, t, 0, this.source) } } toString() { const t = []; return this._records.forEach((e, n) => t.push(yt(n))), "StaticInjector[".concat(t.join(", "), "]") } } function Ne(t) { return De("Cannot mix multi providers and regular providers", t) } function De(t, e) { return new Error(Mt(t, e, "StaticInjectorError")) } const Fe = new Tt("AnalyzeForEntryComponents"); let Me = null; function Le() { if (!Me) { const t = xt.Symbol; if (t && t.iterator) Me = t.iterator; else { const t = Object.getOwnPropertyNames(Map.prototype); for (let e = 0; e < t.length; ++e) { const n = t[e]; "entries" !== n && "size" !== n && Map.prototype[n] === Map.prototype.entries && (Me = n) } } } return Me } function je(t, e) { return t === e || "number" == typeof t && "number" == typeof e && isNaN(t) && isNaN(e) } function Ue(t, e) { const n = He(t), r = He(e); if (n && r) return function (t, e, n) { const r = t[Le()](), s = e[Le()](); for (; ;) { const t = r.next(), e = s.next(); if (t.done && e.done) return !0; if (t.done || e.done) return !1; if (!n(t.value, e.value)) return !1 } }(t, e, Ue); { const s = t && ("object" == typeof t || "function" == typeof t), i = e && ("object" == typeof e || "function" == typeof e); return !(n || !s || r || !i) || je(t, e) } } class Be { constructor(t) { this.wrapped = t } static wrap(t) { return new Be(t) } static unwrap(t) { return Be.isWrapped(t) ? t.wrapped : t } static isWrapped(t) { return t instanceof Be } } function He(t) { return !!Ve(t) && (Array.isArray(t) || !(t instanceof Map) && Le() in t) } function Ve(t) { return null !== t && ("function" == typeof t || "object" == typeof t) } function ze(t) { return !!t && "function" == typeof t.then } function qe(t) { return !!t && "function" == typeof t.subscribe } class We { constructor(t, e, n) { this.previousValue = t, this.currentValue = e, this.firstChange = n } isFirstChange() { return this.firstChange } } class Qe { } function Ke(t) { const e = Error("No component factory found for ".concat(yt(t), ". Did you add it to @NgModule.entryComponents?")); return e[Ze] = t, e } const Ze = "ngComponent"; class Ge { resolveComponentFactory(t) { throw Ke(t) } } let Ye = (() => { class t { } return t.NULL = new Ge, t })(); class Xe { constructor(t, e, n) { this._parent = e, this._ngModule = n, this._factories = new Map; for (let r = 0; r < t.length; r++) { const e = t[r]; this._factories.set(e.componentType, e) } } resolveComponentFactory(t) { let e = this._factories.get(t); if (!e && this._parent && (e = this._parent.resolveComponentFactory(t)), !e) throw Ke(t); return new $e(e, this._ngModule) } } class $e extends Qe { constructor(t, e) { super(), this.factory = t, this.ngModule = e, this.selector = t.selector, this.componentType = t.componentType, this.ngContentSelectors = t.ngContentSelectors, this.inputs = t.inputs, this.outputs = t.outputs } create(t, e, n, r) { return this.factory.create(t, e, n, r || this.ngModule) } } function Je(...t) { } let tn = (() => { class t { constructor(t) { this.nativeElement = t } } return t.__NG_ELEMENT_ID__ = () => en(t), t })(); const en = Je; class nn { } const rn = function () { var t = { Important: 1, DashCase: 2 }; return t[t.Important] = "Important", t[t.DashCase] = "DashCase", t }(); let sn = (() => { class t { } return t.__NG_ELEMENT_ID__ = () => on(), t })(); const on = Je; class an { constructor(t) { this.full = t, this.major = t.split(".")[0], this.minor = t.split(".")[1], this.patch = t.split(".").slice(2).join(".") } } const ln = new an("8.2.14"); class cn { constructor() { } supports(t) { return He(t) } create(t) { return new un(t) } } const hn = (t, e) => e; class un { constructor(t) { this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = t || hn } forEachItem(t) { let e; for (e = this._itHead; null !== e; e = e._next)t(e) } forEachOperation(t) { let e = this._itHead, n = this._removalsHead, r = 0, s = null; for (; e || n;) { const i = !n || e && e.currentIndex < mn(n, r, s) ? e : n, o = mn(i, r, s), a = i.currentIndex; if (i === n) r--, n = n._nextRemoved; else if (e = e._next, null == i.previousIndex) r++; else { s || (s = []); const t = o - r, e = a - r; if (t != e) { for (let n = 0; n < t; n++) { const r = n < s.length ? s[n] : s[n] = 0, i = r + n; e <= i && i < t && (s[n] = r + 1) } s[i.previousIndex] = e - t } } o !== a && t(i, o, a) } } forEachPreviousItem(t) { let e; for (e = this._previousItHead; null !== e; e = e._nextPrevious)t(e) } forEachAddedItem(t) { let e; for (e = this._additionsHead; null !== e; e = e._nextAdded)t(e) } forEachMovedItem(t) { let e; for (e = this._movesHead; null !== e; e = e._nextMoved)t(e) } forEachRemovedItem(t) { let e; for (e = this._removalsHead; null !== e; e = e._nextRemoved)t(e) } forEachIdentityChange(t) { let e; for (e = this._identityChangesHead; null !== e; e = e._nextIdentityChange)t(e) } diff(t) { if (null == t && (t = []), !He(t)) throw new Error("Error trying to diff '".concat(yt(t), "'. Only arrays and iterables are allowed")); return this.check(t) ? this : null } onDestroy() { } check(t) { this._reset(); let e, n, r, s = this._itHead, i = !1; if (Array.isArray(t)) { this.length = t.length; for (let e = 0; e < this.length; e++)n = t[e], r = this._trackByFn(e, n), null !== s && je(s.trackById, r) ? (i && (s = this._verifyReinsertion(s, n, r, e)), je(s.item, n) || this._addIdentityChange(s, n)) : (s = this._mismatch(s, n, r, e), i = !0), s = s._next } else e = 0, function (t, e) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++)e(t[n]); else { const n = t[Le()](); let r; for (; !(r = n.next()).done;)e(r.value) } }(t, t => { r = this._trackByFn(e, t), null !== s && je(s.trackById, r) ? (i && (s = this._verifyReinsertion(s, t, r, e)), je(s.item, t) || this._addIdentityChange(s, t)) : (s = this._mismatch(s, t, r, e), i = !0), s = s._next, e++ }), this.length = e; return this._truncate(s), this.collection = t, this.isDirty } get isDirty() { return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead } _reset() { if (this.isDirty) { let t, e; for (t = this._previousItHead = this._itHead; null !== t; t = t._next)t._nextPrevious = t._next; for (t = this._additionsHead; null !== t; t = t._nextAdded)t.previousIndex = t.currentIndex; for (this._additionsHead = this._additionsTail = null, t = this._movesHead; null !== t; t = e)t.previousIndex = t.currentIndex, e = t._nextMoved; this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null } } _mismatch(t, e, n, r) { let s; return null === t ? s = this._itTail : (s = t._prev, this._remove(t)), null !== (t = null === this._linkedRecords ? null : this._linkedRecords.get(n, r)) ? (je(t.item, e) || this._addIdentityChange(t, e), this._moveAfter(t, s, r)) : null !== (t = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(n, null)) ? (je(t.item, e) || this._addIdentityChange(t, e), this._reinsertAfter(t, s, r)) : t = this._addAfter(new dn(e, n), s, r), t } _verifyReinsertion(t, e, n, r) { let s = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(n, null); return null !== s ? t = this._reinsertAfter(s, t._prev, r) : t.currentIndex != r && (t.currentIndex = r, this._addToMoves(t, r)), t } _truncate(t) { for (; null !== t;) { const e = t._next; this._addToRemovals(this._unlink(t)), t = e } null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null) } _reinsertAfter(t, e, n) { null !== this._unlinkedRecords && this._unlinkedRecords.remove(t); const r = t._prevRemoved, s = t._nextRemoved; return null === r ? this._removalsHead = s : r._nextRemoved = s, null === s ? this._removalsTail = r : s._prevRemoved = r, this._insertAfter(t, e, n), this._addToMoves(t, n), t } _moveAfter(t, e, n) { return this._unlink(t), this._insertAfter(t, e, n), this._addToMoves(t, n), t } _addAfter(t, e, n) { return this._insertAfter(t, e, n), this._additionsTail = null === this._additionsTail ? this._additionsHead = t : this._additionsTail._nextAdded = t, t } _insertAfter(t, e, n) { const r = null === e ? this._itHead : e._next; return t._next = r, t._prev = e, null === r ? this._itTail = t : r._prev = t, null === e ? this._itHead = t : e._next = t, null === this._linkedRecords && (this._linkedRecords = new fn), this._linkedRecords.put(t), t.currentIndex = n, t } _remove(t) { return this._addToRemovals(this._unlink(t)) } _unlink(t) { null !== this._linkedRecords && this._linkedRecords.remove(t); const e = t._prev, n = t._next; return null === e ? this._itHead = n : e._next = n, null === n ? this._itTail = e : n._prev = e, t } _addToMoves(t, e) { return t.previousIndex === e ? t : (this._movesTail = null === this._movesTail ? this._movesHead = t : this._movesTail._nextMoved = t, t) } _addToRemovals(t) { return null === this._unlinkedRecords && (this._unlinkedRecords = new fn), this._unlinkedRecords.put(t), t.currentIndex = null, t._nextRemoved = null, null === this._removalsTail ? (this._removalsTail = this._removalsHead = t, t._prevRemoved = null) : (t._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = t), t } _addIdentityChange(t, e) { return t.item = e, this._identityChangesTail = null === this._identityChangesTail ? this._identityChangesHead = t : this._identityChangesTail._nextIdentityChange = t, t } } class dn { constructor(t, e) { this.item = t, this.trackById = e, this.currentIndex = null, this.previousIndex = null, this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, this._nextMoved = null, this._nextIdentityChange = null } } class pn { constructor() { this._head = null, this._tail = null } add(t) { null === this._head ? (this._head = this._tail = t, t._nextDup = null, t._prevDup = null) : (this._tail._nextDup = t, t._prevDup = this._tail, t._nextDup = null, this._tail = t) } get(t, e) { let n; for (n = this._head; null !== n; n = n._nextDup)if ((null === e || e <= n.currentIndex) && je(n.trackById, t)) return n; return null } remove(t) { const e = t._prevDup, n = t._nextDup; return null === e ? this._head = n : e._nextDup = n, null === n ? this._tail = e : n._prevDup = e, null === this._head } } class fn { constructor() { this.map = new Map } put(t) { const e = t.trackById; let n = this.map.get(e); n || (n = new pn, this.map.set(e, n)), n.add(t) } get(t, e) { const n = this.map.get(t); return n ? n.get(t, e) : null } remove(t) { const e = t.trackById; return this.map.get(e).remove(t) && this.map.delete(e), t } get isEmpty() { return 0 === this.map.size } clear() { this.map.clear() } } function mn(t, e, n) { const r = t.previousIndex; if (null === r) return r; let s = 0; return n && r < n.length && (s = n[r]), r + e + s } class gn { constructor() { } supports(t) { return t instanceof Map || Ve(t) } create() { return new yn } } class yn { constructor() { this._records = new Map, this._mapHead = null, this._appendAfter = null, this._previousMapHead = null, this._changesHead = null, this._changesTail = null, this._additionsHead = null, this._additionsTail = null, this._removalsHead = null, this._removalsTail = null } get isDirty() { return null !== this._additionsHead || null !== this._changesHead || null !== this._removalsHead } forEachItem(t) { let e; for (e = this._mapHead; null !== e; e = e._next)t(e) } forEachPreviousItem(t) { let e; for (e = this._previousMapHead; null !== e; e = e._nextPrevious)t(e) } forEachChangedItem(t) { let e; for (e = this._changesHead; null !== e; e = e._nextChanged)t(e) } forEachAddedItem(t) { let e; for (e = this._additionsHead; null !== e; e = e._nextAdded)t(e) } forEachRemovedItem(t) { let e; for (e = this._removalsHead; null !== e; e = e._nextRemoved)t(e) } diff(t) { if (t) { if (!(t instanceof Map || Ve(t))) throw new Error("Error trying to diff '".concat(yt(t), "'. Only maps and objects are allowed")) } else t = new Map; return this.check(t) ? this : null } onDestroy() { } check(t) { this._reset(); let e = this._mapHead; if (this._appendAfter = null, this._forEach(t, (t, n) => { if (e && e.key === n) this._maybeAddToChanges(e, t), this._appendAfter = e, e = e._next; else { const r = this._getOrCreateRecordForKey(n, t); e = this._insertBeforeOrAppend(e, r) } }), e) { e._prev && (e._prev._next = null), this._removalsHead = e; for (let t = e; null !== t; t = t._nextRemoved)t === this._mapHead && (this._mapHead = null), this._records.delete(t.key), t._nextRemoved = t._next, t.previousValue = t.currentValue, t.currentValue = null, t._prev = null, t._next = null } return this._changesTail && (this._changesTail._nextChanged = null), this._additionsTail && (this._additionsTail._nextAdded = null), this.isDirty } _insertBeforeOrAppend(t, e) { if (t) { const n = t._prev; return e._next = t, e._prev = n, t._prev = e, n && (n._next = e), t === this._mapHead && (this._mapHead = e), this._appendAfter = t, t } return this._appendAfter ? (this._appendAfter._next = e, e._prev = this._appendAfter) : this._mapHead = e, this._appendAfter = e, null } _getOrCreateRecordForKey(t, e) { if (this._records.has(t)) { const n = this._records.get(t); this._maybeAddToChanges(n, e); const r = n._prev, s = n._next; return r && (r._next = s), s && (s._prev = r), n._next = null, n._prev = null, n } const n = new _n(t); return this._records.set(t, n), n.currentValue = e, this._addToAdditions(n), n } _reset() { if (this.isDirty) { let t; for (this._previousMapHead = this._mapHead, t = this._previousMapHead; null !== t; t = t._next)t._nextPrevious = t._next; for (t = this._changesHead; null !== t; t = t._nextChanged)t.previousValue = t.currentValue; for (t = this._additionsHead; null != t; t = t._nextAdded)t.previousValue = t.currentValue; this._changesHead = this._changesTail = null, this._additionsHead = this._additionsTail = null, this._removalsHead = null } } _maybeAddToChanges(t, e) { je(e, t.currentValue) || (t.previousValue = t.currentValue, t.currentValue = e, this._addToChanges(t)) } _addToAdditions(t) { null === this._additionsHead ? this._additionsHead = this._additionsTail = t : (this._additionsTail._nextAdded = t, this._additionsTail = t) } _addToChanges(t) { null === this._changesHead ? this._changesHead = this._changesTail = t : (this._changesTail._nextChanged = t, this._changesTail = t) } _forEach(t, e) { t instanceof Map ? t.forEach(e) : Object.keys(t).forEach(n => e(t[n], n)) } } class _n { constructor(t) { this.key = t, this.previousValue = null, this.currentValue = null, this._nextPrevious = null, this._next = null, this._prev = null, this._nextAdded = null, this._nextRemoved = null, this._nextChanged = null } } let vn = (() => { class t { constructor(t) { this.factories = t } static create(e, n) { if (null != n) { const t = n.factories.slice(); e = e.concat(t) } return new t(e) } static extend(e) { return { provide: t, useFactory: n => { if (!n) throw new Error("Cannot extend IterableDiffers without a parent injector"); return t.create(e, n) }, deps: [[t, new ut, new ct]] } } find(t) { const e = this.factories.find(e => e.supports(t)); if (null != e) return e; throw new Error("Cannot find a differ supporting object '".concat(t, "' of type '").concat((n = t).name || typeof n, "'")); var n } } return t.ngInjectableDef = ft({ token: t, providedIn: "root", factory: () => new t([new cn]) }), t })(), bn = (() => { class t { constructor(t) { this.factories = t } static create(e, n) { if (n) { const t = n.factories.slice(); e = e.concat(t) } return new t(e) } static extend(e) { return { provide: t, useFactory: n => { if (!n) throw new Error("Cannot extend KeyValueDiffers without a parent injector"); return t.create(e, n) }, deps: [[t, new ut, new ct]] } } find(t) { const e = this.factories.find(e => e.supports(t)); if (e) return e; throw new Error("Cannot find a differ supporting object '".concat(t, "'")) } } return t.ngInjectableDef = ft({ token: t, providedIn: "root", factory: () => new t([new gn]) }), t })(); const wn = [new gn], Sn = new vn([new cn]), En = new bn(wn); let Cn = (() => { class t { } return t.__NG_ELEMENT_ID__ = () => xn(t, tn), t })(); const xn = Je; let Tn = (() => { class t { } return t.__NG_ELEMENT_ID__ = () => kn(t, tn), t })(); const kn = Je; function An(t, e, n, r) { let s = "ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value: '".concat(e, "'. Current value: '").concat(n, "'."); return r && (s += " It seems like the view has been created after its parent and its children have been dirty checked. Has it been created in a change detection hook ?"), function (t, e) { const n = new Error(t); return Rn(n, e), n }(s, t) } function Rn(t, e) { t.ngDebugContext = e, t.ngErrorLogger = e.logError.bind(e) } function Pn(t) { return new Error("ViewDestroyedError: Attempt to use a destroyed view: ".concat(t)) } function In(t, e, n) { const r = t.state, s = 1792 & r; return s === e ? (t.state = -1793 & r | n, t.initIndex = -1, !0) : s === n } function On(t, e, n) { return (1792 & t.state) === e && t.initIndex <= n && (t.initIndex = n + 1, !0) } function Nn(t, e) { return t.nodes[e] } function Dn(t, e) { return t.nodes[e] } function Fn(t, e) { return t.nodes[e] } function Mn(t, e) { return t.nodes[e] } function Ln(t, e) { return t.nodes[e] } const jn = { setCurrentNode: void 0, createRootView: void 0, createEmbeddedView: void 0, createComponentView: void 0, createNgModuleRef: void 0, overrideProvider: void 0, overrideComponentView: void 0, clearOverrides: void 0, checkAndUpdateView: void 0, checkNoChangesView: void 0, destroyView: void 0, resolveDep: void 0, createDebugContext: void 0, handleEvent: void 0, updateDirectives: void 0, updateRenderer: void 0, dirtyParentQueries: void 0 }, Un = () => { }, Bn = new Map; function Hn(t) { let e = Bn.get(t); return e || (e = yt(t) + "_" + Bn.size, Bn.set(t, e)), e } function Vn(t) { return { id: "$$undefined", styles: t.styles, encapsulation: t.encapsulation, data: t.data } } let zn = 0; function qn(t, e, n, r) { return !(!(2 & t.state) && je(t.oldValues[e.bindingIndex + n], r)) } function Wn(t, e, n, r) { return !!qn(t, e, n, r) && (t.oldValues[e.bindingIndex + n] = r, !0) } function Qn(t, e, n, r) { const s = t.oldValues[e.bindingIndex + n]; if (1 & t.state || !Ue(s, r)) { const i = e.bindings[n].name; throw An(jn.createDebugContext(t, e.nodeIndex), "".concat(i, ": ").concat(s), "".concat(i, ": ").concat(r), 0 != (1 & t.state)) } } function Kn(t) { let e = t; for (; e;)2 & e.def.flags && (e.state |= 8), e = e.viewContainerParent || e.parent } function Zn(t, e) { let n = t; for (; n && n !== e;)n.state |= 64, n = n.viewContainerParent || n.parent } function Gn(t, e, n, r) { try { return Kn(33554432 & t.def.nodes[e].flags ? Dn(t, e).componentView : t), jn.handleEvent(t, e, n, r) } catch (s) { t.root.errorHandler.handleError(s) } } function Yn(t) { return t.parent ? Dn(t.parent, t.parentNodeDef.nodeIndex) : null } function Xn(t) { return t.parent ? t.parentNodeDef.parent : null } function $n(t, e) { switch (201347067 & e.flags) { case 1: return Dn(t, e.nodeIndex).renderElement; case 2: return Nn(t, e.nodeIndex).renderText } } function Jn(t) { return !!t.parent && !!(32768 & t.parentNodeDef.flags) } function tr(t) { return !(!t.parent || 32768 & t.parentNodeDef.flags) } function er(t) { return 1 << t % 32 } function nr(t) { const e = {}; let n = 0; const r = {}; return t && t.forEach(([t, s]) => { "number" == typeof t ? (e[t] = s, n |= er(t)) : r[t] = s }), { matchedQueries: e, references: r, matchedQueryIds: n } } function rr(t, e) { return t.map(t => { let n, r; return Array.isArray(t) ? [r, n] = t : (r = 0, n = t), n && ("function" == typeof n || "object" == typeof n) && e && Object.defineProperty(n, "__source", { value: e, configurable: !0 }), { flags: r, token: n, tokenKey: Hn(n) } }) } function sr(t, e, n) { let r = n.renderParent; return r ? 0 == (1 & r.flags) || 0 == (33554432 & r.flags) || r.element.componentRendererType && r.element.componentRendererType.encapsulation === Ht.Native ? Dn(t, n.renderParent.nodeIndex).renderElement : void 0 : e } const ir = new WeakMap; function or(t) { let e = ir.get(t); return e || (e = t(() => Un), e.factory = t, ir.set(t, e)), e } function ar(t, e, n, r, s) { 3 === e && (n = t.renderer.parentNode($n(t, t.def.lastRenderRootNode))), lr(t, e, 0, t.def.nodes.length - 1, n, r, s) } function lr(t, e, n, r, s, i, o) { for (let a = n; a <= r; a++) { const n = t.def.nodes[a]; 11 & n.flags && hr(t, n, e, s, i, o), a += n.childCount } } function cr(t, e, n, r, s, i) { let o = t; for (; o && !Jn(o);)o = o.parent; const a = o.parent, l = Xn(o), c = l.nodeIndex + l.childCount; for (let h = l.nodeIndex + 1; h <= c; h++) { const t = a.def.nodes[h]; t.ngContentIndex === e && hr(a, t, n, r, s, i), h += t.childCount } if (!a.parent) { const o = t.root.projectableNodes[e]; if (o) for (let e = 0; e < o.length; e++)ur(t, o[e], n, r, s, i) } } function hr(t, e, n, r, s, i) { if (8 & e.flags) cr(t, e.ngContent.index, n, r, s, i); else { const o = $n(t, e); if (3 === n && 33554432 & e.flags && 48 & e.bindingFlags ? (16 & e.bindingFlags && ur(t, o, n, r, s, i), 32 & e.bindingFlags && ur(Dn(t, e.nodeIndex).componentView, o, n, r, s, i)) : ur(t, o, n, r, s, i), 16777216 & e.flags) { const o = Dn(t, e.nodeIndex).viewContainer._embeddedViews; for (let t = 0; t < o.length; t++)ar(o[t], n, r, s, i) } 1 & e.flags && !e.element.name && lr(t, n, e.nodeIndex + 1, e.nodeIndex + e.childCount, r, s, i) } } function ur(t, e, n, r, s, i) { const o = t.renderer; switch (n) { case 1: o.appendChild(r, e); break; case 2: o.insertBefore(r, e, s); break; case 3: o.removeChild(r, e); break; case 0: i.push(e) } } const dr = /^:([^:]+):(.+)$/; function pr(t) { if (":" === t[0]) { const e = t.match(dr); return [e[1], e[2]] } return ["", t] } function fr(t) { let e = 0; for (let n = 0; n < t.length; n++)e |= t[n].flags; return e } function mr(t, e, n, r, s, i, o, a, l, c, h, u, d, p, f, m, g, y, _, v) { switch (t) { case 1: return e + gr(n) + r; case 2: return e + gr(n) + r + gr(s) + i; case 3: return e + gr(n) + r + gr(s) + i + gr(o) + a; case 4: return e + gr(n) + r + gr(s) + i + gr(o) + a + gr(l) + c; case 5: return e + gr(n) + r + gr(s) + i + gr(o) + a + gr(l) + c + gr(h) + u; case 6: return e + gr(n) + r + gr(s) + i + gr(o) + a + gr(l) + c + gr(h) + u + gr(d) + p; case 7: return e + gr(n) + r + gr(s) + i + gr(o) + a + gr(l) + c + gr(h) + u + gr(d) + p + gr(f) + m; case 8: return e + gr(n) + r + gr(s) + i + gr(o) + a + gr(l) + c + gr(h) + u + gr(d) + p + gr(f) + m + gr(g) + y; case 9: return e + gr(n) + r + gr(s) + i + gr(o) + a + gr(l) + c + gr(h) + u + gr(d) + p + gr(f) + m + gr(g) + y + gr(_) + v; default: throw new Error("Does not support more than 9 expressions") } } function gr(t) { return null != t ? t.toString() : "" } const yr = new Object, _r = Hn(ke), vr = Hn(kt), br = Hn(Lt); function wr(t, e, n, r) { return n = bt(n), { index: -1, deps: rr(r, yt(e)), flags: t, token: e, value: n } } function Sr(t, e, n = ke.THROW_IF_NOT_FOUND) { const r = Ot(t); try { if (8 & e.flags) return e.token; if (2 & e.flags && (n = null), 1 & e.flags) return t._parent.get(e.token, n); const o = e.tokenKey; switch (o) { case _r: case vr: case br: return t }const a = t._def.providersByKey[o]; let l; if (a) { let e = t._providers[a.index]; return void 0 === e && (e = t._providers[a.index] = Er(t, a)), e === yr ? void 0 : e } if ((l = mt(e.token)) && (s = t, null != (i = l).providedIn && (function (t, e) { return t._def.modules.indexOf(e) > -1 }(s, i.providedIn) || "root" === i.providedIn && s._def.isRoot))) { const n = t._providers.length; return t._def.providers[n] = t._def.providersByKey[e.tokenKey] = { flags: 5120, value: l.factory, deps: [], index: n, token: e.token }, t._providers[n] = yr, t._providers[n] = Er(t, t._def.providersByKey[e.tokenKey]) } return 4 & e.flags ? n : t._parent.get(e.token, n) } finally { Ot(r) } var s, i } function Er(t, e) { let n; switch (201347067 & e.flags) { case 512: n = function (t, e, n) { const r = n.length; switch (r) { case 0: return new e; case 1: return new e(Sr(t, n[0])); case 2: return new e(Sr(t, n[0]), Sr(t, n[1])); case 3: return new e(Sr(t, n[0]), Sr(t, n[1]), Sr(t, n[2])); default: const s = new Array(r); for (let e = 0; e < r; e++)s[e] = Sr(t, n[e]); return new e(...s) } }(t, e.value, e.deps); break; case 1024: n = function (t, e, n) { const r = n.length; switch (r) { case 0: return e(); case 1: return e(Sr(t, n[0])); case 2: return e(Sr(t, n[0]), Sr(t, n[1])); case 3: return e(Sr(t, n[0]), Sr(t, n[1]), Sr(t, n[2])); default: const s = Array(r); for (let e = 0; e < r; e++)s[e] = Sr(t, n[e]); return e(...s) } }(t, e.value, e.deps); break; case 2048: n = Sr(t, e.deps[0]); break; case 256: n = e.value }return n === yr || null === n || "object" != typeof n || 131072 & e.flags || "function" != typeof n.ngOnDestroy || (e.flags |= 131072), void 0 === n ? yr : n } function Cr(t, e) { const n = t.viewContainer._embeddedViews; if ((null == e || e >= n.length) && (e = n.length - 1), e < 0) return null; const r = n[e]; return r.viewContainerParent = null, Bt(n, e), jn.dirtyParentQueries(r), Tr(r), r } function xr(t, e, n) { const r = e ? $n(e, e.def.lastRenderRootNode) : t.renderElement, s = n.renderer.parentNode(r), i = n.renderer.nextSibling(r); ar(n, 2, s, i, void 0) } function Tr(t) { ar(t, 3, null, null, void 0) } const kr = new Object; function Ar(t, e, n, r, s, i) { return new Rr(t, e, n, r, s, i) } class Rr extends Qe { constructor(t, e, n, r, s, i) { super(), this.selector = t, this.componentType = e, this._inputs = r, this._outputs = s, this.ngContentSelectors = i, this.viewDefFactory = n } get inputs() { const t = [], e = this._inputs; for (let n in e) t.push({ propName: n, templateName: e[n] }); return t } get outputs() { const t = []; for (let e in this._outputs) t.push({ propName: e, templateName: this._outputs[e] }); return t } create(t, e, n, r) { if (!r) throw new Error("ngModule should be provided"); const s = or(this.viewDefFactory), i = s.nodes[0].element.componentProvider.nodeIndex, o = jn.createRootView(t, e || [], n, s, r, kr), a = Fn(o, i).instance; return n && o.renderer.setAttribute(Dn(o, 0).renderElement, "ng-version", ln.full), new Pr(o, new Dr(o), a) } } class Pr extends class { }{ constructor(t, e, n) { super(), this._view = t, this._viewRef = e, this._component = n, this._elDef = this._view.def.nodes[0], this.hostView = e, this.changeDetectorRef = e, this.instance = n } get location() { return new tn(Dn(this._view, this._elDef.nodeIndex).renderElement) } get injector() { return new jr(this._view, this._elDef) } get componentType() { return this._component.constructor } destroy() { this._viewRef.destroy() } onDestroy(t) { this._viewRef.onDestroy(t) } } function Ir(t, e, n) { return new Or(t, e, n) } class Or { constructor(t, e, n) { this._view = t, this._elDef = e, this._data = n, this._embeddedViews = [] } get element() { return new tn(this._data.renderElement) } get injector() { return new jr(this._view, this._elDef) } get parentInjector() { let t = this._view, e = this._elDef.parent; for (; !e && t;)e = Xn(t), t = t.parent; return t ? new jr(t, e) : new jr(this._view, null) } clear() { for (let t = this._embeddedViews.length - 1; t >= 0; t--) { const e = Cr(this._data, t); jn.destroyView(e) } } get(t) { const e = this._embeddedViews[t]; if (e) { const t = new Dr(e); return t.attachToViewContainerRef(this), t } return null } get length() { return this._embeddedViews.length } createEmbeddedView(t, e, n) { const r = t.createEmbeddedView(e || {}); return this.insert(r, n), r } createComponent(t, e, n, r, s) { const i = n || this.parentInjector; s || t instanceof $e || (s = i.get(Lt)); const o = t.create(i, r, void 0, s); return this.insert(o.hostView, e), o } insert(t, e) { if (t.destroyed) throw new Error("Cannot insert a destroyed View in a ViewContainer!"); const n = t; return function (t, e, n, r) { let s = e.viewContainer._embeddedViews; null == n && (n = s.length), r.viewContainerParent = t, Ut(s, n, r), function (t, e) { const n = Yn(e); if (!n || n === t || 16 & e.state) return; e.state |= 16; let r = n.template._projectedViews; r || (r = n.template._projectedViews = []), r.push(e), function (t, e) { if (4 & e.flags) return; t.nodeFlags |= 4, e.flags |= 4; let n = e.parent; for (; n;)n.childFlags |= 4, n = n.parent }(e.parent.def, e.parentNodeDef) }(e, r), jn.dirtyParentQueries(r), xr(e, n > 0 ? s[n - 1] : null, r) }(this._view, this._data, e, n._view), n.attachToViewContainerRef(this), t } move(t, e) { if (t.destroyed) throw new Error("Cannot move a destroyed View in a ViewContainer!"); const n = this._embeddedViews.indexOf(t._view); return function (t, e, n) { const r = t.viewContainer._embeddedViews, s = r[e]; Bt(r, e), null == n && (n = r.length), Ut(r, n, s), jn.dirtyParentQueries(s), Tr(s), xr(t, n > 0 ? r[n - 1] : null, s) }(this._data, n, e), t } indexOf(t) { return this._embeddedViews.indexOf(t._view) } remove(t) { const e = Cr(this._data, t); e && jn.destroyView(e) } detach(t) { const e = Cr(this._data, t); return e ? new Dr(e) : null } } function Nr(t) { return new Dr(t) } class Dr { constructor(t) { this._view = t, this._viewContainerRef = null, this._appRef = null } get rootNodes() { return function (t) { const e = []; return ar(t, 0, void 0, void 0, e), e }(this._view) } get context() { return this._view.context } get destroyed() { return 0 != (128 & this._view.state) } markForCheck() { Kn(this._view) } detach() { this._view.state &= -5 } detectChanges() { const t = this._view.root.rendererFactory; t.begin && t.begin(); try { jn.checkAndUpdateView(this._view) } finally { t.end && t.end() } } checkNoChanges() { jn.checkNoChangesView(this._view) } reattach() { this._view.state |= 4 } onDestroy(t) { this._view.disposables || (this._view.disposables = []), this._view.disposables.push(t) } destroy() { this._appRef ? this._appRef.detachView(this) : this._viewContainerRef && this._viewContainerRef.detach(this._viewContainerRef.indexOf(this)), jn.destroyView(this._view) } detachFromAppRef() { this._appRef = null, Tr(this._view), jn.dirtyParentQueries(this._view) } attachToAppRef(t) { if (this._viewContainerRef) throw new Error("This view is already attached to a ViewContainer!"); this._appRef = t } attachToViewContainerRef(t) { if (this._appRef) throw new Error("This view is already attached directly to the ApplicationRef!"); this._viewContainerRef = t } } function Fr(t, e) { return new Mr(t, e) } class Mr extends Cn { constructor(t, e) { super(), this._parentView = t, this._def = e } createEmbeddedView(t) { return new Dr(jn.createEmbeddedView(this._parentView, this._def, this._def.element.template, t)) } get elementRef() { return new tn(Dn(this._parentView, this._def.nodeIndex).renderElement) } } function Lr(t, e) { return new jr(t, e) } class jr { constructor(t, e) { this.view = t, this.elDef = e } get(t, e = ke.THROW_IF_NOT_FOUND) { return jn.resolveDep(this.view, this.elDef, !!this.elDef && 0 != (33554432 & this.elDef.flags), { flags: 0, token: t, tokenKey: Hn(t) }, e) } } function Ur(t, e) { const n = t.def.nodes[e]; if (1 & n.flags) { const e = Dn(t, n.nodeIndex); return n.element.template ? e.template : e.renderElement } if (2 & n.flags) return Nn(t, n.nodeIndex).renderText; if (20240 & n.flags) return Fn(t, n.nodeIndex).instance; throw new Error("Illegal state: read nodeValue for node index ".concat(e)) } function Br(t) { return new Hr(t.renderer) } class Hr { constructor(t) { this.delegate = t } selectRootElement(t) { return this.delegate.selectRootElement(t) } createElement(t, e) { const [n, r] = pr(e), s = this.delegate.createElement(r, n); return t && this.delegate.appendChild(t, s), s } createViewRoot(t) { return t } createTemplateAnchor(t) { const e = this.delegate.createComment(""); return t && this.delegate.appendChild(t, e), e } createText(t, e) { const n = this.delegate.createText(e); return t && this.delegate.appendChild(t, n), n } projectNodes(t, e) { for (let n = 0; n < e.length; n++)this.delegate.appendChild(t, e[n]) } attachViewAfter(t, e) { const n = this.delegate.parentNode(t), r = this.delegate.nextSibling(t); for (let s = 0; s < e.length; s++)this.delegate.insertBefore(n, e[s], r) } detachView(t) { for (let e = 0; e < t.length; e++) { const n = t[e], r = this.delegate.parentNode(n); this.delegate.removeChild(r, n) } } destroyView(t, e) { for (let n = 0; n < e.length; n++)this.delegate.destroyNode(e[n]) } listen(t, e, n) { return this.delegate.listen(t, e, n) } listenGlobal(t, e, n) { return this.delegate.listen(t, e, n) } setElementProperty(t, e, n) { this.delegate.setProperty(t, e, n) } setElementAttribute(t, e, n) { const [r, s] = pr(e); null != n ? this.delegate.setAttribute(t, s, n, r) : this.delegate.removeAttribute(t, s, r) } setBindingDebugInfo(t, e, n) { } setElementClass(t, e, n) { n ? this.delegate.addClass(t, e) : this.delegate.removeClass(t, e) } setElementStyle(t, e, n) { null != n ? this.delegate.setStyle(t, e, n) : this.delegate.removeStyle(t, e) } invokeElementMethod(t, e, n) { t[e].apply(t, n) } setText(t, e) { this.delegate.setValue(t, e) } animate() { throw new Error("Renderer.animate is no longer supported!") } } function Vr(t, e, n, r) { return new zr(t, e, n, r) } class zr { constructor(t, e, n, r) { this._moduleType = t, this._parent = e, this._bootstrapComponents = n, this._def = r, this._destroyListeners = [], this._destroyed = !1, this.injector = this, function (t) { const e = t._def, n = t._providers = new Array(e.providers.length); for (let r = 0; r < e.providers.length; r++) { const s = e.providers[r]; 4096 & s.flags || void 0 === n[r] && (n[r] = Er(t, s)) } }(this) } get(t, e = ke.THROW_IF_NOT_FOUND, n = dt.Default) { let r = 0; return n & dt.SkipSelf ? r |= 1 : n & dt.Self && (r |= 4), Sr(this, { token: t, tokenKey: Hn(t), flags: r }, e) } get instance() { return this.get(this._moduleType) } get componentFactoryResolver() { return this.get(Ye) } destroy() { if (this._destroyed) throw new Error("The ng module ".concat(yt(this.instance.constructor), " has already been destroyed.")); this._destroyed = !0, function (t, e) { const n = t._def, r = new Set; for (let s = 0; s < n.providers.length; s++)if (131072 & n.providers[s].flags) { const e = t._providers[s]; if (e && e !== yr) { const t = e.ngOnDestroy; "function" != typeof t || r.has(e) || (t.apply(e), r.add(e)) } } }(this), this._destroyListeners.forEach(t => t()) } onDestroy(t) { this._destroyListeners.push(t) } } const qr = Hn(class { }), Wr = Hn(sn), Qr = Hn(tn), Kr = Hn(Tn), Zr = Hn(Cn), Gr = Hn(Ee), Yr = Hn(ke), Xr = Hn(kt); function $r(t, e, n, r, s, i, o, a) { const l = []; if (o) for (let h in o) { const [t, e] = o[h]; l[t] = { flags: 8, name: h, nonMinifiedName: e, ns: null, securityContext: null, suffix: null } } const c = []; if (a) for (let h in a) c.push({ type: 1, propName: h, target: null, eventName: a[h] }); return function (t, e, n, r, s, i, o, a, l) { const { matchedQueries: c, references: h, matchedQueryIds: u } = nr(n); l || (l = []), a || (a = []), i = bt(i); const d = rr(o, yt(s)); return { nodeIndex: -1, parent: null, renderParent: null, bindingIndex: -1, outputIndex: -1, checkIndex: t, flags: e, childFlags: 0, directChildFlags: 0, childMatchedQueries: 0, matchedQueries: c, matchedQueryIds: u, references: h, ngContentIndex: -1, childCount: r, bindings: a, bindingFlags: fr(a), outputs: l, element: null, provider: { token: s, value: i, deps: d }, text: null, query: null, ngContent: null } }(t, e |= 16384, n, r, s, s, i, l, c) } function Jr(t, e) { return rs(t, e) } function ts(t, e) { let n = t; for (; n.parent && !Jn(n);)n = n.parent; return ss(n.parent, Xn(n), !0, e.provider.value, e.provider.deps) } function es(t, e) { const n = ss(t, e.parent, (32768 & e.flags) > 0, e.provider.value, e.provider.deps); if (e.outputs.length) for (let r = 0; r < e.outputs.length; r++) { const s = e.outputs[r], i = n[s.propName]; if (!qe(i)) throw new Error("@Output ".concat(s.propName, " not initialized in '").concat(n.constructor.name, "'.")); { const n = i.subscribe(ns(t, e.parent.nodeIndex, s.eventName)); t.disposables[e.outputIndex + r] = n.unsubscribe.bind(n) } } return n } function ns(t, e, n) { return r => Gn(t, e, n, r) } function rs(t, e) { const n = (8192 & e.flags) > 0, r = e.provider; switch (201347067 & e.flags) { case 512: return ss(t, e.parent, n, r.value, r.deps); case 1024: return function (t, e, n, r, s) { const i = s.length; switch (i) { case 0: return r(); case 1: return r(os(t, e, n, s[0])); case 2: return r(os(t, e, n, s[0]), os(t, e, n, s[1])); case 3: return r(os(t, e, n, s[0]), os(t, e, n, s[1]), os(t, e, n, s[2])); default: const o = Array(i); for (let r = 0; r < i; r++)o[r] = os(t, e, n, s[r]); return r(...o) } }(t, e.parent, n, r.value, r.deps); case 2048: return os(t, e.parent, n, r.deps[0]); case 256: return r.value } } function ss(t, e, n, r, s) { const i = s.length; switch (i) { case 0: return new r; case 1: return new r(os(t, e, n, s[0])); case 2: return new r(os(t, e, n, s[0]), os(t, e, n, s[1])); case 3: return new r(os(t, e, n, s[0]), os(t, e, n, s[1]), os(t, e, n, s[2])); default: const o = new Array(i); for (let r = 0; r < i; r++)o[r] = os(t, e, n, s[r]); return new r(...o) } } const is = {}; function os(t, e, n, r, s = ke.THROW_IF_NOT_FOUND) { if (8 & r.flags) return r.token; const i = t; 2 & r.flags && (s = null); const o = r.tokenKey; o === Gr && (n = !(!e || !e.element.componentView)), e && 1 & r.flags && (n = !1, e = e.parent); let a = t; for (; a;) { if (e) switch (o) { case qr: return Br(as(a, e, n)); case Wr: return as(a, e, n).renderer; case Qr: return new tn(Dn(a, e.nodeIndex).renderElement); case Kr: return Dn(a, e.nodeIndex).viewContainer; case Zr: if (e.element.template) return Dn(a, e.nodeIndex).template; break; case Gr: return Nr(as(a, e, n)); case Yr: case Xr: return Lr(a, e); default: const t = (n ? e.element.allProviders : e.element.publicProviders)[o]; if (t) { let e = Fn(a, t.nodeIndex); return e || (e = { instance: rs(a, t) }, a.nodes[t.nodeIndex] = e), e.instance } }n = Jn(a), e = Xn(a), a = a.parent, 4 & r.flags && (a = null) } const l = i.root.injector.get(r.token, is); return l !== is || s === is ? l : i.root.ngModule.injector.get(r.token, s) } function as(t, e, n) { let r; if (n) r = Dn(t, e.nodeIndex).componentView; else for (r = t; r.parent && !Jn(r);)r = r.parent; return r } function ls(t, e, n, r, s, i) { if (32768 & n.flags) { const e = Dn(t, n.parent.nodeIndex).componentView; 2 & e.def.flags && (e.state |= 8) } if (e.instance[n.bindings[r].name] = s, 524288 & n.flags) { i = i || {}; const e = Be.unwrap(t.oldValues[n.bindingIndex + r]); i[n.bindings[r].nonMinifiedName] = new We(e, s, 0 != (2 & t.state)) } return t.oldValues[n.bindingIndex + r] = s, i } function cs(t, e) { if (!(t.def.nodeFlags & e)) return; const n = t.def.nodes; let r = 0; for (let s = 0; s < n.length; s++) { const i = n[s]; let o = i.parent; for (!o && i.flags & e && us(t, s, i.flags & e, r++), 0 == (i.childFlags & e) && (s += i.childCount); o && 1 & o.flags && s === o.nodeIndex + o.childCount;)o.directChildFlags & e && (r = hs(t, o, e, r)), o = o.parent } } function hs(t, e, n, r) { for (let s = e.nodeIndex + 1; s <= e.nodeIndex + e.childCount; s++) { const e = t.def.nodes[s]; e.flags & n && us(t, s, e.flags & n, r++), s += e.childCount } return r } function us(t, e, n, r) { const s = Fn(t, e); if (!s) return; const i = s.instance; i && (jn.setCurrentNode(t, e), 1048576 & n && On(t, 512, r) && i.ngAfterContentInit(), 2097152 & n && i.ngAfterContentChecked(), 4194304 & n && On(t, 768, r) && i.ngAfterViewInit(), 8388608 & n && i.ngAfterViewChecked(), 131072 & n && i.ngOnDestroy()) } const ds = new Tt("SCHEDULER_TOKEN", { providedIn: "root", factory: () => Vt }), ps = {}, fs = function () { var t = { LocaleId: 0, DayPeriodsFormat: 1, DayPeriodsStandalone: 2, DaysFormat: 3, DaysStandalone: 4, MonthsFormat: 5, MonthsStandalone: 6, Eras: 7, FirstDayOfWeek: 8, WeekendRange: 9, DateFormat: 10, TimeFormat: 11, DateTimeFormat: 12, NumberSymbols: 13, NumberFormats: 14, CurrencySymbol: 15, CurrencyName: 16, Currencies: 17, PluralCase: 18, ExtraData: 19 }; return t[t.LocaleId] = "LocaleId", t[t.DayPeriodsFormat] = "DayPeriodsFormat", t[t.DayPeriodsStandalone] = "DayPeriodsStandalone", t[t.DaysFormat] = "DaysFormat", t[t.DaysStandalone] = "DaysStandalone", t[t.MonthsFormat] = "MonthsFormat", t[t.MonthsStandalone] = "MonthsStandalone", t[t.Eras] = "Eras", t[t.FirstDayOfWeek] = "FirstDayOfWeek", t[t.WeekendRange] = "WeekendRange", t[t.DateFormat] = "DateFormat", t[t.TimeFormat] = "TimeFormat", t[t.DateTimeFormat] = "DateTimeFormat", t[t.NumberSymbols] = "NumberSymbols", t[t.NumberFormats] = "NumberFormats", t[t.CurrencySymbol] = "CurrencySymbol", t[t.CurrencyName] = "CurrencyName", t[t.Currencies] = "Currencies", t[t.PluralCase] = "PluralCase", t[t.ExtraData] = "ExtraData", t }(), ms = void 0; var gs = ["en", [["a", "p"], ["AM", "PM"], ms], [["AM", "PM"], ms, ms], [["S", "M", "T", "W", "T", "F", "S"], ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]], ms, [["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]], ms, [["B", "A"], ["BC", "AD"], ["Before Christ", "Anno Domini"]], 0, [6, 0], ["M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y"], ["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"], ["{1}, {0}", ms, "{1} 'at' {0}", ms], [".", ",", ";", "%", "+", "-", "E", "\xd7", "\u2030", "\u221e", "NaN", ":"], ["#,##0.###", "#,##0%", "\xa4#,##0.00", "#E0"], "$", "US Dollar", {}, function (t) { let e = Math.floor(Math.abs(t)), n = t.toString().replace(/^[^.]*\.?/, "").length; return 1 === e && 0 === n ? 1 : 5 }]; class ys extends k { constructor(t = !1) { super(), this.__isAsync = t } emit(t) { super.next(t) } subscribe(t, e, n) { let r, s = t => null, i = () => null; t && "object" == typeof t ? (r = this.__isAsync ? e => { setTimeout(() => t.next(e)) } : e => { t.next(e) }, t.error && (s = this.__isAsync ? e => { setTimeout(() => t.error(e)) } : e => { t.error(e) }), t.complete && (i = this.__isAsync ? () => { setTimeout(() => t.complete()) } : () => { t.complete() })) : (r = this.__isAsync ? e => { setTimeout(() => t(e)) } : e => { t(e) }, e && (s = this.__isAsync ? t => { setTimeout(() => e(t)) } : t => { e(t) }), n && (i = this.__isAsync ? () => { setTimeout(() => n()) } : () => { n() })); const o = super.subscribe(r, s, i); return t instanceof d && t.add(o), o } } function _s() { return this._results[Le()]() } class vs { constructor() { this.dirty = !0, this._results = [], this.changes = new ys, this.length = 0; const t = Le(), e = vs.prototype; e[t] || (e[t] = _s) } map(t) { return this._results.map(t) } filter(t) { return this._results.filter(t) } find(t) { return this._results.find(t) } reduce(t, e) { return this._results.reduce(t, e) } forEach(t) { this._results.forEach(t) } some(t) { return this._results.some(t) } toArray() { return this._results.slice() } toString() { return this._results.toString() } reset(t) { this._results = function t(e, n) { void 0 === n && (n = e); for (let r = 0; r < e.length; r++) { let s = e[r]; Array.isArray(s) ? (n === e && (n = e.slice(0, r)), t(s, n)) : n !== e && n.push(s) } return n }(t), this.dirty = !1, this.length = this._results.length, this.last = this._results[this.length - 1], this.first = this._results[0] } notifyOnChanges() { this.changes.emit(this) } setDirty() { this.dirty = !0 } destroy() { this.changes.complete(), this.changes.unsubscribe() } } const bs = new Tt("Application Initializer"); class ws { constructor(t) { this.appInits = t, this.initialized = !1, this.done = !1, this.donePromise = new Promise((t, e) => { this.resolve = t, this.reject = e }) } runInitializers() { if (this.initialized) return; const t = [], e = () => { this.done = !0, this.resolve() }; if (this.appInits) for (let n = 0; n < this.appInits.length; n++) { const e = this.appInits[n](); ze(e) && t.push(e) } Promise.all(t).then(() => { e() }).catch(t => { this.reject(t) }), 0 === t.length && e(), this.initialized = !0 } } const Ss = new Tt("AppId"); function Es() { return "".concat(Cs()).concat(Cs()).concat(Cs()) } function Cs() { return String.fromCharCode(97 + Math.floor(25 * Math.random())) } const xs = new Tt("Platform Initializer"), Ts = new Tt("Platform ID"), ks = new Tt("appBootstrapListener"); class As { log(t) { console.log(t) } warn(t) { console.warn(t) } } const Rs = new Tt("LocaleId"); function Ps() { throw new Error("Runtime compiler is not loaded") } const Is = Ps, Os = Ps, Ns = Ps, Ds = Ps; class Fs { constructor() { this.compileModuleSync = Is, this.compileModuleAsync = Os, this.compileModuleAndAllComponentsSync = Ns, this.compileModuleAndAllComponentsAsync = Ds } clearCache() { } clearCacheFor(t) { } getModuleId(t) { } } class Ms { } let Ls, js; const Us = function () { const t = xt.wtf; return !(!t || (Ls = t.trace, !Ls) || (js = Ls.events, 0)) }(); function Bs(t, e) { return null } const Hs = Us ? function (t, e = null) { return js.createScope(t, e) } : (t, e) => Bs, Vs = Us ? function (t, e) { return Ls.leaveScope(t, e), e } : (t, e) => e, zs = Promise.resolve(0); function qs(t) { "undefined" == typeof Zone ? zs.then(() => { t && t.apply(null, null) }) : Zone.current.scheduleMicroTask("scheduleMicrotask", t) } class Ws { constructor({ enableLongStackTrace: t = !1 }) { if (this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new ys(!1), this.onMicrotaskEmpty = new ys(!1), this.onStable = new ys(!1), this.onError = new ys(!1), "undefined" == typeof Zone) throw new Error("In this configuration Angular requires Zone.js"); var e; Zone.assertZonePatched(), this._nesting = 0, this._outer = this._inner = Zone.current, Zone.wtfZoneSpec && (this._inner = this._inner.fork(Zone.wtfZoneSpec)), Zone.TaskTrackingZoneSpec && (this._inner = this._inner.fork(new Zone.TaskTrackingZoneSpec)), t && Zone.longStackTraceZoneSpec && (this._inner = this._inner.fork(Zone.longStackTraceZoneSpec)), (e = this)._inner = e._inner.fork({ name: "angular", properties: { isAngularZone: !0 }, onInvokeTask: (t, n, r, s, i, o) => { try { return Gs(e), t.invokeTask(r, s, i, o) } finally { Ys(e) } }, onInvoke: (t, n, r, s, i, o, a) => { try { return Gs(e), t.invoke(r, s, i, o, a) } finally { Ys(e) } }, onHasTask: (t, n, r, s) => { t.hasTask(r, s), n === r && ("microTask" == s.change ? (e.hasPendingMicrotasks = s.microTask, Zs(e)) : "macroTask" == s.change && (e.hasPendingMacrotasks = s.macroTask)) }, onHandleError: (t, n, r, s) => (t.handleError(r, s), e.runOutsideAngular(() => e.onError.emit(s)), !1) }) } static isInAngularZone() { return !0 === Zone.current.get("isAngularZone") } static assertInAngularZone() { if (!Ws.isInAngularZone()) throw new Error("Expected to be in Angular Zone, but it is not!") } static assertNotInAngularZone() { if (Ws.isInAngularZone()) throw new Error("Expected to not be in Angular Zone, but it is!") } run(t, e, n) { return this._inner.run(t, e, n) } runTask(t, e, n, r) { const s = this._inner, i = s.scheduleEventTask("NgZoneEvent: " + r, t, Ks, Qs, Qs); try { return s.runTask(i, e, n) } finally { s.cancelTask(i) } } runGuarded(t, e, n) { return this._inner.runGuarded(t, e, n) } runOutsideAngular(t) { return this._outer.run(t) } } function Qs() { } const Ks = {}; function Zs(t) { if (0 == t._nesting && !t.hasPendingMicrotasks && !t.isStable) try { t._nesting++, t.onMicrotaskEmpty.emit(null) } finally { if (t._nesting--, !t.hasPendingMicrotasks) try { t.runOutsideAngular(() => t.onStable.emit(null)) } finally { t.isStable = !0 } } } function Gs(t) { t._nesting++, t.isStable && (t.isStable = !1, t.onUnstable.emit(null)) } function Ys(t) { t._nesting--, Zs(t) } class Xs { constructor() { this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new ys, this.onMicrotaskEmpty = new ys, this.onStable = new ys, this.onError = new ys } run(t) { return t() } runGuarded(t) { return t() } runOutsideAngular(t) { return t() } runTask(t) { return t() } } class $s { constructor(t) { this._ngZone = t, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, this._callbacks = [], this.taskTrackingZone = null, this._watchAngularEvents(), t.run(() => { this.taskTrackingZone = "undefined" == typeof Zone ? null : Zone.current.get("TaskTrackingZone") }) } _watchAngularEvents() { this._ngZone.onUnstable.subscribe({ next: () => { this._didWork = !0, this._isZoneStable = !1 } }), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.subscribe({ next: () => { Ws.assertNotInAngularZone(), qs(() => { this._isZoneStable = !0, this._runCallbacksIfReady() }) } }) }) } increasePendingRequestCount() { return this._pendingCount += 1, this._didWork = !0, this._pendingCount } decreasePendingRequestCount() { if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero"); return this._runCallbacksIfReady(), this._pendingCount } isStable() { return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks } _runCallbacksIfReady() { if (this.isStable()) qs(() => { for (; 0 !== this._callbacks.length;) { let t = this._callbacks.pop(); clearTimeout(t.timeoutId), t.doneCb(this._didWork) } this._didWork = !1 }); else { let t = this.getPendingTasks(); this._callbacks = this._callbacks.filter(e => !e.updateCb || !e.updateCb(t) || (clearTimeout(e.timeoutId), !1)), this._didWork = !0 } } getPendingTasks() { return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(t => ({ source: t.source, creationLocation: t.creationLocation, data: t.data })) : [] } addCallback(t, e, n) { let r = -1; e && e > 0 && (r = setTimeout(() => { this._callbacks = this._callbacks.filter(t => t.timeoutId !== r), t(this._didWork, this.getPendingTasks()) }, e)), this._callbacks.push({ doneCb: t, timeoutId: r, updateCb: n }) } whenStable(t, e, n) { if (n && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/dist/task-tracking.js" loaded?'); this.addCallback(t, e, n), this._runCallbacksIfReady() } getPendingRequestCount() { return this._pendingCount } findProviders(t, e, n) { return [] } } class Js { constructor() { this._applications = new Map, ei.addToWindow(this) } registerApplication(t, e) { this._applications.set(t, e) } unregisterApplication(t) { this._applications.delete(t) } unregisterAllApplications() { this._applications.clear() } getTestability(t) { return this._applications.get(t) || null } getAllTestabilities() { return Array.from(this._applications.values()) } getAllRootElements() { return Array.from(this._applications.keys()) } findTestabilityInTree(t, e = !0) { return ei.findTestabilityInTree(this, t, e) } } let ti, ei = new class { addToWindow(t) { } findTestabilityInTree(t, e, n) { return null } }; const ni = new Tt("AllowMultipleToken"); class ri { constructor(t, e) { this.name = t, this.token = e } } function si(t, e, n = []) { const r = "Platform: ".concat(e), s = new Tt(r); return (e = []) => { let i = ii(); if (!i || i.injector.get(ni, !1)) if (t) t(n.concat(e).concat({ provide: s, useValue: !0 })); else { const t = n.concat(e).concat({ provide: s, useValue: !0 }); !function (t) { if (ti && !ti.destroyed && !ti.injector.get(ni, !1)) throw new Error("There can be only one platform. Destroy the previous one to create a new one."); ti = t.get(oi); const e = t.get(xs, null); e && e.forEach(t => t()) }(ke.create({ providers: t, name: r })) } return function (t) { const e = ii(); if (!e) throw new Error("No platform exists!"); if (!e.injector.get(t, null)) throw new Error("A platform with a different configuration has been created. Please destroy it first."); return e }(s) } } function ii() { return ti && !ti.destroyed ? ti : null } class oi { constructor(t) { this._injector = t, this._modules = [], this._destroyListeners = [], this._destroyed = !1 } bootstrapModuleFactory(t, e) { const n = function (t) { let e; return e = "noop" === t ? new Xs : ("zone.js" === t ? void 0 : t) || new Ws({ enableLongStackTrace: Gt() }), e }(e ? e.ngZone : void 0), r = [{ provide: Ws, useValue: n }]; return n.run(() => { const e = ke.create({ providers: r, parent: this.injector, name: t.moduleType.name }), s = t.create(e), i = s.injector.get(Qt, null); if (!i) throw new Error("No ErrorHandler. Is platform module (BrowserModule) included?"); return s.onDestroy(() => ci(this._modules, s)), n.runOutsideAngular(() => n.onError.subscribe({ next: t => { i.handleError(t) } })), function (t, e, n) { try { const r = n(); return ze(r) ? r.catch(n => { throw e.runOutsideAngular(() => t.handleError(n)), n }) : r } catch (r) { throw e.runOutsideAngular(() => t.handleError(r)), r } }(i, n, () => { const t = s.injector.get(ws); return t.runInitializers(), t.donePromise.then(() => (this._moduleDoBootstrap(s), s)) }) }) } bootstrapModule(t, e = []) { const n = ai({}, e); return function (t, e, n) { return t.get(Ms).createCompiler([e]).compileModuleAsync(n) }(this.injector, n, t).then(t => this.bootstrapModuleFactory(t, n)) } _moduleDoBootstrap(t) { const e = t.injector.get(li); if (t._bootstrapComponents.length > 0) t._bootstrapComponents.forEach(t => e.bootstrap(t)); else { if (!t.instance.ngDoBootstrap) throw new Error("The module ".concat(yt(t.instance.constructor), ' was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. ') + "Please define one of these."); t.instance.ngDoBootstrap(e) } this._modules.push(t) } onDestroy(t) { this._destroyListeners.push(t) } get injector() { return this._injector } destroy() { if (this._destroyed) throw new Error("The platform has already been destroyed!"); this._modules.slice().forEach(t => t.destroy()), this._destroyListeners.forEach(t => t()), this._destroyed = !0 } get destroyed() { return this._destroyed } } function ai(t, e) { return Array.isArray(e) ? e.reduce(ai, t) : Object.assign({}, t, e) } let li = (() => { class t { constructor(t, e, n, r, s, i) { this._zone = t, this._console = e, this._injector = n, this._exceptionHandler = r, this._componentFactoryResolver = s, this._initStatus = i, this._bootstrapListeners = [], this._views = [], this._runningTick = !1, this._enforceNoNewChanges = !1, this._stable = !0, this.componentTypes = [], this.components = [], this._enforceNoNewChanges = Gt(), this._zone.onMicrotaskEmpty.subscribe({ next: () => { this._zone.run(() => { this.tick() }) } }); const o = new w(t => { this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks, this._zone.runOutsideAngular(() => { t.next(this._stable), t.complete() }) }), a = new w(t => { let e; this._zone.runOutsideAngular(() => { e = this._zone.onStable.subscribe(() => { Ws.assertNotInAngularZone(), qs(() => { this._stable || this._zone.hasPendingMacrotasks || this._zone.hasPendingMicrotasks || (this._stable = !0, t.next(!0)) }) }) }); const n = this._zone.onUnstable.subscribe(() => { Ws.assertInAngularZone(), this._stable && (this._stable = !1, this._zone.runOutsideAngular(() => { t.next(!1) })) }); return () => { e.unsubscribe(), n.unsubscribe() } }); this.isStable = X(o, a.pipe(t => $()(st(ot)(t)))) } bootstrap(t, e) { if (!this._initStatus.done) throw new Error("Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module."); let n; n = t instanceof Qe ? t : this._componentFactoryResolver.resolveComponentFactory(t), this.componentTypes.push(n.componentType); const r = n instanceof $e ? null : this._injector.get(Lt), s = n.create(ke.NULL, [], e || n.selector, r); s.onDestroy(() => { this._unloadComponent(s) }); const i = s.injector.get($s, null); return i && s.injector.get(Js).registerApplication(s.location.nativeElement, i), this._loadComponent(s), Gt() && this._console.log("Angular is running in the development mode. Call enableProdMode() to enable the production mode."), s } tick() { if (this._runningTick) throw new Error("ApplicationRef.tick is called recursively"); const e = t._tickScope(); try { this._runningTick = !0; for (let t of this._views) t.detectChanges(); if (this._enforceNoNewChanges) for (let t of this._views) t.checkNoChanges() } catch (n) { this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(n)) } finally { this._runningTick = !1, Vs(e) } } attachView(t) { const e = t; this._views.push(e), e.attachToAppRef(this) } detachView(t) { const e = t; ci(this._views, e), e.detachFromAppRef() } _loadComponent(t) { this.attachView(t.hostView), this.tick(), this.components.push(t), this._injector.get(ks, []).concat(this._bootstrapListeners).forEach(e => e(t)) } _unloadComponent(t) { this.detachView(t.hostView), ci(this.components, t) } ngOnDestroy() { this._views.slice().forEach(t => t.destroy()) } get viewCount() { return this._views.length } } return t._tickScope = Hs("ApplicationRef#tick()"), t })(); function ci(t, e) { const n = t.indexOf(e); n > -1 && t.splice(n, 1) } class hi { } class ui { } const di = { factoryPathPrefix: "", factoryPathSuffix: ".ngfactory" }; class pi { constructor(t, e) { this._compiler = t, this._config = e || di } load(t) { return this._compiler instanceof Fs ? this.loadFactory(t) : this.loadAndCompile(t) } loadAndCompile(t) { let [e, r] = t.split("#"); return void 0 === r && (r = "default"), n("zn8P")(e).then(t => t[r]).then(t => fi(t, e, r)).then(t => this._compiler.compileModuleAsync(t)) } loadFactory(t) { let [e, r] = t.split("#"), s = "NgFactory"; return void 0 === r && (r = "default", s = ""), n("zn8P")(this._config.factoryPathPrefix + e + this._config.factoryPathSuffix).then(t => t[r + s]).then(t => fi(t, e, r)) } } function fi(t, e, n) { if (!t) throw new Error("Cannot find '".concat(n, "' in '").concat(e, "'")); return t } class mi { constructor(t, e) { this.name = t, this.callback = e } } class gi { constructor(t, e, n) { this.listeners = [], this.parent = null, this._debugContext = n, this.nativeNode = t, e && e instanceof yi && e.addChild(this) } get injector() { return this._debugContext.injector } get componentInstance() { return this._debugContext.component } get context() { return this._debugContext.context } get references() { return this._debugContext.references } get providerTokens() { return this._debugContext.providerTokens } } class yi extends gi { constructor(t, e, n) { super(t, e, n), this.properties = {}, this.attributes = {}, this.classes = {}, this.styles = {}, this.childNodes = [], this.nativeElement = t } addChild(t) { t && (this.childNodes.push(t), t.parent = this) } removeChild(t) { const e = this.childNodes.indexOf(t); -1 !== e && (t.parent = null, this.childNodes.splice(e, 1)) } insertChildrenAfter(t, e) { const n = this.childNodes.indexOf(t); -1 !== n && (this.childNodes.splice(n + 1, 0, ...e), e.forEach(e => { e.parent && e.parent.removeChild(e), t.parent = this })) } insertBefore(t, e) { const n = this.childNodes.indexOf(t); -1 === n ? this.addChild(e) : (e.parent && e.parent.removeChild(e), e.parent = this, this.childNodes.splice(n, 0, e)) } query(t) { return this.queryAll(t)[0] || null } queryAll(t) { const e = []; return function t(e, n, r) { e.childNodes.forEach(e => { e instanceof yi && (n(e) && r.push(e), t(e, n, r)) }) }(this, t, e), e } queryAllNodes(t) { const e = []; return function t(e, n, r) { e instanceof yi && e.childNodes.forEach(e => { n(e) && r.push(e), e instanceof yi && t(e, n, r) }) }(this, t, e), e } get children() { return this.childNodes.filter(t => t instanceof yi) } triggerEventHandler(t, e) { this.listeners.forEach(n => { n.name == t && n.callback(e) }) } } const _i = new Map, vi = function (t) { return _i.get(t) || null }; function bi(t) { _i.set(t.nativeNode, t) } const wi = si(null, "core", [{ provide: Ts, useValue: "unknown" }, { provide: oi, deps: [ke] }, { provide: Js, deps: [] }, { provide: As, deps: [] }]); function Si() { return Sn } function Ei() { return En } function Ci(t) { return t || "en-US" } function xi(t) { let e = []; return t.onStable.subscribe(() => { for (; e.length;)e.pop()() }), function (t) { e.push(t) } } class Ti { constructor(t) { } } function ki(t, e, n, r, s, i) { t |= 1; const { matchedQueries: o, references: a, matchedQueryIds: l } = nr(e); return { nodeIndex: -1, parent: null, renderParent: null, bindingIndex: -1, outputIndex: -1, flags: t, checkIndex: -1, childFlags: 0, directChildFlags: 0, childMatchedQueries: 0, matchedQueries: o, matchedQueryIds: l, references: a, ngContentIndex: n, childCount: r, bindings: [], bindingFlags: 0, outputs: [], element: { ns: null, name: null, attrs: null, template: i ? or(i) : null, componentProvider: null, componentView: null, componentRendererType: null, publicProviders: null, allProviders: null, handleEvent: s || Un }, provider: null, text: null, query: null, ngContent: null } } function Ai(t, e, n, r, s, i, o = [], a, l, c, h, u) { c || (c = Un); const { matchedQueries: d, references: p, matchedQueryIds: f } = nr(n); let m = null, g = null; i && ([m, g] = pr(i)), a = a || []; const y = new Array(a.length); for (let b = 0; b < a.length; b++) { const [t, e, n] = a[b], [r, s] = pr(e); let i = void 0, o = void 0; switch (15 & t) { case 4: o = n; break; case 1: case 8: i = n }y[b] = { flags: t, ns: r, name: s, nonMinifiedName: s, securityContext: i, suffix: o } } l = l || []; const _ = new Array(l.length); for (let b = 0; b < l.length; b++) { const [t, e] = l[b]; _[b] = { type: 0, target: t, eventName: e, propName: null } } const v = (o = o || []).map(([t, e]) => { const [n, r] = pr(t); return [n, r, e] }); return u = function (t) { if (t && "$$undefined" === t.id) { const e = null != t.encapsulation && t.encapsulation !== Ht.None || t.styles.length || Object.keys(t.data).length; t.id = e ? "c".concat(zn++) : "$$empty" } return t && "$$empty" === t.id && (t = null), t || null }(u), h && (e |= 33554432), { nodeIndex: -1, parent: null, renderParent: null, bindingIndex: -1, outputIndex: -1, checkIndex: t, flags: e |= 1, childFlags: 0, directChildFlags: 0, childMatchedQueries: 0, matchedQueries: d, matchedQueryIds: f, references: p, ngContentIndex: r, childCount: s, bindings: y, bindingFlags: fr(y), outputs: _, element: { ns: m, name: g, attrs: v, template: null, componentProvider: null, componentView: h || null, componentRendererType: u, publicProviders: null, allProviders: null, handleEvent: c || Un }, provider: null, text: null, query: null, ngContent: null } } function Ri(t, e, n) { const r = n.element, s = t.root.selectorOrNode, i = t.renderer; let o; if (t.parent || !s) { o = r.name ? i.createElement(r.name, r.ns) : i.createComment(""); const s = sr(t, e, n); s && i.appendChild(s, o) } else o = i.selectRootElement(s, !!r.componentRendererType && r.componentRendererType.encapsulation === Ht.ShadowDom); if (r.attrs) for (let a = 0; a < r.attrs.length; a++) { const [t, e, n] = r.attrs[a]; i.setAttribute(o, e, n, t) } return o } function Pi(t, e, n, r) { for (let o = 0; o < n.outputs.length; o++) { const a = n.outputs[o], l = Ii(t, n.nodeIndex, (i = a.eventName, (s = a.target) ? "".concat(s, ":").concat(i) : i)); let c = a.target, h = t; "component" === a.target && (c = null, h = e); const u = h.renderer.listen(c || r, a.eventName, l); t.disposables[n.outputIndex + o] = u } var s, i } function Ii(t, e, n) { return r => Gn(t, e, n, r) } function Oi(t, e, n, r) { if (!Wn(t, e, n, r)) return !1; const s = e.bindings[n], i = Dn(t, e.nodeIndex), o = i.renderElement, a = s.name; switch (15 & s.flags) { case 1: !function (t, e, n, r, s, i) { const o = e.securityContext; let a = o ? t.root.sanitizer.sanitize(o, i) : i; a = null != a ? a.toString() : null; const l = t.renderer; null != i ? l.setAttribute(n, s, a, r) : l.removeAttribute(n, s, r) }(t, s, o, s.ns, a, r); break; case 2: !function (t, e, n, r) { const s = t.renderer; r ? s.addClass(e, n) : s.removeClass(e, n) }(t, o, a, r); break; case 4: !function (t, e, n, r, s) { let i = t.root.sanitizer.sanitize(ye.STYLE, s); if (null != i) { i = i.toString(); const t = e.suffix; null != t && (i += t) } else i = null; const o = t.renderer; null != i ? o.setStyle(n, r, i) : o.removeStyle(n, r) }(t, s, o, a, r); break; case 8: !function (t, e, n, r, s) { const i = e.securityContext; let o = i ? t.root.sanitizer.sanitize(i, s) : s; t.renderer.setProperty(n, r, o) }(33554432 & e.flags && 32 & s.flags ? i.componentView : t, s, o, a, r) }return !0 } function Ni(t, e, n) { let r = []; for (let s in n) r.push({ propName: s, bindingType: n[s] }); return { nodeIndex: -1, parent: null, renderParent: null, bindingIndex: -1, outputIndex: -1, checkIndex: -1, flags: t, childFlags: 0, directChildFlags: 0, childMatchedQueries: 0, ngContentIndex: -1, matchedQueries: {}, matchedQueryIds: 0, references: {}, childCount: 0, bindings: [], bindingFlags: 0, outputs: [], element: null, provider: null, text: null, query: { id: e, filterId: er(e), bindings: r }, ngContent: null } } function Di(t) { const e = t.def.nodeMatchedQueries; for (; t.parent && tr(t);) { let n = t.parentNodeDef; t = t.parent; const r = n.nodeIndex + n.childCount; for (let s = 0; s <= r; s++) { const r = t.def.nodes[s]; 67108864 & r.flags && 536870912 & r.flags && (r.query.filterId & e) === r.query.filterId && Ln(t, s).setDirty(), !(1 & r.flags && s + r.childCount < n.nodeIndex) && 67108864 & r.childFlags && 536870912 & r.childFlags || (s += r.childCount) } } if (134217728 & t.def.nodeFlags) for (let n = 0; n < t.def.nodes.length; n++) { const e = t.def.nodes[n]; 134217728 & e.flags && 536870912 & e.flags && Ln(t, n).setDirty(), n += e.childCount } } function Fi(t, e) { const n = Ln(t, e.nodeIndex); if (!n.dirty) return; let r, s = void 0; if (67108864 & e.flags) { const n = e.parent.parent; s = Mi(t, n.nodeIndex, n.nodeIndex + n.childCount, e.query, []), r = Fn(t, e.parent.nodeIndex).instance } else 134217728 & e.flags && (s = Mi(t, 0, t.def.nodes.length - 1, e.query, []), r = t.component); n.reset(s); const i = e.query.bindings; let o = !1; for (let a = 0; a < i.length; a++) { const t = i[a]; let e; switch (t.bindingType) { case 0: e = n.first; break; case 1: e = n, o = !0 }r[t.propName] = e } o && n.notifyOnChanges() } function Mi(t, e, n, r, s) { for (let i = e; i <= n; i++) { const e = t.def.nodes[i], n = e.matchedQueries[r.id]; if (null != n && s.push(Li(t, e, n)), 1 & e.flags && e.element.template && (e.element.template.nodeMatchedQueries & r.filterId) === r.filterId) { const n = Dn(t, i); if ((e.childMatchedQueries & r.filterId) === r.filterId && (Mi(t, i + 1, i + e.childCount, r, s), i += e.childCount), 16777216 & e.flags) { const t = n.viewContainer._embeddedViews; for (let e = 0; e < t.length; e++) { const i = t[e], o = Yn(i); o && o === n && Mi(i, 0, i.def.nodes.length - 1, r, s) } } const o = n.template._projectedViews; if (o) for (let t = 0; t < o.length; t++) { const e = o[t]; Mi(e, 0, e.def.nodes.length - 1, r, s) } } (e.childMatchedQueries & r.filterId) !== r.filterId && (i += e.childCount) } return s } function Li(t, e, n) { if (null != n) switch (n) { case 1: return Dn(t, e.nodeIndex).renderElement; case 0: return new tn(Dn(t, e.nodeIndex).renderElement); case 2: return Dn(t, e.nodeIndex).template; case 3: return Dn(t, e.nodeIndex).viewContainer; case 4: return Fn(t, e.nodeIndex).instance } } function ji(t, e) { return { nodeIndex: -1, parent: null, renderParent: null, bindingIndex: -1, outputIndex: -1, checkIndex: -1, flags: 8, childFlags: 0, directChildFlags: 0, childMatchedQueries: 0, matchedQueries: {}, matchedQueryIds: 0, references: {}, ngContentIndex: t, childCount: 0, bindings: [], bindingFlags: 0, outputs: [], element: null, provider: null, text: null, query: null, ngContent: { index: e } } } function Ui(t, e, n) { const r = sr(t, e, n); r && cr(t, n.ngContent.index, 1, r, null, void 0) } function Bi(t, e, n) { const r = new Array(n.length - 1); for (let s = 1; s < n.length; s++)r[s - 1] = { flags: 8, name: null, ns: null, nonMinifiedName: null, securityContext: null, suffix: n[s] }; return { nodeIndex: -1, parent: null, renderParent: null, bindingIndex: -1, outputIndex: -1, checkIndex: t, flags: 2, childFlags: 0, directChildFlags: 0, childMatchedQueries: 0, matchedQueries: {}, matchedQueryIds: 0, references: {}, ngContentIndex: e, childCount: 0, bindings: r, bindingFlags: 8, outputs: [], element: null, provider: null, text: { prefix: n[0] }, query: null, ngContent: null } } function Hi(t, e, n) { let r; const s = t.renderer; r = s.createText(n.text.prefix); const i = sr(t, e, n); return i && s.appendChild(i, r), { renderText: r } } function Vi(t, e) { return (null != t ? t.toString() : "") + e.suffix } function zi(t, e, n, r) { let s = 0, i = 0, o = 0, a = 0, l = 0, c = null, h = null, u = !1, d = !1, p = null; for (let f = 0; f < e.length; f++) { const t = e[f]; if (t.nodeIndex = f, t.parent = c, t.bindingIndex = s, t.outputIndex = i, t.renderParent = h, o |= t.flags, l |= t.matchedQueryIds, t.element) { const e = t.element; e.publicProviders = c ? c.element.publicProviders : Object.create(null), e.allProviders = e.publicProviders, u = !1, d = !1, t.element.template && (l |= t.element.template.nodeMatchedQueries) } if (Wi(c, t, e.length), s += t.bindings.length, i += t.outputs.length, !h && 3 & t.flags && (p = t), 20224 & t.flags) { u || (u = !0, c.element.publicProviders = Object.create(c.element.publicProviders), c.element.allProviders = c.element.publicProviders); const e = 0 != (32768 & t.flags); 0 == (8192 & t.flags) || e ? c.element.publicProviders[Hn(t.provider.token)] = t : (d || (d = !0, c.element.allProviders = Object.create(c.element.publicProviders)), c.element.allProviders[Hn(t.provider.token)] = t), e && (c.element.componentProvider = t) } if (c ? (c.childFlags |= t.flags, c.directChildFlags |= t.flags, c.childMatchedQueries |= t.matchedQueryIds, t.element && t.element.template && (c.childMatchedQueries |= t.element.template.nodeMatchedQueries)) : a |= t.flags, t.childCount > 0) c = t, qi(t) || (h = t); else for (; c && f === c.nodeIndex + c.childCount;) { const t = c.parent; t && (t.childFlags |= c.childFlags, t.childMatchedQueries |= c.childMatchedQueries), c = t, h = c && qi(c) ? c.renderParent : c } } return { factory: null, nodeFlags: o, rootNodeFlags: a, nodeMatchedQueries: l, flags: t, nodes: e, updateDirectives: n || Un, updateRenderer: r || Un, handleEvent: (t, n, r, s) => e[n].element.handleEvent(t, r, s), bindingCount: s, outputCount: i, lastRenderRootNode: p } } function qi(t) { return 0 != (1 & t.flags) && null === t.element.name } function Wi(t, e, n) { const r = e.element && e.element.template; if (r) { if (!r.lastRenderRootNode) throw new Error("Illegal State: Embedded templates without nodes are not allowed!"); if (r.lastRenderRootNode && 16777216 & r.lastRenderRootNode.flags) throw new Error("Illegal State: Last root node of a template can't have embedded views, at index ".concat(e.nodeIndex, "!")) } if (20224 & e.flags && 0 == (1 & (t ? t.flags : 0))) throw new Error("Illegal State: StaticProvider/Directive nodes need to be children of elements or anchors, at index ".concat(e.nodeIndex, "!")); if (e.query) { if (67108864 & e.flags && (!t || 0 == (16384 & t.flags))) throw new Error("Illegal State: Content Query nodes need to be children of directives, at index ".concat(e.nodeIndex, "!")); if (134217728 & e.flags && t) throw new Error("Illegal State: View Query nodes have to be top level nodes, at index ".concat(e.nodeIndex, "!")) } if (e.childCount) { const r = t ? t.nodeIndex + t.childCount : n - 1; if (e.nodeIndex <= r && e.nodeIndex + e.childCount > r) throw new Error("Illegal State: childCount of node leads outside of parent, at index ".concat(e.nodeIndex, "!")) } } function Qi(t, e, n, r) { const s = Gi(t.root, t.renderer, t, e, n); return Yi(s, t.component, r), Xi(s), s } function Ki(t, e, n) { const r = Gi(t, t.renderer, null, null, e); return Yi(r, n, n), Xi(r), r } function Zi(t, e, n, r) { const s = e.element.componentRendererType; let i; return i = s ? t.root.rendererFactory.createRenderer(r, s) : t.root.renderer, Gi(t.root, i, t, e.element.componentProvider, n) } function Gi(t, e, n, r, s) { const i = new Array(s.nodes.length), o = s.outputCount ? new Array(s.outputCount) : null; return { def: s, parent: n, viewContainerParent: null, parentNodeDef: r, context: null, component: null, nodes: i, state: 13, root: t, renderer: e, oldValues: new Array(s.bindingCount), disposables: o, initIndex: -1 } } function Yi(t, e, n) { t.component = e, t.context = n } function Xi(t) { let e; Jn(t) && (e = Dn(t.parent, t.parentNodeDef.parent.nodeIndex).renderElement); const n = t.def, r = t.nodes; for (let s = 0; s < n.nodes.length; s++) { const i = n.nodes[s]; let o; switch (jn.setCurrentNode(t, s), 201347067 & i.flags) { case 1: const n = Ri(t, e, i); let a = void 0; if (33554432 & i.flags) { const e = or(i.element.componentView); a = jn.createComponentView(t, i, e, n) } Pi(t, a, i, n), o = { renderElement: n, componentView: a, viewContainer: null, template: i.element.template ? Fr(t, i) : void 0 }, 16777216 & i.flags && (o.viewContainer = Ir(t, i, o)); break; case 2: o = Hi(t, e, i); break; case 512: case 1024: case 2048: case 256: o = r[s], o || 4096 & i.flags || (o = { instance: Jr(t, i) }); break; case 16: o = { instance: ts(t, i) }; break; case 16384: o = r[s], o || (o = { instance: es(t, i) }), 32768 & i.flags && Yi(Dn(t, i.parent.nodeIndex).componentView, o.instance, o.instance); break; case 32: case 64: case 128: o = { value: void 0 }; break; case 67108864: case 134217728: o = new vs; break; case 8: Ui(t, e, i), o = void 0 }r[s] = o } oo(t, io.CreateViewNodes), ho(t, 201326592, 268435456, 0) } function $i(t) { eo(t), jn.updateDirectives(t, 1), ao(t, io.CheckNoChanges), jn.updateRenderer(t, 1), oo(t, io.CheckNoChanges), t.state &= -97 } function Ji(t) { 1 & t.state ? (t.state &= -2, t.state |= 2) : t.state &= -3, In(t, 0, 256), eo(t), jn.updateDirectives(t, 0), ao(t, io.CheckAndUpdate), ho(t, 67108864, 536870912, 0); let e = In(t, 256, 512); cs(t, 2097152 | (e ? 1048576 : 0)), jn.updateRenderer(t, 0), oo(t, io.CheckAndUpdate), ho(t, 134217728, 536870912, 0), e = In(t, 512, 768), cs(t, 8388608 | (e ? 4194304 : 0)), 2 & t.def.flags && (t.state &= -9), t.state &= -97, In(t, 768, 1024) } function to(t, e, n, r, s, i, o, a, l, c, h, u, d) { return 0 === n ? function (t, e, n, r, s, i, o, a, l, c, h, u) { switch (201347067 & e.flags) { case 1: return function (t, e, n, r, s, i, o, a, l, c, h, u) { const d = e.bindings.length; let p = !1; return d > 0 && Oi(t, e, 0, n) && (p = !0), d > 1 && Oi(t, e, 1, r) && (p = !0), d > 2 && Oi(t, e, 2, s) && (p = !0), d > 3 && Oi(t, e, 3, i) && (p = !0), d > 4 && Oi(t, e, 4, o) && (p = !0), d > 5 && Oi(t, e, 5, a) && (p = !0), d > 6 && Oi(t, e, 6, l) && (p = !0), d > 7 && Oi(t, e, 7, c) && (p = !0), d > 8 && Oi(t, e, 8, h) && (p = !0), d > 9 && Oi(t, e, 9, u) && (p = !0), p }(t, e, n, r, s, i, o, a, l, c, h, u); case 2: return function (t, e, n, r, s, i, o, a, l, c, h, u) { let d = !1; const p = e.bindings, f = p.length; if (f > 0 && Wn(t, e, 0, n) && (d = !0), f > 1 && Wn(t, e, 1, r) && (d = !0), f > 2 && Wn(t, e, 2, s) && (d = !0), f > 3 && Wn(t, e, 3, i) && (d = !0), f > 4 && Wn(t, e, 4, o) && (d = !0), f > 5 && Wn(t, e, 5, a) && (d = !0), f > 6 && Wn(t, e, 6, l) && (d = !0), f > 7 && Wn(t, e, 7, c) && (d = !0), f > 8 && Wn(t, e, 8, h) && (d = !0), f > 9 && Wn(t, e, 9, u) && (d = !0), d) { let d = e.text.prefix; f > 0 && (d += Vi(n, p[0])), f > 1 && (d += Vi(r, p[1])), f > 2 && (d += Vi(s, p[2])), f > 3 && (d += Vi(i, p[3])), f > 4 && (d += Vi(o, p[4])), f > 5 && (d += Vi(a, p[5])), f > 6 && (d += Vi(l, p[6])), f > 7 && (d += Vi(c, p[7])), f > 8 && (d += Vi(h, p[8])), f > 9 && (d += Vi(u, p[9])); const m = Nn(t, e.nodeIndex).renderText; t.renderer.setValue(m, d) } return d }(t, e, n, r, s, i, o, a, l, c, h, u); case 16384: return function (t, e, n, r, s, i, o, a, l, c, h, u) { const d = Fn(t, e.nodeIndex), p = d.instance; let f = !1, m = void 0; const g = e.bindings.length; return g > 0 && qn(t, e, 0, n) && (f = !0, m = ls(t, d, e, 0, n, m)), g > 1 && qn(t, e, 1, r) && (f = !0, m = ls(t, d, e, 1, r, m)), g > 2 && qn(t, e, 2, s) && (f = !0, m = ls(t, d, e, 2, s, m)), g > 3 && qn(t, e, 3, i) && (f = !0, m = ls(t, d, e, 3, i, m)), g > 4 && qn(t, e, 4, o) && (f = !0, m = ls(t, d, e, 4, o, m)), g > 5 && qn(t, e, 5, a) && (f = !0, m = ls(t, d, e, 5, a, m)), g > 6 && qn(t, e, 6, l) && (f = !0, m = ls(t, d, e, 6, l, m)), g > 7 && qn(t, e, 7, c) && (f = !0, m = ls(t, d, e, 7, c, m)), g > 8 && qn(t, e, 8, h) && (f = !0, m = ls(t, d, e, 8, h, m)), g > 9 && qn(t, e, 9, u) && (f = !0, m = ls(t, d, e, 9, u, m)), m && p.ngOnChanges(m), 65536 & e.flags && On(t, 256, e.nodeIndex) && p.ngOnInit(), 262144 & e.flags && p.ngDoCheck(), f }(t, e, n, r, s, i, o, a, l, c, h, u); case 32: case 64: case 128: return function (t, e, n, r, s, i, o, a, l, c, h, u) { const d = e.bindings; let p = !1; const f = d.length; if (f > 0 && Wn(t, e, 0, n) && (p = !0), f > 1 && Wn(t, e, 1, r) && (p = !0), f > 2 && Wn(t, e, 2, s) && (p = !0), f > 3 && Wn(t, e, 3, i) && (p = !0), f > 4 && Wn(t, e, 4, o) && (p = !0), f > 5 && Wn(t, e, 5, a) && (p = !0), f > 6 && Wn(t, e, 6, l) && (p = !0), f > 7 && Wn(t, e, 7, c) && (p = !0), f > 8 && Wn(t, e, 8, h) && (p = !0), f > 9 && Wn(t, e, 9, u) && (p = !0), p) { const p = Mn(t, e.nodeIndex); let m; switch (201347067 & e.flags) { case 32: m = new Array(d.length), f > 0 && (m[0] = n), f > 1 && (m[1] = r), f > 2 && (m[2] = s), f > 3 && (m[3] = i), f > 4 && (m[4] = o), f > 5 && (m[5] = a), f > 6 && (m[6] = l), f > 7 && (m[7] = c), f > 8 && (m[8] = h), f > 9 && (m[9] = u); break; case 64: m = {}, f > 0 && (m[d[0].name] = n), f > 1 && (m[d[1].name] = r), f > 2 && (m[d[2].name] = s), f > 3 && (m[d[3].name] = i), f > 4 && (m[d[4].name] = o), f > 5 && (m[d[5].name] = a), f > 6 && (m[d[6].name] = l), f > 7 && (m[d[7].name] = c), f > 8 && (m[d[8].name] = h), f > 9 && (m[d[9].name] = u); break; case 128: const t = n; switch (f) { case 1: m = t.transform(n); break; case 2: m = t.transform(r); break; case 3: m = t.transform(r, s); break; case 4: m = t.transform(r, s, i); break; case 5: m = t.transform(r, s, i, o); break; case 6: m = t.transform(r, s, i, o, a); break; case 7: m = t.transform(r, s, i, o, a, l); break; case 8: m = t.transform(r, s, i, o, a, l, c); break; case 9: m = t.transform(r, s, i, o, a, l, c, h); break; case 10: m = t.transform(r, s, i, o, a, l, c, h, u) } }p.value = m } return p }(t, e, n, r, s, i, o, a, l, c, h, u); default: throw "unreachable" } }(t, e, r, s, i, o, a, l, c, h, u, d) : function (t, e, n) { switch (201347067 & e.flags) { case 1: return function (t, e, n) { let r = !1; for (let s = 0; s < n.length; s++)Oi(t, e, s, n[s]) && (r = !0); return r }(t, e, n); case 2: return function (t, e, n) { const r = e.bindings; let s = !1; for (let i = 0; i < n.length; i++)Wn(t, e, i, n[i]) && (s = !0); if (s) { let s = ""; for (let t = 0; t < n.length; t++)s += Vi(n[t], r[t]); s = e.text.prefix + s; const i = Nn(t, e.nodeIndex).renderText; t.renderer.setValue(i, s) } return s }(t, e, n); case 16384: return function (t, e, n) { const r = Fn(t, e.nodeIndex), s = r.instance; let i = !1, o = void 0; for (let a = 0; a < n.length; a++)qn(t, e, a, n[a]) && (i = !0, o = ls(t, r, e, a, n[a], o)); return o && s.ngOnChanges(o), 65536 & e.flags && On(t, 256, e.nodeIndex) && s.ngOnInit(), 262144 & e.flags && s.ngDoCheck(), i }(t, e, n); case 32: case 64: case 128: return function (t, e, n) { const r = e.bindings; let s = !1; for (let i = 0; i < n.length; i++)Wn(t, e, i, n[i]) && (s = !0); if (s) { const s = Mn(t, e.nodeIndex); let i; switch (201347067 & e.flags) { case 32: i = n; break; case 64: i = {}; for (let s = 0; s < n.length; s++)i[r[s].name] = n[s]; break; case 128: const t = n[0], e = n.slice(1); i = t.transform(...e) }s.value = i } return s }(t, e, n); default: throw "unreachable" } }(t, e, r) } function eo(t) { const e = t.def; if (4 & e.nodeFlags) for (let n = 0; n < e.nodes.length; n++) { const r = e.nodes[n]; if (4 & r.flags) { const e = Dn(t, n).template._projectedViews; if (e) for (let n = 0; n < e.length; n++) { const r = e[n]; r.state |= 32, Zn(r, t) } } else 0 == (4 & r.childFlags) && (n += r.childCount) } } function no(t, e, n, r, s, i, o, a, l, c, h, u, d) { return 0 === n ? function (t, e, n, r, s, i, o, a, l, c, h, u) { const d = e.bindings.length; d > 0 && Qn(t, e, 0, n), d > 1 && Qn(t, e, 1, r), d > 2 && Qn(t, e, 2, s), d > 3 && Qn(t, e, 3, i), d > 4 && Qn(t, e, 4, o), d > 5 && Qn(t, e, 5, a), d > 6 && Qn(t, e, 6, l), d > 7 && Qn(t, e, 7, c), d > 8 && Qn(t, e, 8, h), d > 9 && Qn(t, e, 9, u) }(t, e, r, s, i, o, a, l, c, h, u, d) : function (t, e, n) { for (let r = 0; r < n.length; r++)Qn(t, e, r, n[r]) }(t, e, r), !1 } function ro(t, e) { if (Ln(t, e.nodeIndex).dirty) throw An(jn.createDebugContext(t, e.nodeIndex), "Query ".concat(e.query.id, " not dirty"), "Query ".concat(e.query.id, " dirty"), 0 != (1 & t.state)) } function so(t) { if (!(128 & t.state)) { if (ao(t, io.Destroy), oo(t, io.Destroy), cs(t, 131072), t.disposables) for (let e = 0; e < t.disposables.length; e++)t.disposables[e](); !function (t) { if (!(16 & t.state)) return; const e = Yn(t); if (e) { const n = e.template._projectedViews; n && (Bt(n, n.indexOf(t)), jn.dirtyParentQueries(t)) } }(t), t.renderer.destroyNode && function (t) { const e = t.def.nodes.length; for (let n = 0; n < e; n++) { const e = t.def.nodes[n]; 1 & e.flags ? t.renderer.destroyNode(Dn(t, n).renderElement) : 2 & e.flags ? t.renderer.destroyNode(Nn(t, n).renderText) : (67108864 & e.flags || 134217728 & e.flags) && Ln(t, n).destroy() } }(t), Jn(t) && t.renderer.destroy(), t.state |= 128 } } const io = function () { var t = { CreateViewNodes: 0, CheckNoChanges: 1, CheckNoChangesProjectedViews: 2, CheckAndUpdate: 3, CheckAndUpdateProjectedViews: 4, Destroy: 5 }; return t[t.CreateViewNodes] = "CreateViewNodes", t[t.CheckNoChanges] = "CheckNoChanges", t[t.CheckNoChangesProjectedViews] = "CheckNoChangesProjectedViews", t[t.CheckAndUpdate] = "CheckAndUpdate", t[t.CheckAndUpdateProjectedViews] = "CheckAndUpdateProjectedViews", t[t.Destroy] = "Destroy", t }(); function oo(t, e) { const n = t.def; if (33554432 & n.nodeFlags) for (let r = 0; r < n.nodes.length; r++) { const s = n.nodes[r]; 33554432 & s.flags ? lo(Dn(t, r).componentView, e) : 0 == (33554432 & s.childFlags) && (r += s.childCount) } } function ao(t, e) { const n = t.def; if (16777216 & n.nodeFlags) for (let r = 0; r < n.nodes.length; r++) { const s = n.nodes[r]; if (16777216 & s.flags) { const n = Dn(t, r).viewContainer._embeddedViews; for (let t = 0; t < n.length; t++)lo(n[t], e) } else 0 == (16777216 & s.childFlags) && (r += s.childCount) } } function lo(t, e) { const n = t.state; switch (e) { case io.CheckNoChanges: 0 == (128 & n) && (12 == (12 & n) ? $i(t) : 64 & n && co(t, io.CheckNoChangesProjectedViews)); break; case io.CheckNoChangesProjectedViews: 0 == (128 & n) && (32 & n ? $i(t) : 64 & n && co(t, e)); break; case io.CheckAndUpdate: 0 == (128 & n) && (12 == (12 & n) ? Ji(t) : 64 & n && co(t, io.CheckAndUpdateProjectedViews)); break; case io.CheckAndUpdateProjectedViews: 0 == (128 & n) && (32 & n ? Ji(t) : 64 & n && co(t, e)); break; case io.Destroy: so(t); break; case io.CreateViewNodes: Xi(t) } } function co(t, e) { ao(t, e), oo(t, e) } function ho(t, e, n, r) { if (!(t.def.nodeFlags & e && t.def.nodeFlags & n)) return; const s = t.def.nodes.length; for (let i = 0; i < s; i++) { const s = t.def.nodes[i]; if (s.flags & e && s.flags & n) switch (jn.setCurrentNode(t, s.nodeIndex), r) { case 0: Fi(t, s); break; case 1: ro(t, s) }s.childFlags & e && s.childFlags & n || (i += s.childCount) } } let uo = !1; function po(t, e, n, r, s, i) { const o = s.injector.get(nn); return Ki(mo(t, s, o, e, n), r, i) } function fo(t, e, n, r, s, i) { const o = s.injector.get(nn), a = mo(t, s, new Ko(o), e, n), l = xo(r); return Wo(Io.create, Ki, null, [a, l, i]) } function mo(t, e, n, r, s) { const i = e.injector.get(_e), o = e.injector.get(Qt), a = n.createRenderer(null, null); return { ngModule: e, injector: t, projectableNodes: r, selectorOrNode: s, sanitizer: i, rendererFactory: n, renderer: a, errorHandler: o } } function go(t, e, n, r) { const s = xo(n); return Wo(Io.create, Qi, null, [t, e, s, r]) } function yo(t, e, n, r) { return n = wo.get(e.element.componentProvider.provider.token) || xo(n), Wo(Io.create, Zi, null, [t, e, n, r]) } function _o(t, e, n, r) { return Vr(t, e, n, function (t) { const { hasOverrides: e, hasDeprecatedOverrides: n } = function (t) { let e = !1, n = !1; return 0 === vo.size ? { hasOverrides: e, hasDeprecatedOverrides: n } : (t.providers.forEach(t => { const r = vo.get(t.token); 3840 & t.flags && r && (e = !0, n = n || r.deprecatedBehavior) }), t.modules.forEach(t => { bo.forEach((r, s) => { mt(s).providedIn === t && (e = !0, n = n || r.deprecatedBehavior) }) }), { hasOverrides: e, hasDeprecatedOverrides: n }) }(t); return e ? (function (t) { for (let e = 0; e < t.providers.length; e++) { const r = t.providers[e]; n && (r.flags |= 4096); const s = vo.get(r.token); s && (r.flags = -3841 & r.flags | s.flags, r.deps = rr(s.deps), r.value = s.value) } if (bo.size > 0) { let e = new Set(t.modules); bo.forEach((r, s) => { if (e.has(mt(s).providedIn)) { let e = { token: s, flags: r.flags | (n ? 4096 : 0), deps: rr(r.deps), value: r.value, index: t.providers.length }; t.providers.push(e), t.providersByKey[Hn(s)] = e } }) } }(t = t.factory(() => Un)), t) : t }(r)) } const vo = new Map, bo = new Map, wo = new Map; function So(t) { let e; vo.set(t.token, t), "function" == typeof t.token && (e = mt(t.token)) && "function" == typeof e.providedIn && bo.set(t.token, t) } function Eo(t, e) { const n = or(e.viewDefFactory), r = or(n.nodes[0].element.componentView); wo.set(t, r) } function Co() { vo.clear(), bo.clear(), wo.clear() } function xo(t) { if (0 === vo.size) return t; const e = function (t) { const e = []; let n = null; for (let r = 0; r < t.nodes.length; r++) { const s = t.nodes[r]; 1 & s.flags && (n = s), n && 3840 & s.flags && vo.has(s.provider.token) && (e.push(n.nodeIndex), n = null) } return e }(t); if (0 === e.length) return t; t = t.factory(() => Un); for (let r = 0; r < e.length; r++)n(t, e[r]); return t; function n(t, e) { for (let n = e + 1; n < t.nodes.length; n++) { const e = t.nodes[n]; if (1 & e.flags) return; if (3840 & e.flags) { const t = e.provider, n = vo.get(t.token); n && (e.flags = -3841 & e.flags | n.flags, t.deps = rr(n.deps), t.value = n.value) } } } } function To(t, e, n, r, s, i, o, a, l, c, h, u, d) { const p = t.def.nodes[e]; return to(t, p, n, r, s, i, o, a, l, c, h, u, d), 224 & p.flags ? Mn(t, e).value : void 0 } function ko(t, e, n, r, s, i, o, a, l, c, h, u, d) { const p = t.def.nodes[e]; return no(t, p, n, r, s, i, o, a, l, c, h, u, d), 224 & p.flags ? Mn(t, e).value : void 0 } function Ao(t) { return Wo(Io.detectChanges, Ji, null, [t]) } function Ro(t) { return Wo(Io.checkNoChanges, $i, null, [t]) } function Po(t) { return Wo(Io.destroy, so, null, [t]) } const Io = function () { var t = { create: 0, detectChanges: 1, checkNoChanges: 2, destroy: 3, handleEvent: 4 }; return t[t.create] = "create", t[t.detectChanges] = "detectChanges", t[t.checkNoChanges] = "checkNoChanges", t[t.destroy] = "destroy", t[t.handleEvent] = "handleEvent", t }(); let Oo, No, Do; function Fo(t, e) { No = t, Do = e } function Mo(t, e, n, r) { return Fo(t, e), Wo(Io.handleEvent, t.def.handleEvent, null, [t, e, n, r]) } function Lo(t, e) { if (128 & t.state) throw Pn(Io[Oo]); return Fo(t, Ho(t, 0)), t.def.updateDirectives((function (t, n, r, ...s) { const i = t.def.nodes[n]; return 0 === e ? Uo(t, i, r, s) : Bo(t, i, r, s), 16384 & i.flags && Fo(t, Ho(t, n)), 224 & i.flags ? Mn(t, i.nodeIndex).value : void 0 }), t) } function jo(t, e) { if (128 & t.state) throw Pn(Io[Oo]); return Fo(t, Vo(t, 0)), t.def.updateRenderer((function (t, n, r, ...s) { const i = t.def.nodes[n]; return 0 === e ? Uo(t, i, r, s) : Bo(t, i, r, s), 3 & i.flags && Fo(t, Vo(t, n)), 224 & i.flags ? Mn(t, i.nodeIndex).value : void 0 }), t) } function Uo(t, e, n, r) { if (to(t, e, n, ...r)) { const o = 1 === n ? r[0] : r; if (16384 & e.flags) { const n = {}; for (let t = 0; t < e.bindings.length; t++) { const r = e.bindings[t], a = o[t]; 8 & r.flags && (n[(s = r.nonMinifiedName, i = void 0, i = s.replace(/[$@]/g, "_"), "ng-reflect-".concat(s = i.replace(we, (...t) => "-" + t[1].toLowerCase())))] = Se(a)) } const r = e.parent, a = Dn(t, r.nodeIndex).renderElement; if (r.element.name) for (let e in n) { const r = n[e]; null != r ? t.renderer.setAttribute(a, e, r) : t.renderer.removeAttribute(a, e) } else t.renderer.setValue(a, "bindings=".concat(JSON.stringify(n, null, 2))) } } var s, i } function Bo(t, e, n, r) { no(t, e, n, ...r) } function Ho(t, e) { for (let n = e; n < t.def.nodes.length; n++) { const e = t.def.nodes[n]; if (16384 & e.flags && e.bindings && e.bindings.length) return n } return null } function Vo(t, e) { for (let n = e; n < t.def.nodes.length; n++) { const e = t.def.nodes[n]; if (3 & e.flags && e.bindings && e.bindings.length) return n } return null } class zo { constructor(t, e) { this.view = t, this.nodeIndex = e, null == e && (this.nodeIndex = e = 0), this.nodeDef = t.def.nodes[e]; let n = this.nodeDef, r = t; for (; n && 0 == (1 & n.flags);)n = n.parent; if (!n) for (; !n && r;)n = Xn(r), r = r.parent; this.elDef = n, this.elView = r } get elOrCompView() { return Dn(this.elView, this.elDef.nodeIndex).componentView || this.view } get injector() { return Lr(this.elView, this.elDef) } get component() { return this.elOrCompView.component } get context() { return this.elOrCompView.context } get providerTokens() { const t = []; if (this.elDef) for (let e = this.elDef.nodeIndex + 1; e <= this.elDef.nodeIndex + this.elDef.childCount; e++) { const n = this.elView.def.nodes[e]; 20224 & n.flags && t.push(n.provider.token), e += n.childCount } return t } get references() { const t = {}; if (this.elDef) { qo(this.elView, this.elDef, t); for (let e = this.elDef.nodeIndex + 1; e <= this.elDef.nodeIndex + this.elDef.childCount; e++) { const n = this.elView.def.nodes[e]; 20224 & n.flags && qo(this.elView, n, t), e += n.childCount } } return t } get componentRenderElement() { const t = function (t) { for (; t && !Jn(t);)t = t.parent; return t.parent ? Dn(t.parent, Xn(t).nodeIndex) : null }(this.elOrCompView); return t ? t.renderElement : void 0 } get renderNode() { return 2 & this.nodeDef.flags ? $n(this.view, this.nodeDef) : $n(this.elView, this.elDef) } logError(t, ...e) { let n, r; 2 & this.nodeDef.flags ? (n = this.view.def, r = this.nodeDef.nodeIndex) : (n = this.elView.def, r = this.elDef.nodeIndex); const s = function (t, e) { let n = -1; for (let r = 0; r <= e; r++)3 & t.nodes[r].flags && n++; return n }(n, r); let i = -1; n.factory(() => (i++, i === s ? t.error.bind(t, ...e) : Un)), i < s && (t.error("Illegal state: the ViewDefinitionFactory did not call the logger!"), t.error(...e)) } } function qo(t, e, n) { for (let r in e.references) n[r] = Li(t, e, e.references[r]) } function Wo(t, e, n, r) { const s = Oo, i = No, o = Do; try { Oo = t; const a = e.apply(n, r); return No = i, Do = o, Oo = s, a } catch (c) { if (zt(c) || !No) throw c; throw a = c, l = Qo(), a instanceof Error || (a = new Error(a.toString())), Rn(a, l), a } var a, l } function Qo() { return No ? new zo(No, Do) : null } class Ko { constructor(t) { this.delegate = t } createRenderer(t, e) { return new Zo(this.delegate.createRenderer(t, e)) } begin() { this.delegate.begin && this.delegate.begin() } end() { this.delegate.end && this.delegate.end() } whenRenderingDone() { return this.delegate.whenRenderingDone ? this.delegate.whenRenderingDone() : Promise.resolve(null) } } class Zo { constructor(t) { this.delegate = t, this.debugContextFactory = Qo, this.data = this.delegate.data } createDebugContext(t) { return this.debugContextFactory(t) } destroyNode(t) { const e = vi(t); !function (t) { _i.delete(t.nativeNode) }(e), e instanceof gi && (e.listeners.length = 0), this.delegate.destroyNode && this.delegate.destroyNode(t) } destroy() { this.delegate.destroy() } createElement(t, e) { const n = this.delegate.createElement(t, e), r = this.createDebugContext(n); if (r) { const e = new yi(n, null, r); e.name = t, bi(e) } return n } createComment(t) { const e = this.delegate.createComment(t), n = this.createDebugContext(e); return n && bi(new gi(e, null, n)), e } createText(t) { const e = this.delegate.createText(t), n = this.createDebugContext(e); return n && bi(new gi(e, null, n)), e } appendChild(t, e) { const n = vi(t), r = vi(e); n && r && n instanceof yi && n.addChild(r), this.delegate.appendChild(t, e) } insertBefore(t, e, n) { const r = vi(t), s = vi(e), i = vi(n); r && s && r instanceof yi && r.insertBefore(i, s), this.delegate.insertBefore(t, e, n) } removeChild(t, e) { const n = vi(t), r = vi(e); n && r && n instanceof yi && n.removeChild(r), this.delegate.removeChild(t, e) } selectRootElement(t, e) { const n = this.delegate.selectRootElement(t, e), r = Qo(); return r && bi(new yi(n, null, r)), n } setAttribute(t, e, n, r) { const s = vi(t); s && s instanceof yi && (s.attributes[r ? r + ":" + e : e] = n), this.delegate.setAttribute(t, e, n, r) } removeAttribute(t, e, n) { const r = vi(t); r && r instanceof yi && (r.attributes[n ? n + ":" + e : e] = null), this.delegate.removeAttribute(t, e, n) } addClass(t, e) { const n = vi(t); n && n instanceof yi && (n.classes[e] = !0), this.delegate.addClass(t, e) } removeClass(t, e) { const n = vi(t); n && n instanceof yi && (n.classes[e] = !1), this.delegate.removeClass(t, e) } setStyle(t, e, n, r) { const s = vi(t); s && s instanceof yi && (s.styles[e] = n), this.delegate.setStyle(t, e, n, r) } removeStyle(t, e, n) { const r = vi(t); r && r instanceof yi && (r.styles[e] = null), this.delegate.removeStyle(t, e, n) } setProperty(t, e, n) { const r = vi(t); r && r instanceof yi && (r.properties[e] = n), this.delegate.setProperty(t, e, n) } listen(t, e, n) { if ("string" != typeof t) { const r = vi(t); r && r.listeners.push(new mi(e, n)) } return this.delegate.listen(t, e, n) } parentNode(t) { return this.delegate.parentNode(t) } nextSibling(t) { return this.delegate.nextSibling(t) } setValue(t, e) { return this.delegate.setValue(t, e) } } class Go extends jt { constructor(t, e, n) { super(), this.moduleType = t, this._bootstrapComponents = e, this._ngModuleDefFactory = n } create(t) { !function () { if (uo) return; uo = !0; const t = Gt() ? { setCurrentNode: Fo, createRootView: fo, createEmbeddedView: go, createComponentView: yo, createNgModuleRef: _o, overrideProvider: So, overrideComponentView: Eo, clearOverrides: Co, checkAndUpdateView: Ao, checkNoChangesView: Ro, destroyView: Po, createDebugContext: (t, e) => new zo(t, e), handleEvent: Mo, updateDirectives: Lo, updateRenderer: jo } : { setCurrentNode: () => { }, createRootView: po, createEmbeddedView: Qi, createComponentView: Zi, createNgModuleRef: Vr, overrideProvider: Un, overrideComponentView: Un, clearOverrides: Un, checkAndUpdateView: Ji, checkNoChangesView: $i, destroyView: so, createDebugContext: (t, e) => new zo(t, e), handleEvent: (t, e, n, r) => t.def.handleEvent(t, e, n, r), updateDirectives: (t, e) => t.def.updateDirectives(0 === e ? To : ko, t), updateRenderer: (t, e) => t.def.updateRenderer(0 === e ? To : ko, t) }; jn.setCurrentNode = t.setCurrentNode, jn.createRootView = t.createRootView, jn.createEmbeddedView = t.createEmbeddedView, jn.createComponentView = t.createComponentView, jn.createNgModuleRef = t.createNgModuleRef, jn.overrideProvider = t.overrideProvider, jn.overrideComponentView = t.overrideComponentView, jn.clearOverrides = t.clearOverrides, jn.checkAndUpdateView = t.checkAndUpdateView, jn.checkNoChangesView = t.checkNoChangesView, jn.destroyView = t.destroyView, jn.resolveDep = os, jn.createDebugContext = t.createDebugContext, jn.handleEvent = t.handleEvent, jn.updateDirectives = t.updateDirectives, jn.updateRenderer = t.updateRenderer, jn.dirtyParentQueries = Di }(); const e = function (t) { const e = Array.from(t.providers), n = Array.from(t.modules), r = {}; for (const s in t.providersByKey) r[s] = t.providersByKey[s]; return { factory: t.factory, isRoot: t.isRoot, providers: e, modules: n, providersByKey: r } }(or(this._ngModuleDefFactory)); return jn.createNgModuleRef(this.moduleType, t || ke.NULL, this._bootstrapComponents, e) } } class Yo { } class Xo { constructor() { this.title = "library" } } class $o { } const Jo = new Tt("Location Initialized"); class ta { } const ea = new Tt("appBaseHref"); class na { constructor(t, e) { this._subject = new ys, this._urlChangeListeners = [], this._platformStrategy = t; const n = this._platformStrategy.getBaseHref(); this._platformLocation = e, this._baseHref = na.stripTrailingSlash(ra(n)), this._platformStrategy.onPopState(t => { this._subject.emit({ url: this.path(!0), pop: !0, state: t.state, type: t.type }) }) } path(t = !1) { return this.normalize(this._platformStrategy.path(t)) } getState() { return this._platformLocation.getState() } isCurrentPathEqualTo(t, e = "") { return this.path() == this.normalize(t + na.normalizeQueryParams(e)) } normalize(t) { return na.stripTrailingSlash(function (t, e) { return t && e.startsWith(t) ? e.substring(t.length) : e }(this._baseHref, ra(t))) } prepareExternalUrl(t) { return t && "/" !== t[0] && (t = "/" + t), this._platformStrategy.prepareExternalUrl(t) } go(t, e = "", n = null) { this._platformStrategy.pushState(n, "", t, e), this._notifyUrlChangeListeners(this.prepareExternalUrl(t + na.normalizeQueryParams(e)), n) } replaceState(t, e = "", n = null) { this._platformStrategy.replaceState(n, "", t, e), this._notifyUrlChangeListeners(this.prepareExternalUrl(t + na.normalizeQueryParams(e)), n) } forward() { this._platformStrategy.forward() } back() { this._platformStrategy.back() } onUrlChange(t) { this._urlChangeListeners.push(t), this.subscribe(t => { this._notifyUrlChangeListeners(t.url, t.state) }) } _notifyUrlChangeListeners(t = "", e) { this._urlChangeListeners.forEach(n => n(t, e)) } subscribe(t, e, n) { return this._subject.subscribe({ next: t, error: e, complete: n }) } static normalizeQueryParams(t) { return t && "?" !== t[0] ? "?" + t : t } static joinWithSlash(t, e) { if (0 == t.length) return e; if (0 == e.length) return t; let n = 0; return t.endsWith("/") && n++, e.startsWith("/") && n++, 2 == n ? t + e.substring(1) : 1 == n ? t + e : t + "/" + e } static stripTrailingSlash(t) { const e = t.match(/#|\?|$/), n = e && e.index || t.length; return t.slice(0, n - ("/" === t[n - 1] ? 1 : 0)) + t.slice(n) } } function ra(t) { return t.replace(/\/index.html$/, "") } class sa extends ta { constructor(t, e) { super(), this._platformLocation = t, this._baseHref = "", null != e && (this._baseHref = e) } onPopState(t) { this._platformLocation.onPopState(t), this._platformLocation.onHashChange(t) } getBaseHref() { return this._baseHref } path(t = !1) { let e = this._platformLocation.hash; return null == e && (e = "#"), e.length > 0 ? e.substring(1) : e } prepareExternalUrl(t) { const e = na.joinWithSlash(this._baseHref, t); return e.length > 0 ? "#" + e : e } pushState(t, e, n, r) { let s = this.prepareExternalUrl(n + na.normalizeQueryParams(r)); 0 == s.length && (s = this._platformLocation.pathname), this._platformLocation.pushState(t, e, s) } replaceState(t, e, n, r) { let s = this.prepareExternalUrl(n + na.normalizeQueryParams(r)); 0 == s.length && (s = this._platformLocation.pathname), this._platformLocation.replaceState(t, e, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } } class ia extends ta { constructor(t, e) { if (super(), this._platformLocation = t, null == e && (e = this._platformLocation.getBaseHrefFromDOM()), null == e) throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document."); this._baseHref = e } onPopState(t) { this._platformLocation.onPopState(t), this._platformLocation.onHashChange(t) } getBaseHref() { return this._baseHref } prepareExternalUrl(t) { return na.joinWithSlash(this._baseHref, t) } path(t = !1) { const e = this._platformLocation.pathname + na.normalizeQueryParams(this._platformLocation.search), n = this._platformLocation.hash; return n && t ? "".concat(e).concat(n) : e } pushState(t, e, n, r) { const s = this.prepareExternalUrl(n + na.normalizeQueryParams(r)); this._platformLocation.pushState(t, e, s) } replaceState(t, e, n, r) { const s = this.prepareExternalUrl(n + na.normalizeQueryParams(r)); this._platformLocation.replaceState(t, e, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } } const oa = function () { var t = { Zero: 0, One: 1, Two: 2, Few: 3, Many: 4, Other: 5 }; return t[t.Zero] = "Zero", t[t.One] = "One", t[t.Two] = "Two", t[t.Few] = "Few", t[t.Many] = "Many", t[t.Other] = "Other", t }(), aa = new Tt("UseV4Plurals"); class la { } class ca extends la { constructor(t, e) { super(), this.locale = t, this.deprecatedPluralFn = e } getPluralCategory(t, e) { switch (this.deprecatedPluralFn ? this.deprecatedPluralFn(e || this.locale, t) : function (t) { return function (t) { const e = t.toLowerCase().replace(/_/g, "-"); let n = ps[e]; if (n) return n; const r = e.split("-")[0]; if (n = ps[r], n) return n; if ("en" === r) return gs; throw new Error('Missing locale data for the locale "'.concat(t, '".')) }(t)[fs.PluralCase] }(e || this.locale)(t)) { case oa.Zero: return "zero"; case oa.One: return "one"; case oa.Two: return "two"; case oa.Few: return "few"; case oa.Many: return "many"; default: return "other" } } } function ha(t, e) { e = encodeURIComponent(e); for (const n of t.split(";")) { const t = n.indexOf("="), [r, s] = -1 == t ? [n, ""] : [n.slice(0, t), n.slice(t + 1)]; if (r.trim() === e) return decodeURIComponent(s) } return null } class ua { constructor(t, e, n, r) { this.$implicit = t, this.ngForOf = e, this.index = n, this.count = r } get first() { return 0 === this.index } get last() { return this.index === this.count - 1 } get even() { return this.index % 2 == 0 } get odd() { return !this.even } } class da { constructor(t, e, n) { this._viewContainer = t, this._template = e, this._differs = n, this._ngForOfDirty = !0, this._differ = null } set ngForOf(t) { this._ngForOf = t, this._ngForOfDirty = !0 } set ngForTrackBy(t) { Gt() && null != t && "function" != typeof t && console && console.warn && console.warn("trackBy must be a function, but received ".concat(JSON.stringify(t), ". ") + "See https://angular.io/docs/ts/latest/api/common/index/NgFor-directive.html#!#change-propagation for more information."), this._trackByFn = t } get ngForTrackBy() { return this._trackByFn } set ngForTemplate(t) { t && (this._template = t) } ngDoCheck() { if (this._ngForOfDirty) { this._ngForOfDirty = !1; const n = this._ngForOf; if (!this._differ && n) try { this._differ = this._differs.find(n).create(this.ngForTrackBy) } catch (e) { throw new Error("Cannot find a differ supporting object '".concat(n, "' of type '").concat((t = n).name || typeof t, "'. NgFor only supports binding to Iterables such as Arrays.")) } } var t; if (this._differ) { const t = this._differ.diff(this._ngForOf); t && this._applyChanges(t) } } _applyChanges(t) { const e = []; t.forEachOperation((t, n, r) => { if (null == t.previousIndex) { const n = this._viewContainer.createEmbeddedView(this._template, new ua(null, this._ngForOf, -1, -1), null === r ? void 0 : r), s = new pa(t, n); e.push(s) } else if (null == r) this._viewContainer.remove(null === n ? void 0 : n); else if (null !== n) { const s = this._viewContainer.get(n); this._viewContainer.move(s, r); const i = new pa(t, s); e.push(i) } }); for (let n = 0; n < e.length; n++)this._perViewChange(e[n].view, e[n].record); for (let n = 0, r = this._viewContainer.length; n < r; n++) { const t = this._viewContainer.get(n); t.context.index = n, t.context.count = r, t.context.ngForOf = this._ngForOf } t.forEachIdentityChange(t => { this._viewContainer.get(t.currentIndex).context.$implicit = t.item }) } _perViewChange(t, e) { t.context.$implicit = e.item } static ngTemplateContextGuard(t, e) { return !0 } } class pa { constructor(t, e) { this.record = t, this.view = e } } class fa { } const ma = new Tt("DocumentToken"); function ga(t) { return "browser" === t } let ya = (() => { class t { } return t.ngInjectableDef = ft({ token: t, providedIn: "root", factory: () => new _a(Nt(ma), window, Nt(Qt)) }), t })(); class _a { constructor(t, e, n) { this.document = t, this.window = e, this.errorHandler = n, this.offset = () => [0, 0] } setOffset(t) { this.offset = Array.isArray(t) ? () => t : t } getScrollPosition() { return this.supportScrollRestoration() ? [this.window.scrollX, this.window.scrollY] : [0, 0] } scrollToPosition(t) { this.supportScrollRestoration() && this.window.scrollTo(t[0], t[1]) } scrollToAnchor(t) { if (this.supportScrollRestoration()) { t = this.window.CSS && this.window.CSS.escape ? this.window.CSS.escape(t) : t.replace(/(\"|\'\ |:|\.|\[|\]|,|=)/g, "\\$1"); try { const e = this.document.querySelector("#".concat(t)); if (e) return void this.scrollToElement(e); const n = this.document.querySelector("[name='".concat(t, "']")); if (n) return void this.scrollToElement(n) } catch (e) { this.errorHandler.handleError(e) } } } setHistoryScrollRestoration(t) { if (this.supportScrollRestoration()) { const e = this.window.history; e && e.scrollRestoration && (e.scrollRestoration = t) } } scrollToElement(t) { const e = t.getBoundingClientRect(), n = e.left + this.window.pageXOffset, r = e.top + this.window.pageYOffset, s = this.offset(); this.window.scrollTo(n - s[0], r - s[1]) } supportScrollRestoration() { try { return !!this.window && !!this.window.scrollTo } catch (t) { return !1 } } } const va = new w(t => t.complete()); function ba(t) { return t ? function (t) { return new w(e => t.schedule(() => e.complete())) }(t) : va } function wa(t) { const e = new w(e => { e.next(t), e.complete() }); return e._isScalar = !0, e.value = t, e } function Sa(...t) { let e = t[t.length - 1]; switch (R(e) ? t.pop() : e = void 0, t.length) { case 0: return ba(e); case 1: return e ? q(t, e) : wa(t[0]); default: return q(t, e) } } class Ea extends k { constructor(t) { super(), this._value = t } get value() { return this.getValue() } _subscribe(t) { const e = super._subscribe(t); return e && !e.closed && t.next(this._value), e } getValue() { if (this.hasError) throw this.thrownError; if (this.closed) throw new C; return this._value } next(t) { super.next(this._value = t) } } function Ca() { return Error.call(this), this.message = "no elements in sequence", this.name = "EmptyError", this } Ca.prototype = Object.create(Error.prototype); const xa = Ca, Ta = {}; class ka { constructor(t) { this.resultSelector = t } call(t, e) { return e.subscribe(new Aa(t, this.resultSelector)) } } class Aa extends B { constructor(t, e) { super(t), this.resultSelector = e, this.active = 0, this.values = [], this.observables = [] } _next(t) { this.values.push(Ta), this.observables.push(t) } _complete() { const t = this.observables, e = t.length; if (0 === e) this.destination.complete(); else { this.active = e, this.toRespond = e; for (let n = 0; n < e; n++) { const e = t[n]; this.add(U(this, e, e, n)) } } } notifyComplete(t) { 0 == (this.active -= 1) && this.destination.complete() } notifyNext(t, e, n, r, s) { const i = this.values, o = this.toRespond ? i[n] === Ta ? --this.toRespond : this.toRespond : 0; i[n] = e, 0 === o && (this.resultSelector ? this._tryResultSelector(i) : this.destination.next(i.slice())) } _tryResultSelector(t) { let e; try { e = this.resultSelector.apply(this, t) } catch (n) { return void this.destination.error(n) } this.destination.next(e) } } function Ra(t) { return new w(e => { let n; try { n = t() } catch (r) { return void e.error(r) } return (n ? W(n) : ba()).subscribe(e) }) } function Pa() { return Y(1) } function Ia(t, e) { return function (n) { return n.lift(new Oa(t, e)) } } class Oa { constructor(t, e) { this.predicate = t, this.thisArg = e } call(t, e) { return e.subscribe(new Na(t, this.predicate, this.thisArg)) } } class Na extends m { constructor(t, e, n) { super(t), this.predicate = e, this.thisArg = n, this.count = 0 } _next(t) { let e; try { e = this.predicate.call(this.thisArg, t, this.count++) } catch (n) { return void this.destination.error(n) } e && this.destination.next(t) } } function Da() { return Error.call(this), this.message = "argument out of range", this.name = "ArgumentOutOfRangeError", this } Da.prototype = Object.create(Error.prototype); const Fa = Da; function Ma(t) { return function (e) { return 0 === t ? ba() : e.lift(new La(t)) } } class La { constructor(t) { if (this.total = t, this.total < 0) throw new Fa } call(t, e) { return e.subscribe(new ja(t, this.total)) } } class ja extends m { constructor(t, e) { super(t), this.total = e, this.ring = new Array, this.count = 0 } _next(t) { const e = this.ring, n = this.total, r = this.count++; e.length < n ? e.push(t) : e[r % n] = t } _complete() { const t = this.destination; let e = this.count; if (e > 0) { const n = this.count >= this.total ? this.total : this.count, r = this.ring; for (let s = 0; s < n; s++) { const s = e++ % n; t.next(r[s]) } } t.complete() } } function Ua(t, e, n) { return function (r) { return r.lift(new Ba(t, e, n)) } } class Ba { constructor(t, e, n) { this.nextOrObserver = t, this.error = e, this.complete = n } call(t, e) { return e.subscribe(new Ha(t, this.nextOrObserver, this.error, this.complete)) } } class Ha extends m { constructor(t, e, n, s) { super(t), this._tapNext = _, this._tapError = _, this._tapComplete = _, this._tapError = n || _, this._tapComplete = s || _, r(e) ? (this._context = this, this._tapNext = e) : e && (this._context = e, this._tapNext = e.next || _, this._tapError = e.error || _, this._tapComplete = e.complete || _) } _next(t) { try { this._tapNext.call(this._context, t) } catch (e) { return void this.destination.error(e) } this.destination.next(t) } _error(t) { try { this._tapError.call(this._context, t) } catch (t) { return void this.destination.error(t) } this.destination.error(t) } _complete() { try { this._tapComplete.call(this._context) } catch (t) { return void this.destination.error(t) } return this.destination.complete() } } const Va = (t = za) => Ua({ hasValue: !1, next() { this.hasValue = !0 }, complete() { if (!this.hasValue) throw t() } }); function za() { return new xa } function qa(t = null) { return e => e.lift(new Wa(t)) } class Wa { constructor(t) { this.defaultValue = t } call(t, e) { return e.subscribe(new Qa(t, this.defaultValue)) } } class Qa extends m { constructor(t, e) { super(t), this.defaultValue = e, this.isEmpty = !0 } _next(t) { this.isEmpty = !1, this.destination.next(t) } _complete() { this.isEmpty && this.destination.next(this.defaultValue), this.destination.complete() } } function Ka(t, e) { const n = arguments.length >= 2; return r => r.pipe(t ? Ia((e, n) => t(e, n, r)) : G, Ma(1), n ? qa(e) : Va(() => new xa)) } function Za(t) { return function (e) { const n = new Ga(t), r = e.lift(n); return n.caught = r } } class Ga { constructor(t) { this.selector = t } call(t, e) { return e.subscribe(new Ya(t, this.selector, this.caught)) } } class Ya extends B { constructor(t, e, n) { super(t), this.selector = e, this.caught = n } error(t) { if (!this.isStopped) { let n; try { n = this.selector(t, this.caught) } catch (e) { return void super.error(e) } this._unsubscribeAndRecycle(); const r = new P(this, void 0, void 0); this.add(r), U(this, n, void 0, void 0, r) } } } function Xa(t) { return e => 0 === t ? ba() : e.lift(new $a(t)) } class $a { constructor(t) { if (this.total = t, this.total < 0) throw new Fa } call(t, e) { return e.subscribe(new Ja(t, this.total)) } } class Ja extends m { constructor(t, e) { super(t), this.total = e, this.count = 0 } _next(t) { const e = this.total, n = ++this.count; n <= e && (this.destination.next(t), n === e && (this.destination.complete(), this.unsubscribe())) } } function tl(t, e) { const n = arguments.length >= 2; return r => r.pipe(t ? Ia((e, n) => t(e, n, r)) : G, Xa(1), n ? qa(e) : Va(() => new xa)) } class el { constructor(t, e, n) { this.predicate = t, this.thisArg = e, this.source = n } call(t, e) { return e.subscribe(new nl(t, this.predicate, this.thisArg, this.source)) } } class nl extends m { constructor(t, e, n, r) { super(t), this.predicate = e, this.thisArg = n, this.source = r, this.index = 0, this.thisArg = n || this } notifyComplete(t) { this.destination.next(t), this.destination.complete() } _next(t) { let e = !1; try { e = this.predicate.call(this.thisArg, t, this.index++, this.source) } catch (n) { return void this.destination.error(n) } e || this.notifyComplete(!1) } _complete() { this.notifyComplete(!0) } } function rl(t, e) { return "function" == typeof e ? n => n.pipe(rl((n, r) => W(t(n, r)).pipe(H((t, s) => e(n, t, r, s))))) : e => e.lift(new sl(t)) } class sl { constructor(t) { this.project = t } call(t, e) { return e.subscribe(new il(t, this.project)) } } class il extends B { constructor(t, e) { super(t), this.project = e, this.index = 0 } _next(t) { let e; const n = this.index++; try { e = this.project(t, n) } catch (r) { return void this.destination.error(r) } this._innerSub(e, t, n) } _innerSub(t, e, n) { const r = this.innerSubscription; r && r.unsubscribe(); const s = new P(this, void 0, void 0); this.destination.add(s), this.innerSubscription = U(this, t, e, n, s) } _complete() { const { innerSubscription: t } = this; t && !t.closed || super._complete(), this.unsubscribe() } _unsubscribe() { this.innerSubscription = null } notifyComplete(t) { this.destination.remove(t), this.innerSubscription = null, this.isStopped && super._complete() } notifyNext(t, e, n, r, s) { this.destination.next(e) } } function ol(...t) { return Pa()(Sa(...t)) } function al(...t) { return e => { let n = t[t.length - 1]; R(n) ? t.pop() : n = null; const r = t.length; return ol(1 !== r || n ? r > 0 ? q(t, n) : ba(n) : wa(t[0]), e) } } function ll(t, e) { let n = !1; return arguments.length >= 2 && (n = !0), function (r) { return r.lift(new cl(t, e, n)) } } class cl { constructor(t, e, n = !1) { this.accumulator = t, this.seed = e, this.hasSeed = n } call(t, e) { return e.subscribe(new hl(t, this.accumulator, this.seed, this.hasSeed)) } } class hl extends m { constructor(t, e, n, r) { super(t), this.accumulator = e, this._seed = n, this.hasSeed = r, this.index = 0 } get seed() { return this._seed } set seed(t) { this.hasSeed = !0, this._seed = t } _next(t) { if (this.hasSeed) return this._tryNext(t); this.seed = t, this.destination.next(t) } _tryNext(t) { const e = this.index++; let n; try { n = this.accumulator(this.seed, t, e) } catch (r) { this.destination.error(r) } this.seed = n, this.destination.next(n) } } function ul(t, e) { return Q(t, e, 1) } class dl { constructor(t) { this.callback = t } call(t, e) { return e.subscribe(new pl(t, this.callback)) } } class pl extends m { constructor(t, e) { super(t), this.add(new d(e)) } } let fl = null; function ml() { return fl } const gl = { class: "className", innerHtml: "innerHTML", readonly: "readOnly", tabindex: "tabIndex" }, yl = { "\b": "Backspace", "\t": "Tab", "\x7f": "Delete", "\x1b": "Escape", Del: "Delete", Esc: "Escape", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Down: "ArrowDown", Menu: "ContextMenu", Scroll: "ScrollLock", Win: "OS" }, _l = { A: "1", B: "2", C: "3", D: "4", E: "5", F: "6", G: "7", H: "8", I: "9", J: "*", K: "+", M: "-", N: ".", O: "/", "`": "0", "\x90": "NumLock" }, vl = (() => { if (xt.Node) return xt.Node.prototype.contains || function (t) { return !!(16 & this.compareDocumentPosition(t)) } })(); class bl extends class extends class { constructor() { this.resourceLoaderType = null } get attrToPropMap() { return this._attrToPropMap } set attrToPropMap(t) { this._attrToPropMap = t } }{ constructor() { super(), this._animationPrefix = null, this._transitionEnd = null; try { const t = this.createElement("div", document); if (null != this.getStyle(t, "animationName")) this._animationPrefix = ""; else { const e = ["Webkit", "Moz", "O", "ms"]; for (let n = 0; n < e.length; n++)if (null != this.getStyle(t, e[n] + "AnimationName")) { this._animationPrefix = "-" + e[n].toLowerCase() + "-"; break } } const e = { WebkitTransition: "webkitTransitionEnd", MozTransition: "transitionend", OTransition: "oTransitionEnd otransitionend", transition: "transitionend" }; Object.keys(e).forEach(n => { null != this.getStyle(t, n) && (this._transitionEnd = e[n]) }) } catch (t) { this._animationPrefix = null, this._transitionEnd = null } } getDistributedNodes(t) { return t.getDistributedNodes() } resolveAndSetHref(t, e, n) { t.href = null == n ? e : e + "/../" + n } supportsDOMEvents() { return !0 } supportsNativeShadowDOM() { return "function" == typeof document.body.createShadowRoot } getAnimationPrefix() { return this._animationPrefix ? this._animationPrefix : "" } getTransitionEnd() { return this._transitionEnd ? this._transitionEnd : "" } supportsAnimation() { return null != this._animationPrefix && null != this._transitionEnd } }{ parse(t) { throw new Error("parse not implemented") } static makeCurrent() { var t; t = new bl, fl || (fl = t) } hasProperty(t, e) { return e in t } setProperty(t, e, n) { t[e] = n } getProperty(t, e) { return t[e] } invoke(t, e, n) { t[e](...n) } logError(t) { window.console && (console.error ? console.error(t) : console.log(t)) } log(t) { window.console && window.console.log && window.console.log(t) } logGroup(t) { window.console && window.console.group && window.console.group(t) } logGroupEnd() { window.console && window.console.groupEnd && window.console.groupEnd() } get attrToPropMap() { return gl } contains(t, e) { return vl.call(t, e) } querySelector(t, e) { return t.querySelector(e) } querySelectorAll(t, e) { return t.querySelectorAll(e) } on(t, e, n) { t.addEventListener(e, n, !1) } onAndCancel(t, e, n) { return t.addEventListener(e, n, !1), () => { t.removeEventListener(e, n, !1) } } dispatchEvent(t, e) { t.dispatchEvent(e) } createMouseEvent(t) { const e = this.getDefaultDocument().createEvent("MouseEvent"); return e.initEvent(t, !0, !0), e } createEvent(t) { const e = this.getDefaultDocument().createEvent("Event"); return e.initEvent(t, !0, !0), e } preventDefault(t) { t.preventDefault(), t.returnValue = !1 } isPrevented(t) { return t.defaultPrevented || null != t.returnValue && !t.returnValue } getInnerHTML(t) { return t.innerHTML } getTemplateContent(t) { return "content" in t && this.isTemplateElement(t) ? t.content : null } getOuterHTML(t) { return t.outerHTML } nodeName(t) { return t.nodeName } nodeValue(t) { return t.nodeValue } type(t) { return t.type } content(t) { return this.hasProperty(t, "content") ? t.content : t } firstChild(t) { return t.firstChild } nextSibling(t) { return t.nextSibling } parentElement(t) { return t.parentNode } childNodes(t) { return t.childNodes } childNodesAsList(t) { const e = t.childNodes, n = new Array(e.length); for (let r = 0; r < e.length; r++)n[r] = e[r]; return n } clearNodes(t) { for (; t.firstChild;)t.removeChild(t.firstChild) } appendChild(t, e) { t.appendChild(e) } removeChild(t, e) { t.removeChild(e) } replaceChild(t, e, n) { t.replaceChild(e, n) } remove(t) { return t.parentNode && t.parentNode.removeChild(t), t } insertBefore(t, e, n) { t.insertBefore(n, e) } insertAllBefore(t, e, n) { n.forEach(n => t.insertBefore(n, e)) } insertAfter(t, e, n) { t.insertBefore(n, e.nextSibling) } setInnerHTML(t, e) { t.innerHTML = e } getText(t) { return t.textContent } setText(t, e) { t.textContent = e } getValue(t) { return t.value } setValue(t, e) { t.value = e } getChecked(t) { return t.checked } setChecked(t, e) { t.checked = e } createComment(t) { return this.getDefaultDocument().createComment(t) } createTemplate(t) { const e = this.getDefaultDocument().createElement("template"); return e.innerHTML = t, e } createElement(t, e) { return (e = e || this.getDefaultDocument()).createElement(t) } createElementNS(t, e, n) { return (n = n || this.getDefaultDocument()).createElementNS(t, e) } createTextNode(t, e) { return (e = e || this.getDefaultDocument()).createTextNode(t) } createScriptTag(t, e, n) { const r = (n = n || this.getDefaultDocument()).createElement("SCRIPT"); return r.setAttribute(t, e), r } createStyleElement(t, e) { const n = (e = e || this.getDefaultDocument()).createElement("style"); return this.appendChild(n, this.createTextNode(t, e)), n } createShadowRoot(t) { return t.createShadowRoot() } getShadowRoot(t) { return t.shadowRoot } getHost(t) { return t.host } clone(t) { return t.cloneNode(!0) } getElementsByClassName(t, e) { return t.getElementsByClassName(e) } getElementsByTagName(t, e) { return t.getElementsByTagName(e) } classList(t) { return Array.prototype.slice.call(t.classList, 0) } addClass(t, e) { t.classList.add(e) } removeClass(t, e) { t.classList.remove(e) } hasClass(t, e) { return t.classList.contains(e) } setStyle(t, e, n) { t.style[e] = n } removeStyle(t, e) { t.style[e] = "" } getStyle(t, e) { return t.style[e] } hasStyle(t, e, n) { const r = this.getStyle(t, e) || ""; return n ? r == n : r.length > 0 } tagName(t) { return t.tagName } attributeMap(t) { const e = new Map, n = t.attributes; for (let r = 0; r < n.length; r++) { const t = n.item(r); e.set(t.name, t.value) } return e } hasAttribute(t, e) { return t.hasAttribute(e) } hasAttributeNS(t, e, n) { return t.hasAttributeNS(e, n) } getAttribute(t, e) { return t.getAttribute(e) } getAttributeNS(t, e, n) { return t.getAttributeNS(e, n) } setAttribute(t, e, n) { t.setAttribute(e, n) } setAttributeNS(t, e, n, r) { t.setAttributeNS(e, n, r) } removeAttribute(t, e) { t.removeAttribute(e) } removeAttributeNS(t, e, n) { t.removeAttributeNS(e, n) } templateAwareRoot(t) { return this.isTemplateElement(t) ? this.content(t) : t } createHtmlDocument() { return document.implementation.createHTMLDocument("fakeTitle") } getDefaultDocument() { return document } getBoundingClientRect(t) { try { return t.getBoundingClientRect() } catch (e) { return { top: 0, bottom: 0, left: 0, right: 0, width: 0, height: 0 } } } getTitle(t) { return t.title } setTitle(t, e) { t.title = e || "" } elementMatches(t, e) { return !!this.isElementNode(t) && (t.matches && t.matches(e) || t.msMatchesSelector && t.msMatchesSelector(e) || t.webkitMatchesSelector && t.webkitMatchesSelector(e)) } isTemplateElement(t) { return this.isElementNode(t) && "TEMPLATE" === t.nodeName } isTextNode(t) { return t.nodeType === Node.TEXT_NODE } isCommentNode(t) { return t.nodeType === Node.COMMENT_NODE } isElementNode(t) { return t.nodeType === Node.ELEMENT_NODE } hasShadowRoot(t) { return null != t.shadowRoot && t instanceof HTMLElement } isShadowRoot(t) { return t instanceof DocumentFragment } importIntoDoc(t) { return document.importNode(this.templateAwareRoot(t), !0) } adoptNode(t) { return document.adoptNode(t) } getHref(t) { return t.getAttribute("href") } getEventKey(t) { let e = t.key; if (null == e) { if (e = t.keyIdentifier, null == e) return "Unidentified"; e.startsWith("U+") && (e = String.fromCharCode(parseInt(e.substring(2), 16)), 3 === t.location && _l.hasOwnProperty(e) && (e = _l[e])) } return yl[e] || e } getGlobalEventTarget(t, e) { return "window" === e ? window : "document" === e ? t : "body" === e ? t.body : null } getHistory() { return window.history } getLocation() { return window.location } getBaseHref(t) { const e = Sl || (Sl = document.querySelector("base"), Sl) ? Sl.getAttribute("href") : null; return null == e ? null : (n = e, wl || (wl = document.createElement("a")), wl.setAttribute("href", n), "/" === wl.pathname.charAt(0) ? wl.pathname : "/" + wl.pathname); var n } resetBaseElement() { Sl = null } getUserAgent() { return window.navigator.userAgent } setData(t, e, n) { this.setAttribute(t, "data-" + e, n) } getData(t, e) { return this.getAttribute(t, "data-" + e) } getComputedStyle(t) { return getComputedStyle(t) } supportsWebAnimation() { return "function" == typeof Element.prototype.animate } performanceNow() { return window.performance && window.performance.now ? window.performance.now() : (new Date).getTime() } supportsCookies() { return !0 } getCookie(t) { return ha(document.cookie, t) } setCookie(t, e) { document.cookie = encodeURIComponent(t) + "=" + encodeURIComponent(e) } } let wl, Sl = null; function El() { return !!window.history.pushState } const Cl = new Tt("TRANSITION_ID"), xl = [{ provide: bs, useFactory: function (t, e, n) { return () => { n.get(ws).donePromise.then(() => { const n = ml(); Array.prototype.slice.apply(n.querySelectorAll(e, "style[ng-transition]")).filter(e => n.getAttribute(e, "ng-transition") === t).forEach(t => n.remove(t)) }) } }, deps: [Cl, ma, ke], multi: !0 }]; class Tl { static init() { var t; t = new Tl, ei = t } addToWindow(t) { xt.getAngularTestability = (e, n = !0) => { const r = t.findTestabilityInTree(e, n); if (null == r) throw new Error("Could not find testability for element."); return r }, xt.getAllAngularTestabilities = () => t.getAllTestabilities(), xt.getAllAngularRootElements = () => t.getAllRootElements(), xt.frameworkStabilizers || (xt.frameworkStabilizers = []), xt.frameworkStabilizers.push(t => { const e = xt.getAllAngularTestabilities(); let n = e.length, r = !1; const s = function (e) { r = r || e, n--, 0 == n && t(r) }; e.forEach((function (t) { t.whenStable(s) })) }) } findTestabilityInTree(t, e, n) { if (null == e) return null; const r = t.getTestability(e); return null != r ? r : n ? ml().isShadowRoot(e) ? this.findTestabilityInTree(t, ml().getHost(e), !0) : this.findTestabilityInTree(t, ml().parentElement(e), !0) : null } } function kl(t, e) { "undefined" != typeof COMPILED && COMPILED || ((xt.ng = xt.ng || {})[t] = e) } const Al = { ApplicationRef: li, NgZone: Ws }; function Rl(t) { return vi(t) } const Pl = new Tt("EventManagerPlugins"); class Il { constructor(t, e) { this._zone = e, this._eventNameToPlugin = new Map, t.forEach(t => t.manager = this), this._plugins = t.slice().reverse() } addEventListener(t, e, n) { return this._findPluginFor(e).addEventListener(t, e, n) } addGlobalEventListener(t, e, n) { return this._findPluginFor(e).addGlobalEventListener(t, e, n) } getZone() { return this._zone } _findPluginFor(t) { const e = this._eventNameToPlugin.get(t); if (e) return e; const n = this._plugins; for (let r = 0; r < n.length; r++) { const e = n[r]; if (e.supports(t)) return this._eventNameToPlugin.set(t, e), e } throw new Error("No event manager plugin found for event ".concat(t)) } } class Ol { constructor(t) { this._doc = t } addGlobalEventListener(t, e, n) { const r = ml().getGlobalEventTarget(this._doc, t); if (!r) throw new Error("Unsupported event target ".concat(r, " for event ").concat(e)); return this.addEventListener(r, e, n) } } class Nl { constructor() { this._stylesSet = new Set } addStyles(t) { const e = new Set; t.forEach(t => { this._stylesSet.has(t) || (this._stylesSet.add(t), e.add(t)) }), this.onStylesAdded(e) } onStylesAdded(t) { } getAllStyles() { return Array.from(this._stylesSet) } } class Dl extends Nl { constructor(t) { super(), this._doc = t, this._hostNodes = new Set, this._styleNodes = new Set, this._hostNodes.add(t.head) } _addStylesToHost(t, e) { t.forEach(t => { const n = this._doc.createElement("style"); n.textContent = t, this._styleNodes.add(e.appendChild(n)) }) } addHost(t) { this._addStylesToHost(this._stylesSet, t), this._hostNodes.add(t) } removeHost(t) { this._hostNodes.delete(t) } onStylesAdded(t) { this._hostNodes.forEach(e => this._addStylesToHost(t, e)) } ngOnDestroy() { this._styleNodes.forEach(t => ml().remove(t)) } } const Fl = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/" }, Ml = /%COMP%/g; function Ll(t, e, n) { for (let r = 0; r < e.length; r++) { let s = e[r]; Array.isArray(s) ? Ll(t, s, n) : (s = s.replace(Ml, t), n.push(s)) } return n } function jl(t) { return e => { !1 === t(e) && (e.preventDefault(), e.returnValue = !1) } } class Ul { constructor(t, e, n) { this.eventManager = t, this.sharedStylesHost = e, this.appId = n, this.rendererByCompId = new Map, this.defaultRenderer = new Bl(t) } createRenderer(t, e) { if (!t || !e) return this.defaultRenderer; switch (e.encapsulation) { case Ht.Emulated: { let n = this.rendererByCompId.get(e.id); return n || (n = new zl(this.eventManager, this.sharedStylesHost, e, this.appId), this.rendererByCompId.set(e.id, n)), n.applyToHost(t), n } case Ht.Native: case Ht.ShadowDom: return new ql(this.eventManager, this.sharedStylesHost, t, e); default: if (!this.rendererByCompId.has(e.id)) { const t = Ll(e.id, e.styles, []); this.sharedStylesHost.addStyles(t), this.rendererByCompId.set(e.id, this.defaultRenderer) } return this.defaultRenderer } } begin() { } end() { } } class Bl { constructor(t) { this.eventManager = t, this.data = Object.create(null) } destroy() { } createElement(t, e) { return e ? document.createElementNS(Fl[e] || e, t) : document.createElement(t) } createComment(t) { return document.createComment(t) } createText(t) { return document.createTextNode(t) } appendChild(t, e) { t.appendChild(e) } insertBefore(t, e, n) { t && t.insertBefore(e, n) } removeChild(t, e) { t && t.removeChild(e) } selectRootElement(t, e) { let n = "string" == typeof t ? document.querySelector(t) : t; if (!n) throw new Error('The selector "'.concat(t, '" did not match any elements')); return e || (n.textContent = ""), n } parentNode(t) { return t.parentNode } nextSibling(t) { return t.nextSibling } setAttribute(t, e, n, r) { if (r) { e = r + ":" + e; const s = Fl[r]; s ? t.setAttributeNS(s, e, n) : t.setAttribute(e, n) } else t.setAttribute(e, n) } removeAttribute(t, e, n) { if (n) { const r = Fl[n]; r ? t.removeAttributeNS(r, e) : t.removeAttribute("".concat(n, ":").concat(e)) } else t.removeAttribute(e) } addClass(t, e) { t.classList.add(e) } removeClass(t, e) { t.classList.remove(e) } setStyle(t, e, n, r) { r & rn.DashCase ? t.style.setProperty(e, n, r & rn.Important ? "important" : "") : t.style[e] = n } removeStyle(t, e, n) { n & rn.DashCase ? t.style.removeProperty(e) : t.style[e] = "" } setProperty(t, e, n) { Vl(e, "property"), t[e] = n } setValue(t, e) { t.nodeValue = e } listen(t, e, n) { return Vl(e, "listener"), "string" == typeof t ? this.eventManager.addGlobalEventListener(t, e, jl(n)) : this.eventManager.addEventListener(t, e, jl(n)) } } const Hl = "@".charCodeAt(0); function Vl(t, e) { if (t.charCodeAt(0) === Hl) throw new Error("Found the synthetic ".concat(e, " ").concat(t, '. Please include either "BrowserAnimationsModule" or "NoopAnimationsModule" in your application.')) } class zl extends Bl { constructor(t, e, n, r) { super(t), this.component = n; const s = Ll(r + "-" + n.id, n.styles, []); var i; e.addStyles(s), this.contentAttr = "_ngcontent-%COMP%".replace(Ml, r + "-" + n.id), this.hostAttr = (i = r + "-" + n.id, "_nghost-%COMP%".replace(Ml, i)) } applyToHost(t) { super.setAttribute(t, this.hostAttr, "") } createElement(t, e) { const n = super.createElement(t, e); return super.setAttribute(n, this.contentAttr, ""), n } } class ql extends Bl { constructor(t, e, n, r) { super(t), this.sharedStylesHost = e, this.hostEl = n, this.component = r, this.shadowRoot = r.encapsulation === Ht.ShadowDom ? n.attachShadow({ mode: "open" }) : n.createShadowRoot(), this.sharedStylesHost.addHost(this.shadowRoot); const s = Ll(r.id, r.styles, []); for (let i = 0; i < s.length; i++) { const t = document.createElement("style"); t.textContent = s[i], this.shadowRoot.appendChild(t) } } nodeOrShadowRoot(t) { return t === this.hostEl ? this.shadowRoot : t } destroy() { this.sharedStylesHost.removeHost(this.shadowRoot) } appendChild(t, e) { return super.appendChild(this.nodeOrShadowRoot(t), e) } insertBefore(t, e, n) { return super.insertBefore(this.nodeOrShadowRoot(t), e, n) } removeChild(t, e) { return super.removeChild(this.nodeOrShadowRoot(t), e) } parentNode(t) { return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t))) } } const Wl = "undefined" != typeof Zone && Zone.__symbol__ || function (t) { return "__zone_symbol__" + t }, Ql = Wl("addEventListener"), Kl = Wl("removeEventListener"), Zl = {}, Gl = "__zone_symbol__propagationStopped", Yl = (() => { const t = "undefined" != typeof Zone && Zone[Wl("BLACK_LISTED_EVENTS")]; if (t) { const e = {}; return t.forEach(t => { e[t] = t }), e } })(), Xl = function (t) { return !!Yl && Yl.hasOwnProperty(t) }, $l = function (t) { const e = Zl[t.type]; if (!e) return; const n = this[e]; if (!n) return; const r = [t]; if (1 === n.length) { const t = n[0]; return t.zone !== Zone.current ? t.zone.run(t.handler, this, r) : t.handler.apply(this, r) } { const e = n.slice(); for (let n = 0; n < e.length && !0 !== t[Gl]; n++) { const t = e[n]; t.zone !== Zone.current ? t.zone.run(t.handler, this, r) : t.handler.apply(this, r) } } }; class Jl extends Ol { constructor(t, e, n) { super(t), this.ngZone = e, n && function (t) { return "server" === t }(n) || this.patchEvent() } patchEvent() { if ("undefined" == typeof Event || !Event || !Event.prototype) return; if (Event.prototype.__zone_symbol__stopImmediatePropagation) return; const t = Event.prototype.__zone_symbol__stopImmediatePropagation = Event.prototype.stopImmediatePropagation; Event.prototype.stopImmediatePropagation = function () { this && (this[Gl] = !0), t && t.apply(this, arguments) } } supports(t) { return !0 } addEventListener(t, e, n) { let r = n; if (!t[Ql] || Ws.isInAngularZone() && !Xl(e)) t.addEventListener(e, r, !1); else { let n = Zl[e]; n || (n = Zl[e] = Wl("ANGULAR" + e + "FALSE")); let s = t[n]; const i = s && s.length > 0; s || (s = t[n] = []); const o = Xl(e) ? Zone.root : Zone.current; if (0 === s.length) s.push({ zone: o, handler: r }); else { let t = !1; for (let e = 0; e < s.length; e++)if (s[e].handler === r) { t = !0; break } t || s.push({ zone: o, handler: r }) } i || t[Ql](e, $l, !1) } return () => this.removeEventListener(t, e, r) } removeEventListener(t, e, n) { let r = t[Kl]; if (!r) return t.removeEventListener.apply(t, [e, n, !1]); let s = Zl[e], i = s && t[s]; if (!i) return t.removeEventListener.apply(t, [e, n, !1]); let o = !1; for (let a = 0; a < i.length; a++)if (i[a].handler === n) { o = !0, i.splice(a, 1); break } o ? 0 === i.length && r.apply(t, [e, $l, !1]) : t.removeEventListener.apply(t, [e, n, !1]) } } const tc = { pan: !0, panstart: !0, panmove: !0, panend: !0, pancancel: !0, panleft: !0, panright: !0, panup: !0, pandown: !0, pinch: !0, pinchstart: !0, pinchmove: !0, pinchend: !0, pinchcancel: !0, pinchin: !0, pinchout: !0, press: !0, pressup: !0, rotate: !0, rotatestart: !0, rotatemove: !0, rotateend: !0, rotatecancel: !0, swipe: !0, swipeleft: !0, swiperight: !0, swipeup: !0, swipedown: !0, tap: !0 }, ec = new Tt("HammerGestureConfig"), nc = new Tt("HammerLoader"); class rc { constructor() { this.events = [], this.overrides = {} } buildHammer(t) { const e = new Hammer(t, this.options); e.get("pinch").set({ enable: !0 }), e.get("rotate").set({ enable: !0 }); for (const n in this.overrides) e.get(n).set(this.overrides[n]); return e } } class sc extends Ol { constructor(t, e, n, r) { super(t), this._config = e, this.console = n, this.loader = r } supports(t) { return !(!tc.hasOwnProperty(t.toLowerCase()) && !this.isCustomEvent(t) || !window.Hammer && !this.loader && (this.console.warn('The "'.concat(t, '" event cannot be bound because Hammer.JS is not ') + "loaded and no custom loader has been specified."), 1)) } addEventListener(t, e, n) { const r = this.manager.getZone(); if (e = e.toLowerCase(), !window.Hammer && this.loader) { let r = !1, s = () => { r = !0 }; return this.loader().then(() => { if (!window.Hammer) return this.console.warn("The custom HAMMER_LOADER completed, but Hammer.JS is not present."), void (s = () => { }); r || (s = this.addEventListener(t, e, n)) }).catch(() => { this.console.warn('The "'.concat(e, '" event cannot be bound because the custom ') + "Hammer.JS loader failed."), s = () => { } }), () => { s() } } return r.runOutsideAngular(() => { const s = this._config.buildHammer(t), i = function (t) { r.runGuarded((function () { n(t) })) }; return s.on(e, i), () => { s.off(e, i), "function" == typeof s.destroy && s.destroy() } }) } isCustomEvent(t) { return this._config.events.indexOf(t) > -1 } } const ic = ["alt", "control", "meta", "shift"], oc = { alt: t => t.altKey, control: t => t.ctrlKey, meta: t => t.metaKey, shift: t => t.shiftKey }; class ac extends Ol { constructor(t) { super(t) } supports(t) { return null != ac.parseEventName(t) } addEventListener(t, e, n) { const r = ac.parseEventName(e), s = ac.eventCallback(r.fullKey, n, this.manager.getZone()); return this.manager.getZone().runOutsideAngular(() => ml().onAndCancel(t, r.domEventName, s)) } static parseEventName(t) { const e = t.toLowerCase().split("."), n = e.shift(); if (0 === e.length || "keydown" !== n && "keyup" !== n) return null; const r = ac._normalizeKey(e.pop()); let s = ""; if (ic.forEach(t => { const n = e.indexOf(t); n > -1 && (e.splice(n, 1), s += t + ".") }), s += r, 0 != e.length || 0 === r.length) return null; const i = {}; return i.domEventName = n, i.fullKey = s, i } static getEventFullKey(t) { let e = "", n = ml().getEventKey(t); return n = n.toLowerCase(), " " === n ? n = "space" : "." === n && (n = "dot"), ic.forEach(r => { r != n && (0, oc[r])(t) && (e += r + ".") }), e += n, e } static eventCallback(t, e, n) { return r => { ac.getEventFullKey(r) === t && n.runGuarded(() => e(r)) } } static _normalizeKey(t) { switch (t) { case "esc": return "escape"; default: return t } } } class lc { } class cc extends lc { constructor(t) { super(), this._doc = t } sanitize(t, e) { if (null == e) return null; switch (t) { case ye.NONE: return e; case ye.HTML: return e instanceof uc ? e.changingThisBreaksApplicationSecurity : (this.checkNotSafeValue(e, "HTML"), function (t, e) { let n = null; try { me = me || new Yt(t); let r = e ? String(e) : ""; n = me.getInertBodyElement(r); let s = 5, i = r; do { if (0 === s) throw new Error("Failed to sanitize html because the input is unstable"); s--, r = i, i = n.innerHTML, n = me.getInertBodyElement(r) } while (r !== i); const o = new ue, a = o.sanitizeChildren(ge(n) || n); return Gt() && o.sanitizedSomething && console.warn("WARNING: sanitizing HTML stripped some content, see http://g.co/ng/security#xss"), a } finally { if (n) { const t = ge(n) || n; for (; t.firstChild;)t.removeChild(t.firstChild) } } }(this._doc, String(e))); case ye.STYLE: return e instanceof dc ? e.changingThisBreaksApplicationSecurity : (this.checkNotSafeValue(e, "Style"), function (t) { if (!(t = String(t).trim())) return ""; const e = t.match(be); return e && Jt(e[1]) === e[1] || t.match(ve) && function (t) { let e = !0, n = !0; for (let r = 0; r < t.length; r++) { const s = t.charAt(r); "'" === s && n ? e = !e : '"' === s && e && (n = !n) } return e && n }(t) ? t : (Gt() && console.warn("WARNING: sanitizing unsafe style value ".concat(t, " (see http://g.co/ng/security#xss).")), "unsafe") }(e)); case ye.SCRIPT: if (e instanceof pc) return e.changingThisBreaksApplicationSecurity; throw this.checkNotSafeValue(e, "Script"), new Error("unsafe value used in a script context"); case ye.URL: return e instanceof mc || e instanceof fc ? e.changingThisBreaksApplicationSecurity : (this.checkNotSafeValue(e, "URL"), Jt(String(e))); case ye.RESOURCE_URL: if (e instanceof mc) return e.changingThisBreaksApplicationSecurity; throw this.checkNotSafeValue(e, "ResourceURL"), new Error("unsafe value used in a resource URL context (see http://g.co/ng/security#xss)"); default: throw new Error("Unexpected SecurityContext ".concat(t, " (see http://g.co/ng/security#xss)")) } } checkNotSafeValue(t, e) { if (t instanceof hc) throw new Error("Required a safe ".concat(e, ", got a ").concat(t.getTypeName(), " ") + "(see http://g.co/ng/security#xss)") } bypassSecurityTrustHtml(t) { return new uc(t) } bypassSecurityTrustStyle(t) { return new dc(t) } bypassSecurityTrustScript(t) { return new pc(t) } bypassSecurityTrustUrl(t) { return new fc(t) } bypassSecurityTrustResourceUrl(t) { return new mc(t) } } class hc { constructor(t) { this.changingThisBreaksApplicationSecurity = t } toString() { return "SafeValue must use [property]=binding: ".concat(this.changingThisBreaksApplicationSecurity) + " (see http://g.co/ng/security#xss)" } } class uc extends hc { getTypeName() { return "HTML" } } class dc extends hc { getTypeName() { return "Style" } } class pc extends hc { getTypeName() { return "Script" } } class fc extends hc { getTypeName() { return "URL" } } class mc extends hc { getTypeName() { return "ResourceURL" } } const gc = si(wi, "browser", [{ provide: Ts, useValue: "browser" }, { provide: xs, useValue: function () { bl.makeCurrent(), Tl.init() }, multi: !0 }, { provide: $o, useClass: class extends $o { constructor(t) { super(), this._doc = t, this._init() } _init() { this.location = ml().getLocation(), this._history = ml().getHistory() } getBaseHrefFromDOM() { return ml().getBaseHref(this._doc) } onPopState(t) { ml().getGlobalEventTarget(this._doc, "window").addEventListener("popstate", t, !1) } onHashChange(t) { ml().getGlobalEventTarget(this._doc, "window").addEventListener("hashchange", t, !1) } get href() { return this.location.href } get protocol() { return this.location.protocol } get hostname() { return this.location.hostname } get port() { return this.location.port } get pathname() { return this.location.pathname } get search() { return this.location.search } get hash() { return this.location.hash } set pathname(t) { this.location.pathname = t } pushState(t, e, n) { El() ? this._history.pushState(t, e, n) : this.location.hash = n } replaceState(t, e, n) { El() ? this._history.replaceState(t, e, n) : this.location.hash = n } forward() { this._history.forward() } back() { this._history.back() } getState() { return this._history.state } }, deps: [ma] }, { provide: ma, useFactory: function () { return document }, deps: [] }]); function yc() { return new Qt } class _c { constructor(t) { if (t) throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.") } static withServerTransition(t) { return { ngModule: _c, providers: [{ provide: Ss, useValue: t.appId }, { provide: Cl, useExisting: Ss }, xl] } } } "undefined" != typeof window && window; class vc { constructor(t, e) { this.id = t, this.url = e } } class bc extends vc { constructor(t, e, n = "imperative", r = null) { super(t, e), this.navigationTrigger = n, this.restoredState = r } toString() { return "NavigationStart(id: ".concat(this.id, ", url: '").concat(this.url, "')") } } class wc extends vc { constructor(t, e, n) { super(t, e), this.urlAfterRedirects = n } toString() { return "NavigationEnd(id: ".concat(this.id, ", url: '").concat(this.url, "', urlAfterRedirects: '").concat(this.urlAfterRedirects, "')") } } class Sc extends vc { constructor(t, e, n) { super(t, e), this.reason = n } toString() { return "NavigationCancel(id: ".concat(this.id, ", url: '").concat(this.url, "')") } } class Ec extends vc { constructor(t, e, n) { super(t, e), this.error = n } toString() { return "NavigationError(id: ".concat(this.id, ", url: '").concat(this.url, "', error: ").concat(this.error, ")") } } class Cc extends vc { constructor(t, e, n, r) { super(t, e), this.urlAfterRedirects = n, this.state = r } toString() { return "RoutesRecognized(id: ".concat(this.id, ", url: '").concat(this.url, "', urlAfterRedirects: '").concat(this.urlAfterRedirects, "', state: ").concat(this.state, ")") } } class xc extends vc { constructor(t, e, n, r) { super(t, e), this.urlAfterRedirects = n, this.state = r } toString() { return "GuardsCheckStart(id: ".concat(this.id, ", url: '").concat(this.url, "', urlAfterRedirects: '").concat(this.urlAfterRedirects, "', state: ").concat(this.state, ")") } } class Tc extends vc { constructor(t, e, n, r, s) { super(t, e), this.urlAfterRedirects = n, this.state = r, this.shouldActivate = s } toString() { return "GuardsCheckEnd(id: ".concat(this.id, ", url: '").concat(this.url, "', urlAfterRedirects: '").concat(this.urlAfterRedirects, "', state: ").concat(this.state, ", shouldActivate: ").concat(this.shouldActivate, ")") } } class kc extends vc { constructor(t, e, n, r) { super(t, e), this.urlAfterRedirects = n, this.state = r } toString() { return "ResolveStart(id: ".concat(this.id, ", url: '").concat(this.url, "', urlAfterRedirects: '").concat(this.urlAfterRedirects, "', state: ").concat(this.state, ")") } } class Ac extends vc { constructor(t, e, n, r) { super(t, e), this.urlAfterRedirects = n, this.state = r } toString() { return "ResolveEnd(id: ".concat(this.id, ", url: '").concat(this.url, "', urlAfterRedirects: '").concat(this.urlAfterRedirects, "', state: ").concat(this.state, ")") } } class Rc { constructor(t) { this.route = t } toString() { return "RouteConfigLoadStart(path: ".concat(this.route.path, ")") } } class Pc { constructor(t) { this.route = t } toString() { return "RouteConfigLoadEnd(path: ".concat(this.route.path, ")") } } class Ic { constructor(t) { this.snapshot = t } toString() { return "ChildActivationStart(path: '".concat(this.snapshot.routeConfig && this.snapshot.routeConfig.path || "", "')") } } class Oc { constructor(t) { this.snapshot = t } toString() { return "ChildActivationEnd(path: '".concat(this.snapshot.routeConfig && this.snapshot.routeConfig.path || "", "')") } } class Nc { constructor(t) { this.snapshot = t } toString() { return "ActivationStart(path: '".concat(this.snapshot.routeConfig && this.snapshot.routeConfig.path || "", "')") } } class Dc { constructor(t) { this.snapshot = t } toString() { return "ActivationEnd(path: '".concat(this.snapshot.routeConfig && this.snapshot.routeConfig.path || "", "')") } } class Fc { constructor(t, e, n) { this.routerEvent = t, this.position = e, this.anchor = n } toString() { return "Scroll(anchor: '".concat(this.anchor, "', position: '").concat(this.position ? "".concat(this.position[0], ", ").concat(this.position[1]) : null, "')") } } class Mc { } class Lc { constructor(t) { this.params = t || {} } has(t) { return this.params.hasOwnProperty(t) } get(t) { if (this.has(t)) { const e = this.params[t]; return Array.isArray(e) ? e[0] : e } return null } getAll(t) { if (this.has(t)) { const e = this.params[t]; return Array.isArray(e) ? e : [e] } return [] } get keys() { return Object.keys(this.params) } } function jc(t) { return new Lc(t) } function Uc(t) { const e = Error("NavigationCancelingError: " + t); return e.ngNavigationCancelingError = !0, e } function Bc(t, e, n) { const r = n.path.split("/"); if (r.length > t.length) return null; if ("full" === n.pathMatch && (e.hasChildren() || r.length < t.length)) return null; const s = {}; for (let i = 0; i < r.length; i++) { const e = r[i], n = t[i]; if (e.startsWith(":")) s[e.substring(1)] = n; else if (e !== n.path) return null } return { consumed: t.slice(0, r.length), posParams: s } } class Hc { constructor(t, e) { this.routes = t, this.module = e } } function Vc(t, e = "") { for (let n = 0; n < t.length; n++) { const r = t[n]; zc(r, qc(e, r)) } } function zc(t, e) { if (!t) throw new Error("\n      Invalid configuration of route '".concat(e, "': Encountered undefined route.\n      The reason might be an extra comma.\n\n      Example:\n      const routes: Routes = [\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\n        { path: 'detail/:id', component: HeroDetailComponent }\n      ];\n    ")); if (Array.isArray(t)) throw new Error("Invalid configuration of route '".concat(e, "': Array cannot be specified")); if (!t.component && !t.children && !t.loadChildren && t.outlet && "primary" !== t.outlet) throw new Error("Invalid configuration of route '".concat(e, "': a componentless route without children or loadChildren cannot have a named outlet set")); if (t.redirectTo && t.children) throw new Error("Invalid configuration of route '".concat(e, "': redirectTo and children cannot be used together")); if (t.redirectTo && t.loadChildren) throw new Error("Invalid configuration of route '".concat(e, "': redirectTo and loadChildren cannot be used together")); if (t.children && t.loadChildren) throw new Error("Invalid configuration of route '".concat(e, "': children and loadChildren cannot be used together")); if (t.redirectTo && t.component) throw new Error("Invalid configuration of route '".concat(e, "': redirectTo and component cannot be used together")); if (t.path && t.matcher) throw new Error("Invalid configuration of route '".concat(e, "': path and matcher cannot be used together")); if (void 0 === t.redirectTo && !t.component && !t.children && !t.loadChildren) throw new Error("Invalid configuration of route '".concat(e, "'. One of the following must be provided: component, redirectTo, children or loadChildren")); if (void 0 === t.path && void 0 === t.matcher) throw new Error("Invalid configuration of route '".concat(e, "': routes must have either a path or a matcher specified")); if ("string" == typeof t.path && "/" === t.path.charAt(0)) throw new Error("Invalid configuration of route '".concat(e, "': path cannot start with a slash")); if ("" === t.path && void 0 !== t.redirectTo && void 0 === t.pathMatch) throw new Error("Invalid configuration of route '{path: \"".concat(e, '", redirectTo: "').concat(t.redirectTo, "\"}': please provide 'pathMatch'. The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.")); if (void 0 !== t.pathMatch && "full" !== t.pathMatch && "prefix" !== t.pathMatch) throw new Error("Invalid configuration of route '".concat(e, "': pathMatch can only be set to 'prefix' or 'full'")); t.children && Vc(t.children, e) } function qc(t, e) { return e ? t || e.path ? t && !e.path ? "".concat(t, "/") : !t && e.path ? e.path : "".concat(t, "/").concat(e.path) : "" : t } function Wc(t) { const e = t.children && t.children.map(Wc), n = e ? Object.assign({}, t, { children: e }) : Object.assign({}, t); return !n.component && (e || n.loadChildren) && n.outlet && "primary" !== n.outlet && (n.component = Mc), n } function Qc(t, e) { const n = Object.keys(t), r = Object.keys(e); if (!n || !r || n.length != r.length) return !1; let s; for (let i = 0; i < n.length; i++)if (s = n[i], t[s] !== e[s]) return !1; return !0 } function Kc(t) { return Array.prototype.concat.apply([], t) } function Zc(t) { return t.length > 0 ? t[t.length - 1] : null } function Gc(t, e) { for (const n in t) t.hasOwnProperty(n) && e(t[n], n) } function Yc(t) { return qe(t) ? t : ze(t) ? W(Promise.resolve(t)) : Sa(t) } function Xc(t, e, n) { return n ? function (t, e) { return Qc(t, e) }(t.queryParams, e.queryParams) && function t(e, n) { if (!eh(e.segments, n.segments)) return !1; if (e.numberOfChildren !== n.numberOfChildren) return !1; for (const r in n.children) { if (!e.children[r]) return !1; if (!t(e.children[r], n.children[r])) return !1 } return !0 }(t.root, e.root) : function (t, e) { return Object.keys(e).length <= Object.keys(t).length && Object.keys(e).every(n => e[n] === t[n]) }(t.queryParams, e.queryParams) && function t(e, n) { return function e(n, r, s) { if (n.segments.length > s.length) return !!eh(n.segments.slice(0, s.length), s) && !r.hasChildren(); if (n.segments.length === s.length) { if (!eh(n.segments, s)) return !1; for (const e in r.children) { if (!n.children[e]) return !1; if (!t(n.children[e], r.children[e])) return !1 } return !0 } { const t = s.slice(0, n.segments.length), i = s.slice(n.segments.length); return !!eh(n.segments, t) && !!n.children.primary && e(n.children.primary, r, i) } }(e, n, n.segments) }(t.root, e.root) } class $c { constructor(t, e, n) { this.root = t, this.queryParams = e, this.fragment = n } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = jc(this.queryParams)), this._queryParamMap } toString() { return ih.serialize(this) } } class Jc { constructor(t, e) { this.segments = t, this.children = e, this.parent = null, Gc(e, (t, e) => t.parent = this) } hasChildren() { return this.numberOfChildren > 0 } get numberOfChildren() { return Object.keys(this.children).length } toString() { return oh(this) } } class th { constructor(t, e) { this.path = t, this.parameters = e } get parameterMap() { return this._parameterMap || (this._parameterMap = jc(this.parameters)), this._parameterMap } toString() { return dh(this) } } function eh(t, e) { return t.length === e.length && t.every((t, n) => t.path === e[n].path) } function nh(t, e) { let n = []; return Gc(t.children, (t, r) => { "primary" === r && (n = n.concat(e(t, r))) }), Gc(t.children, (t, r) => { "primary" !== r && (n = n.concat(e(t, r))) }), n } class rh { } class sh { parse(t) { const e = new yh(t); return new $c(e.parseRootSegment(), e.parseQueryParams(), e.parseFragment()) } serialize(t) { var e; return "".concat("/".concat(function t(e, n) { if (!e.hasChildren()) return oh(e); if (n) { const n = e.children.primary ? t(e.children.primary, !1) : "", r = []; return Gc(e.children, (e, n) => { "primary" !== n && r.push("".concat(n, ":").concat(t(e, !1))) }), r.length > 0 ? "".concat(n, "(").concat(r.join("//"), ")") : n } { const n = nh(e, (n, r) => "primary" === r ? [t(e.children.primary, !1)] : ["".concat(r, ":").concat(t(n, !1))]); return "".concat(oh(e), "/(").concat(n.join("//"), ")") } }(t.root, !0)), function (t) { const e = Object.keys(t).map(e => { const n = t[e]; return Array.isArray(n) ? n.map(t => "".concat(lh(e), "=").concat(lh(t))).join("&") : "".concat(lh(e), "=").concat(lh(n)) }); return e.length ? "?".concat(e.join("&")) : "" }(t.queryParams)).concat("string" == typeof t.fragment ? "#".concat((e = t.fragment, encodeURI(e))) : "") } } const ih = new sh; function oh(t) { return t.segments.map(t => dh(t)).join("/") } function ah(t) { return encodeURIComponent(t).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",") } function lh(t) { return ah(t).replace(/%3B/gi, ";") } function ch(t) { return ah(t).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&") } function hh(t) { return decodeURIComponent(t) } function uh(t) { return hh(t.replace(/\+/g, "%20")) } function dh(t) { return "".concat(ch(t.path)).concat((e = t.parameters, Object.keys(e).map(t => ";".concat(ch(t), "=").concat(ch(e[t]))).join(""))); var e } const ph = /^[^\/()?;=#]+/; function fh(t) { const e = t.match(ph); return e ? e[0] : "" } const mh = /^[^=?&#]+/, gh = /^[^?&#]+/; class yh { constructor(t) { this.url = t, this.remaining = t } parseRootSegment() { return this.consumeOptional("/"), "" === this.remaining || this.peekStartsWith("?") || this.peekStartsWith("#") ? new Jc([], {}) : new Jc([], this.parseChildren()) } parseQueryParams() { const t = {}; if (this.consumeOptional("?")) do { this.parseQueryParam(t) } while (this.consumeOptional("&")); return t } parseFragment() { return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null } parseChildren() { if ("" === this.remaining) return {}; this.consumeOptional("/"); const t = []; for (this.peekStartsWith("(") || t.push(this.parseSegment()); this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(");)this.capture("/"), t.push(this.parseSegment()); let e = {}; this.peekStartsWith("/(") && (this.capture("/"), e = this.parseParens(!0)); let n = {}; return this.peekStartsWith("(") && (n = this.parseParens(!1)), (t.length > 0 || Object.keys(e).length > 0) && (n.primary = new Jc(t, e)), n } parseSegment() { const t = fh(this.remaining); if ("" === t && this.peekStartsWith(";")) throw new Error("Empty path url segment cannot have parameters: '".concat(this.remaining, "'.")); return this.capture(t), new th(hh(t), this.parseMatrixParams()) } parseMatrixParams() { const t = {}; for (; this.consumeOptional(";");)this.parseParam(t); return t } parseParam(t) { const e = fh(this.remaining); if (!e) return; this.capture(e); let n = ""; if (this.consumeOptional("=")) { const t = fh(this.remaining); t && (n = t, this.capture(n)) } t[hh(e)] = hh(n) } parseQueryParam(t) { const e = function (t) { const e = t.match(mh); return e ? e[0] : "" }(this.remaining); if (!e) return; this.capture(e); let n = ""; if (this.consumeOptional("=")) { const t = function (t) { const e = t.match(gh); return e ? e[0] : "" }(this.remaining); t && (n = t, this.capture(n)) } const r = uh(e), s = uh(n); if (t.hasOwnProperty(r)) { let e = t[r]; Array.isArray(e) || (e = [e], t[r] = e), e.push(s) } else t[r] = s } parseParens(t) { const e = {}; for (this.capture("("); !this.consumeOptional(")") && this.remaining.length > 0;) { const n = fh(this.remaining), r = this.remaining[n.length]; if ("/" !== r && ")" !== r && ";" !== r) throw new Error("Cannot parse url '".concat(this.url, "'")); let s = void 0; n.indexOf(":") > -1 ? (s = n.substr(0, n.indexOf(":")), this.capture(s), this.capture(":")) : t && (s = "primary"); const i = this.parseChildren(); e[s] = 1 === Object.keys(i).length ? i.primary : new Jc([], i), this.consumeOptional("//") } return e } peekStartsWith(t) { return this.remaining.startsWith(t) } consumeOptional(t) { return !!this.peekStartsWith(t) && (this.remaining = this.remaining.substring(t.length), !0) } capture(t) { if (!this.consumeOptional(t)) throw new Error('Expected "'.concat(t, '".')) } } class _h { constructor(t) { this._root = t } get root() { return this._root.value } parent(t) { const e = this.pathFromRoot(t); return e.length > 1 ? e[e.length - 2] : null } children(t) { const e = vh(t, this._root); return e ? e.children.map(t => t.value) : [] } firstChild(t) { const e = vh(t, this._root); return e && e.children.length > 0 ? e.children[0].value : null } siblings(t) { const e = bh(t, this._root); return e.length < 2 ? [] : e[e.length - 2].children.map(t => t.value).filter(e => e !== t) } pathFromRoot(t) { return bh(t, this._root).map(t => t.value) } } function vh(t, e) { if (t === e.value) return e; for (const n of e.children) { const e = vh(t, n); if (e) return e } return null } function bh(t, e) { if (t === e.value) return [e]; for (const n of e.children) { const r = bh(t, n); if (r.length) return r.unshift(e), r } return [] } class wh { constructor(t, e) { this.value = t, this.children = e } toString() { return "TreeNode(".concat(this.value, ")") } } function Sh(t) { const e = {}; return t && t.children.forEach(t => e[t.value.outlet] = t), e } class Eh extends _h { constructor(t, e) { super(t), this.snapshot = e, Rh(this, t) } toString() { return this.snapshot.toString() } } function Ch(t, e) { const n = function (t, e) { const n = new kh([], {}, {}, "", {}, "primary", e, null, t.root, -1, {}); return new Ah("", new wh(n, [])) }(t, e), r = new Ea([new th("", {})]), s = new Ea({}), i = new Ea({}), o = new Ea({}), a = new Ea(""), l = new xh(r, s, o, a, i, "primary", e, n.root); return l.snapshot = n.root, new Eh(new wh(l, []), n) } class xh { constructor(t, e, n, r, s, i, o, a) { this.url = t, this.params = e, this.queryParams = n, this.fragment = r, this.data = s, this.outlet = i, this.component = o, this._futureSnapshot = a } get routeConfig() { return this._futureSnapshot.routeConfig } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = this.params.pipe(H(t => jc(t)))), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = this.queryParams.pipe(H(t => jc(t)))), this._queryParamMap } toString() { return this.snapshot ? this.snapshot.toString() : "Future(".concat(this._futureSnapshot, ")") } } function Th(t, e = "emptyOnly") { const n = t.pathFromRoot; let r = 0; if ("always" !== e) for (r = n.length - 1; r >= 1;) { const t = n[r], e = n[r - 1]; if (t.routeConfig && "" === t.routeConfig.path) r--; else { if (e.component) break; r-- } } return function (t) { return t.reduce((t, e) => ({ params: Object.assign({}, t.params, e.params), data: Object.assign({}, t.data, e.data), resolve: Object.assign({}, t.resolve, e._resolvedData) }), { params: {}, data: {}, resolve: {} }) }(n.slice(r)) } class kh { constructor(t, e, n, r, s, i, o, a, l, c, h) { this.url = t, this.params = e, this.queryParams = n, this.fragment = r, this.data = s, this.outlet = i, this.component = o, this.routeConfig = a, this._urlSegment = l, this._lastPathIndex = c, this._resolve = h } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = jc(this.params)), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = jc(this.queryParams)), this._queryParamMap } toString() { return "Route(url:'".concat(this.url.map(t => t.toString()).join("/"), "', path:'").concat(this.routeConfig ? this.routeConfig.path : "", "')") } } class Ah extends _h { constructor(t, e) { super(e), this.url = t, Rh(this, e) } toString() { return Ph(this._root) } } function Rh(t, e) { e.value._routerState = t, e.children.forEach(e => Rh(t, e)) } function Ph(t) { const e = t.children.length > 0 ? " { ".concat(t.children.map(Ph).join(", "), " } ") : ""; return "".concat(t.value).concat(e) } function Ih(t) { if (t.snapshot) { const e = t.snapshot, n = t._futureSnapshot; t.snapshot = n, Qc(e.queryParams, n.queryParams) || t.queryParams.next(n.queryParams), e.fragment !== n.fragment && t.fragment.next(n.fragment), Qc(e.params, n.params) || t.params.next(n.params), function (t, e) { if (t.length !== e.length) return !1; for (let n = 0; n < t.length; ++n)if (!Qc(t[n], e[n])) return !1; return !0 }(e.url, n.url) || t.url.next(n.url), Qc(e.data, n.data) || t.data.next(n.data) } else t.snapshot = t._futureSnapshot, t.data.next(t._futureSnapshot.data) } function Oh(t, e) { var n, r; return Qc(t.params, e.params) && eh(n = t.url, r = e.url) && n.every((t, e) => Qc(t.parameters, r[e].parameters)) && !(!t.parent != !e.parent) && (!t.parent || Oh(t.parent, e.parent)) } function Nh(t) { return "object" == typeof t && null != t && !t.outlets && !t.segmentPath } function Dh(t, e, n, r, s) { let i = {}; return r && Gc(r, (t, e) => { i[e] = Array.isArray(t) ? t.map(t => "".concat(t)) : "".concat(t) }), new $c(n.root === t ? e : function t(e, n, r) { const s = {}; return Gc(e.children, (e, i) => { s[i] = e === n ? r : t(e, n, r) }), new Jc(e.segments, s) }(n.root, t, e), i, s) } class Fh { constructor(t, e, n) { if (this.isAbsolute = t, this.numberOfDoubleDots = e, this.commands = n, t && n.length > 0 && Nh(n[0])) throw new Error("Root segment cannot have matrix parameters"); const r = n.find(t => "object" == typeof t && null != t && t.outlets); if (r && r !== Zc(n)) throw new Error("{outlets:{}} has to be the last command") } toRoot() { return this.isAbsolute && 1 === this.commands.length && "/" == this.commands[0] } } class Mh { constructor(t, e, n) { this.segmentGroup = t, this.processChildren = e, this.index = n } } function Lh(t) { return "object" == typeof t && null != t && t.outlets ? t.outlets.primary : "".concat(t) } function jh(t, e, n) { if (t || (t = new Jc([], {})), 0 === t.segments.length && t.hasChildren()) return Uh(t, e, n); const r = function (t, e, n) { let r = 0, s = e; const i = { match: !1, pathIndex: 0, commandIndex: 0 }; for (; s < t.segments.length;) { if (r >= n.length) return i; const e = t.segments[s], o = Lh(n[r]), a = r < n.length - 1 ? n[r + 1] : null; if (s > 0 && void 0 === o) break; if (o && a && "object" == typeof a && void 0 === a.outlets) { if (!zh(o, a, e)) return i; r += 2 } else { if (!zh(o, {}, e)) return i; r++ } s++ } return { match: !0, pathIndex: s, commandIndex: r } }(t, e, n), s = n.slice(r.commandIndex); if (r.match && r.pathIndex < t.segments.length) { const e = new Jc(t.segments.slice(0, r.pathIndex), {}); return e.children.primary = new Jc(t.segments.slice(r.pathIndex), t.children), Uh(e, 0, s) } return r.match && 0 === s.length ? new Jc(t.segments, {}) : r.match && !t.hasChildren() ? Bh(t, e, n) : r.match ? Uh(t, 0, s) : Bh(t, e, n) } function Uh(t, e, n) { if (0 === n.length) return new Jc(t.segments, {}); { const r = function (t) { return "object" != typeof t[0] ? { primary: t } : void 0 === t[0].outlets ? { primary: t } : t[0].outlets }(n), s = {}; return Gc(r, (n, r) => { null !== n && (s[r] = jh(t.children[r], e, n)) }), Gc(t.children, (t, e) => { void 0 === r[e] && (s[e] = t) }), new Jc(t.segments, s) } } function Bh(t, e, n) { const r = t.segments.slice(0, e); let s = 0; for (; s < n.length;) { if ("object" == typeof n[s] && void 0 !== n[s].outlets) { const t = Hh(n[s].outlets); return new Jc(r, t) } if (0 === s && Nh(n[0])) { r.push(new th(t.segments[e].path, n[0])), s++; continue } const i = Lh(n[s]), o = s < n.length - 1 ? n[s + 1] : null; i && o && Nh(o) ? (r.push(new th(i, Vh(o))), s += 2) : (r.push(new th(i, {})), s++) } return new Jc(r, {}) } function Hh(t) { const e = {}; return Gc(t, (t, n) => { null !== t && (e[n] = Bh(new Jc([], {}), 0, t)) }), e } function Vh(t) { const e = {}; return Gc(t, (t, n) => e[n] = "".concat(t)), e } function zh(t, e, n) { return t == n.path && Qc(e, n.parameters) } class qh { constructor(t, e, n, r) { this.routeReuseStrategy = t, this.futureState = e, this.currState = n, this.forwardEvent = r } activate(t) { const e = this.futureState._root, n = this.currState ? this.currState._root : null; this.deactivateChildRoutes(e, n, t), Ih(this.futureState.root), this.activateChildRoutes(e, n, t) } deactivateChildRoutes(t, e, n) { const r = Sh(e); t.children.forEach(t => { const e = t.value.outlet; this.deactivateRoutes(t, r[e], n), delete r[e] }), Gc(r, (t, e) => { this.deactivateRouteAndItsChildren(t, n) }) } deactivateRoutes(t, e, n) { const r = t.value, s = e ? e.value : null; if (r === s) if (r.component) { const s = n.getContext(r.outlet); s && this.deactivateChildRoutes(t, e, s.children) } else this.deactivateChildRoutes(t, e, n); else s && this.deactivateRouteAndItsChildren(e, n) } deactivateRouteAndItsChildren(t, e) { this.routeReuseStrategy.shouldDetach(t.value.snapshot) ? this.detachAndStoreRouteSubtree(t, e) : this.deactivateRouteAndOutlet(t, e) } detachAndStoreRouteSubtree(t, e) { const n = e.getContext(t.value.outlet); if (n && n.outlet) { const e = n.outlet.detach(), r = n.children.onOutletDeactivated(); this.routeReuseStrategy.store(t.value.snapshot, { componentRef: e, route: t, contexts: r }) } } deactivateRouteAndOutlet(t, e) { const n = e.getContext(t.value.outlet); if (n) { const r = Sh(t), s = t.value.component ? n.children : e; Gc(r, (t, e) => this.deactivateRouteAndItsChildren(t, s)), n.outlet && (n.outlet.deactivate(), n.children.onOutletDeactivated()) } } activateChildRoutes(t, e, n) { const r = Sh(e); t.children.forEach(t => { this.activateRoutes(t, r[t.value.outlet], n), this.forwardEvent(new Dc(t.value.snapshot)) }), t.children.length && this.forwardEvent(new Oc(t.value.snapshot)) } activateRoutes(t, e, n) { const r = t.value, s = e ? e.value : null; if (Ih(r), r === s) if (r.component) { const s = n.getOrCreateContext(r.outlet); this.activateChildRoutes(t, e, s.children) } else this.activateChildRoutes(t, e, n); else if (r.component) { const e = n.getOrCreateContext(r.outlet); if (this.routeReuseStrategy.shouldAttach(r.snapshot)) { const t = this.routeReuseStrategy.retrieve(r.snapshot); this.routeReuseStrategy.store(r.snapshot, null), e.children.onOutletReAttached(t.contexts), e.attachRef = t.componentRef, e.route = t.route.value, e.outlet && e.outlet.attach(t.componentRef, t.route.value), Wh(t.route) } else { const n = function (t) { for (let e = t.parent; e; e = e.parent) { const t = e.routeConfig; if (t && t._loadedConfig) return t._loadedConfig; if (t && t.component) return null } return null }(r.snapshot), s = n ? n.module.componentFactoryResolver : null; e.attachRef = null, e.route = r, e.resolver = s, e.outlet && e.outlet.activateWith(r, s), this.activateChildRoutes(t, null, e.children) } } else this.activateChildRoutes(t, null, n) } } function Wh(t) { Ih(t.value), t.children.forEach(Wh) } function Qh(t) { return "function" == typeof t } function Kh(t) { return t instanceof $c } class Zh { constructor(t) { this.segmentGroup = t || null } } class Gh { constructor(t) { this.urlTree = t } } function Yh(t) { return new w(e => e.error(new Zh(t))) } function Xh(t) { return new w(e => e.error(new Gh(t))) } function $h(t) { return new w(e => e.error(new Error("Only absolute redirects can have named outlets. redirectTo: '".concat(t, "'")))) } class Jh { constructor(t, e, n, r, s) { this.configLoader = e, this.urlSerializer = n, this.urlTree = r, this.config = s, this.allowRedirects = !0, this.ngModule = t.get(Lt) } apply() { return this.expandSegmentGroup(this.ngModule, this.config, this.urlTree.root, "primary").pipe(H(t => this.createUrlTree(t, this.urlTree.queryParams, this.urlTree.fragment))).pipe(Za(t => { if (t instanceof Gh) return this.allowRedirects = !1, this.match(t.urlTree); if (t instanceof Zh) throw this.noMatchError(t); throw t })) } match(t) { return this.expandSegmentGroup(this.ngModule, this.config, t.root, "primary").pipe(H(e => this.createUrlTree(e, t.queryParams, t.fragment))).pipe(Za(t => { if (t instanceof Zh) throw this.noMatchError(t); throw t })) } noMatchError(t) { return new Error("Cannot match any routes. URL Segment: '".concat(t.segmentGroup, "'")) } createUrlTree(t, e, n) { const r = t.segments.length > 0 ? new Jc([], { primary: t }) : t; return new $c(r, e, n) } expandSegmentGroup(t, e, n, r) { return 0 === n.segments.length && n.hasChildren() ? this.expandChildren(t, e, n).pipe(H(t => new Jc([], t))) : this.expandSegment(t, n, e, n.segments, r, !0) } expandChildren(t, e, n) { return function (t, e) { if (0 === Object.keys(t).length) return Sa({}); const n = [], r = [], s = {}; return Gc(t, (t, i) => { const o = e(i, t).pipe(H(t => s[i] = t)); "primary" === i ? n.push(o) : r.push(o) }), Sa.apply(null, n.concat(r)).pipe(Pa(), Ka(), H(() => s)) }(n.children, (n, r) => this.expandSegmentGroup(t, e, r, n)) } expandSegment(t, e, n, r, s, i) { return Sa(...n).pipe(H(o => this.expandSegmentAgainstRoute(t, e, n, o, r, s, i).pipe(Za(t => { if (t instanceof Zh) return Sa(null); throw t }))), Pa(), tl(t => !!t), Za((t, n) => { if (t instanceof xa || "EmptyError" === t.name) { if (this.noLeftoversInUrl(e, r, s)) return Sa(new Jc([], {})); throw new Zh(e) } throw t })) } noLeftoversInUrl(t, e, n) { return 0 === e.length && !t.children[n] } expandSegmentAgainstRoute(t, e, n, r, s, i, o) { return ru(r) !== i ? Yh(e) : void 0 === r.redirectTo ? this.matchSegmentAgainstRoute(t, e, r, s) : o && this.allowRedirects ? this.expandSegmentAgainstRouteUsingRedirect(t, e, n, r, s, i) : Yh(e) } expandSegmentAgainstRouteUsingRedirect(t, e, n, r, s, i) { return "**" === r.path ? this.expandWildCardWithParamsAgainstRouteUsingRedirect(t, n, r, i) : this.expandRegularSegmentAgainstRouteUsingRedirect(t, e, n, r, s, i) } expandWildCardWithParamsAgainstRouteUsingRedirect(t, e, n, r) { const s = this.applyRedirectCommands([], n.redirectTo, {}); return n.redirectTo.startsWith("/") ? Xh(s) : this.lineralizeSegments(n, s).pipe(Q(n => { const s = new Jc(n, {}); return this.expandSegment(t, s, e, n, r, !1) })) } expandRegularSegmentAgainstRouteUsingRedirect(t, e, n, r, s, i) { const { matched: o, consumedSegments: a, lastChild: l, positionalParamSegments: c } = tu(e, r, s); if (!o) return Yh(e); const h = this.applyRedirectCommands(a, r.redirectTo, c); return r.redirectTo.startsWith("/") ? Xh(h) : this.lineralizeSegments(r, h).pipe(Q(r => this.expandSegment(t, e, n, r.concat(s.slice(l)), i, !1))) } matchSegmentAgainstRoute(t, e, n, r) { if ("**" === n.path) return n.loadChildren ? this.configLoader.load(t.injector, n).pipe(H(t => (n._loadedConfig = t, new Jc(r, {})))) : Sa(new Jc(r, {})); const { matched: s, consumedSegments: i, lastChild: o } = tu(e, n, r); if (!s) return Yh(e); const a = r.slice(o); return this.getChildConfig(t, n, r).pipe(Q(t => { const n = t.module, r = t.routes, { segmentGroup: s, slicedSegments: o } = function (t, e, n, r) { return n.length > 0 && function (t, e, n) { return n.some(n => nu(t, e, n) && "primary" !== ru(n)) }(t, n, r) ? { segmentGroup: eu(new Jc(e, function (t, e) { const n = {}; n.primary = e; for (const r of t) "" === r.path && "primary" !== ru(r) && (n[ru(r)] = new Jc([], {})); return n }(r, new Jc(n, t.children)))), slicedSegments: [] } : 0 === n.length && function (t, e, n) { return n.some(n => nu(t, e, n)) }(t, n, r) ? { segmentGroup: eu(new Jc(t.segments, function (t, e, n, r) { const s = {}; for (const i of n) nu(t, e, i) && !r[ru(i)] && (s[ru(i)] = new Jc([], {})); return Object.assign({}, r, s) }(t, n, r, t.children))), slicedSegments: n } : { segmentGroup: t, slicedSegments: n } }(e, i, a, r); return 0 === o.length && s.hasChildren() ? this.expandChildren(n, r, s).pipe(H(t => new Jc(i, t))) : 0 === r.length && 0 === o.length ? Sa(new Jc(i, {})) : this.expandSegment(n, s, r, o, "primary", !0).pipe(H(t => new Jc(i.concat(t.segments), t.children))) })) } getChildConfig(t, e, n) { return e.children ? Sa(new Hc(e.children, t)) : e.loadChildren ? void 0 !== e._loadedConfig ? Sa(e._loadedConfig) : function (t, e, n) { const r = e.canLoad; return r && 0 !== r.length ? W(r).pipe(H(r => { const s = t.get(r); let i; if (function (t) { return t && Qh(t.canLoad) }(s)) i = s.canLoad(e, n); else { if (!Qh(s)) throw new Error("Invalid CanLoad guard"); i = s(e, n) } return Yc(i) })).pipe(Pa(), (s = t => !0 === t, t => t.lift(new el(s, void 0, t)))) : Sa(!0); var s }(t.injector, e, n).pipe(Q(n => n ? this.configLoader.load(t.injector, e).pipe(H(t => (e._loadedConfig = t, t))) : function (t) { return new w(e => e.error(Uc("Cannot load children because the guard of the route \"path: '".concat(t.path, "'\" returned false")))) }(e))) : Sa(new Hc([], t)) } lineralizeSegments(t, e) { let n = [], r = e.root; for (; ;) { if (n = n.concat(r.segments), 0 === r.numberOfChildren) return Sa(n); if (r.numberOfChildren > 1 || !r.children.primary) return $h(t.redirectTo); r = r.children.primary } } applyRedirectCommands(t, e, n) { return this.applyRedirectCreatreUrlTree(e, this.urlSerializer.parse(e), t, n) } applyRedirectCreatreUrlTree(t, e, n, r) { const s = this.createSegmentGroup(t, e.root, n, r); return new $c(s, this.createQueryParams(e.queryParams, this.urlTree.queryParams), e.fragment) } createQueryParams(t, e) { const n = {}; return Gc(t, (t, r) => { if ("string" == typeof t && t.startsWith(":")) { const s = t.substring(1); n[r] = e[s] } else n[r] = t }), n } createSegmentGroup(t, e, n, r) { const s = this.createSegments(t, e.segments, n, r); let i = {}; return Gc(e.children, (e, s) => { i[s] = this.createSegmentGroup(t, e, n, r) }), new Jc(s, i) } createSegments(t, e, n, r) { return e.map(e => e.path.startsWith(":") ? this.findPosParam(t, e, r) : this.findOrReturn(e, n)) } findPosParam(t, e, n) { const r = n[e.path.substring(1)]; if (!r) throw new Error("Cannot redirect to '".concat(t, "'. Cannot find '").concat(e.path, "'.")); return r } findOrReturn(t, e) { let n = 0; for (const r of e) { if (r.path === t.path) return e.splice(n), r; n++ } return t } } function tu(t, e, n) { if ("" === e.path) return "full" === e.pathMatch && (t.hasChildren() || n.length > 0) ? { matched: !1, consumedSegments: [], lastChild: 0, positionalParamSegments: {} } : { matched: !0, consumedSegments: [], lastChild: 0, positionalParamSegments: {} }; const r = (e.matcher || Bc)(n, t, e); return r ? { matched: !0, consumedSegments: r.consumed, lastChild: r.consumed.length, positionalParamSegments: r.posParams } : { matched: !1, consumedSegments: [], lastChild: 0, positionalParamSegments: {} } } function eu(t) { if (1 === t.numberOfChildren && t.children.primary) { const e = t.children.primary; return new Jc(t.segments.concat(e.segments), e.children) } return t } function nu(t, e, n) { return (!(t.hasChildren() || e.length > 0) || "full" !== n.pathMatch) && "" === n.path && void 0 !== n.redirectTo } function ru(t) { return t.outlet || "primary" } class su { constructor(t) { this.path = t, this.route = this.path[this.path.length - 1] } } class iu { constructor(t, e) { this.component = t, this.route = e } } function ou(t, e, n) { const r = t._root; return function t(e, n, r, s, i = { canDeactivateChecks: [], canActivateChecks: [] }) { const o = Sh(n); return e.children.forEach(e => { !function (e, n, r, s, i = { canDeactivateChecks: [], canActivateChecks: [] }) { const o = e.value, a = n ? n.value : null, l = r ? r.getContext(e.value.outlet) : null; if (a && o.routeConfig === a.routeConfig) { const c = function (t, e, n) { if ("function" == typeof n) return n(t, e); switch (n) { case "pathParamsChange": return !eh(t.url, e.url); case "pathParamsOrQueryParamsChange": return !eh(t.url, e.url) || !Qc(t.queryParams, e.queryParams); case "always": return !0; case "paramsOrQueryParamsChange": return !Oh(t, e) || !Qc(t.queryParams, e.queryParams); case "paramsChange": default: return !Oh(t, e) } }(a, o, o.routeConfig.runGuardsAndResolvers); c ? i.canActivateChecks.push(new su(s)) : (o.data = a.data, o._resolvedData = a._resolvedData), t(e, n, o.component ? l ? l.children : null : r, s, i), c && i.canDeactivateChecks.push(new iu(l && l.outlet && l.outlet.component || null, a)) } else a && lu(n, l, i), i.canActivateChecks.push(new su(s)), t(e, null, o.component ? l ? l.children : null : r, s, i) }(e, o[e.value.outlet], r, s.concat([e.value]), i), delete o[e.value.outlet] }), Gc(o, (t, e) => lu(t, r.getContext(e), i)), i }(r, e ? e._root : null, n, [r.value]) } function au(t, e, n) { const r = function (t) { if (!t) return null; for (let e = t.parent; e; e = e.parent) { const t = e.routeConfig; if (t && t._loadedConfig) return t._loadedConfig } return null }(e); return (r ? r.module.injector : n).get(t) } function lu(t, e, n) { const r = Sh(t), s = t.value; Gc(r, (t, r) => { lu(t, s.component ? e ? e.children.getContext(r) : null : e, n) }), n.canDeactivateChecks.push(new iu(s.component && e && e.outlet && e.outlet.isActivated ? e.outlet.component : null, s)) } const cu = Symbol("INITIAL_VALUE"); function hu() { return rl(t => function (...t) { let e = null, n = null; return R(t[t.length - 1]) && (n = t.pop()), "function" == typeof t[t.length - 1] && (e = t.pop()), 1 === t.length && l(t[0]) && (t = t[0]), q(t, n).lift(new ka(e)) }(...t.map(t => t.pipe(Xa(1), al(cu)))).pipe(ll((t, e) => { let n = !1; return e.reduce((t, r, s) => { if (t !== cu) return t; if (r === cu && (n = !0), !n) { if (!1 === r) return r; if (s === e.length - 1 || Kh(r)) return r } return t }, t) }, cu), Ia(t => t !== cu), H(t => Kh(t) ? t : !0 === t), Xa(1))) } function uu(t, e) { return null !== t && e && e(new Nc(t)), Sa(!0) } function du(t, e) { return null !== t && e && e(new Ic(t)), Sa(!0) } function pu(t, e, n) { const r = e.routeConfig ? e.routeConfig.canActivate : null; return r && 0 !== r.length ? Sa(r.map(r => Ra(() => { const s = au(r, e, n); let i; if (function (t) { return t && Qh(t.canActivate) }(s)) i = Yc(s.canActivate(e, t)); else { if (!Qh(s)) throw new Error("Invalid CanActivate guard"); i = Yc(s(e, t)) } return i.pipe(tl()) }))).pipe(hu()) : Sa(!0) } function fu(t, e, n) { const r = e[e.length - 1], s = e.slice(0, e.length - 1).reverse().map(t => function (t) { const e = t.routeConfig ? t.routeConfig.canActivateChild : null; return e && 0 !== e.length ? { node: t, guards: e } : null }(t)).filter(t => null !== t).map(e => Ra(() => Sa(e.guards.map(s => { const i = au(s, e.node, n); let o; if (function (t) { return t && Qh(t.canActivateChild) }(i)) o = Yc(i.canActivateChild(r, t)); else { if (!Qh(i)) throw new Error("Invalid CanActivateChild guard"); o = Yc(i(r, t)) } return o.pipe(tl()) })).pipe(hu()))); return Sa(s).pipe(hu()) } class mu { } class gu { constructor(t, e, n, r, s, i) { this.rootComponentType = t, this.config = e, this.urlTree = n, this.url = r, this.paramsInheritanceStrategy = s, this.relativeLinkResolution = i } recognize() { try { const t = vu(this.urlTree.root, [], [], this.config, this.relativeLinkResolution).segmentGroup, e = this.processSegmentGroup(this.config, t, "primary"), n = new kh([], Object.freeze({}), Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, {}, "primary", this.rootComponentType, null, this.urlTree.root, -1, {}), r = new wh(n, e), s = new Ah(this.url, r); return this.inheritParamsAndData(s._root), Sa(s) } catch (t) { return new w(e => e.error(t)) } } inheritParamsAndData(t) { const e = t.value, n = Th(e, this.paramsInheritanceStrategy); e.params = Object.freeze(n.params), e.data = Object.freeze(n.data), t.children.forEach(t => this.inheritParamsAndData(t)) } processSegmentGroup(t, e, n) { return 0 === e.segments.length && e.hasChildren() ? this.processChildren(t, e) : this.processSegment(t, e, e.segments, n) } processChildren(t, e) { const n = nh(e, (e, n) => this.processSegmentGroup(t, e, n)); return function (t) { const e = {}; t.forEach(t => { const n = e[t.value.outlet]; if (n) { const e = n.url.map(t => t.toString()).join("/"), r = t.value.url.map(t => t.toString()).join("/"); throw new Error("Two segments cannot have the same outlet name: '".concat(e, "' and '").concat(r, "'.")) } e[t.value.outlet] = t.value }) }(n), n.sort((t, e) => "primary" === t.value.outlet ? -1 : "primary" === e.value.outlet ? 1 : t.value.outlet.localeCompare(e.value.outlet)), n } processSegment(t, e, n, r) { for (const i of t) try { return this.processSegmentAgainstRoute(i, e, n, r) } catch (s) { if (!(s instanceof mu)) throw s } if (this.noLeftoversInUrl(e, n, r)) return []; throw new mu } noLeftoversInUrl(t, e, n) { return 0 === e.length && !t.children[n] } processSegmentAgainstRoute(t, e, n, r) { if (t.redirectTo) throw new mu; if ((t.outlet || "primary") !== r) throw new mu; let s, i = [], o = []; if ("**" === t.path) { const i = n.length > 0 ? Zc(n).parameters : {}; s = new kh(n, i, Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, Su(t), r, t.component, t, yu(e), _u(e) + n.length, Eu(t)) } else { const a = function (t, e, n) { if ("" === e.path) { if ("full" === e.pathMatch && (t.hasChildren() || n.length > 0)) throw new mu; return { consumedSegments: [], lastChild: 0, parameters: {} } } const r = (e.matcher || Bc)(n, t, e); if (!r) throw new mu; const s = {}; Gc(r.posParams, (t, e) => { s[e] = t.path }); const i = r.consumed.length > 0 ? Object.assign({}, s, r.consumed[r.consumed.length - 1].parameters) : s; return { consumedSegments: r.consumed, lastChild: r.consumed.length, parameters: i } }(e, t, n); i = a.consumedSegments, o = n.slice(a.lastChild), s = new kh(i, a.parameters, Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, Su(t), r, t.component, t, yu(e), _u(e) + i.length, Eu(t)) } const a = function (t) { return t.children ? t.children : t.loadChildren ? t._loadedConfig.routes : [] }(t), { segmentGroup: l, slicedSegments: c } = vu(e, i, o, a, this.relativeLinkResolution); if (0 === c.length && l.hasChildren()) { const t = this.processChildren(a, l); return [new wh(s, t)] } if (0 === a.length && 0 === c.length) return [new wh(s, [])]; const h = this.processSegment(a, l, c, "primary"); return [new wh(s, h)] } } function yu(t) { let e = t; for (; e._sourceSegment;)e = e._sourceSegment; return e } function _u(t) { let e = t, n = e._segmentIndexShift ? e._segmentIndexShift : 0; for (; e._sourceSegment;)e = e._sourceSegment, n += e._segmentIndexShift ? e._segmentIndexShift : 0; return n - 1 } function vu(t, e, n, r, s) { if (n.length > 0 && function (t, e, n) { return n.some(n => bu(t, e, n) && "primary" !== wu(n)) }(t, n, r)) { const s = new Jc(e, function (t, e, n, r) { const s = {}; s.primary = r, r._sourceSegment = t, r._segmentIndexShift = e.length; for (const i of n) if ("" === i.path && "primary" !== wu(i)) { const n = new Jc([], {}); n._sourceSegment = t, n._segmentIndexShift = e.length, s[wu(i)] = n } return s }(t, e, r, new Jc(n, t.children))); return s._sourceSegment = t, s._segmentIndexShift = e.length, { segmentGroup: s, slicedSegments: [] } } if (0 === n.length && function (t, e, n) { return n.some(n => bu(t, e, n)) }(t, n, r)) { const i = new Jc(t.segments, function (t, e, n, r, s, i) { const o = {}; for (const a of r) if (bu(t, n, a) && !s[wu(a)]) { const n = new Jc([], {}); n._sourceSegment = t, n._segmentIndexShift = "legacy" === i ? t.segments.length : e.length, o[wu(a)] = n } return Object.assign({}, s, o) }(t, e, n, r, t.children, s)); return i._sourceSegment = t, i._segmentIndexShift = e.length, { segmentGroup: i, slicedSegments: n } } const i = new Jc(t.segments, t.children); return i._sourceSegment = t, i._segmentIndexShift = e.length, { segmentGroup: i, slicedSegments: n } } function bu(t, e, n) { return (!(t.hasChildren() || e.length > 0) || "full" !== n.pathMatch) && "" === n.path && void 0 === n.redirectTo } function wu(t) { return t.outlet || "primary" } function Su(t) { return t.data || {} } function Eu(t) { return t.resolve || {} } function Cu(t, e, n, r) { const s = au(t, e, r); return Yc(s.resolve ? s.resolve(e, n) : s(e, n)) } function xu(t) { return function (e) { return e.pipe(rl(e => { const n = t(e); return n ? W(n).pipe(H(() => e)) : W([e]) })) } } class Tu { } class ku { shouldDetach(t) { return !1 } store(t, e) { } shouldAttach(t) { return !1 } retrieve(t) { return null } shouldReuseRoute(t, e) { return t.routeConfig === e.routeConfig } } const Au = new Tt("ROUTES"); class Ru { constructor(t, e, n, r) { this.loader = t, this.compiler = e, this.onLoadStartListener = n, this.onLoadEndListener = r } load(t, e) { return this.onLoadStartListener && this.onLoadStartListener(e), this.loadModuleFactory(e.loadChildren).pipe(H(n => { this.onLoadEndListener && this.onLoadEndListener(e); const r = n.create(t); return new Hc(Kc(r.injector.get(Au)).map(Wc), r) })) } loadModuleFactory(t) { return "string" == typeof t ? W(this.loader.load(t)) : Yc(t()).pipe(Q(t => t instanceof jt ? Sa(t) : W(this.compiler.compileModuleAsync(t)))) } } class Pu { } class Iu { shouldProcessUrl(t) { return !0 } extract(t) { return t } merge(t, e) { return t } } function Ou(t) { throw t } function Nu(t, e, n) { return e.parse("/") } function Du(t, e) { return Sa(null) } class Fu { constructor(t, e, n, r, s, i, o, a) { this.rootComponentType = t, this.urlSerializer = e, this.rootContexts = n, this.location = r, this.config = a, this.lastSuccessfulNavigation = null, this.currentNavigation = null, this.navigationId = 0, this.isNgZoneEnabled = !1, this.events = new k, this.errorHandler = Ou, this.malformedUriErrorHandler = Nu, this.navigated = !1, this.lastSuccessfulId = -1, this.hooks = { beforePreactivation: Du, afterPreactivation: Du }, this.urlHandlingStrategy = new Iu, this.routeReuseStrategy = new ku, this.onSameUrlNavigation = "ignore", this.paramsInheritanceStrategy = "emptyOnly", this.urlUpdateStrategy = "deferred", this.relativeLinkResolution = "legacy", this.ngModule = s.get(Lt), this.console = s.get(As); const l = s.get(Ws); this.isNgZoneEnabled = l instanceof Ws, this.resetConfig(a), this.currentUrlTree = new $c(new Jc([], {}), {}, null), this.rawUrlTree = this.currentUrlTree, this.browserUrlTree = this.currentUrlTree, this.configLoader = new Ru(i, o, t => this.triggerEvent(new Rc(t)), t => this.triggerEvent(new Pc(t))), this.routerState = Ch(this.currentUrlTree, this.rootComponentType), this.transitions = new Ea({ id: 0, currentUrlTree: this.currentUrlTree, currentRawUrl: this.currentUrlTree, extractedUrl: this.urlHandlingStrategy.extract(this.currentUrlTree), urlAfterRedirects: this.urlHandlingStrategy.extract(this.currentUrlTree), rawUrl: this.currentUrlTree, extras: {}, resolve: null, reject: null, promise: Promise.resolve(!0), source: "imperative", restoredState: null, currentSnapshot: this.routerState.snapshot, targetSnapshot: null, currentRouterState: this.routerState, targetRouterState: null, guards: { canActivateChecks: [], canDeactivateChecks: [] }, guardsResult: null }), this.navigations = this.setupNavigations(this.transitions), this.processNavigations() } setupNavigations(t) { const e = this.events; return t.pipe(Ia(t => 0 !== t.id), H(t => Object.assign({}, t, { extractedUrl: this.urlHandlingStrategy.extract(t.rawUrl) })), rl(t => { let n = !1, r = !1; return Sa(t).pipe(Ua(t => { this.currentNavigation = { id: t.id, initialUrl: t.currentRawUrl, extractedUrl: t.extractedUrl, trigger: t.source, extras: t.extras, previousNavigation: this.lastSuccessfulNavigation ? Object.assign({}, this.lastSuccessfulNavigation, { previousNavigation: null }) : null } }), rl(t => { const n = !this.navigated || t.extractedUrl.toString() !== this.browserUrlTree.toString(); if (("reload" === this.onSameUrlNavigation || n) && this.urlHandlingStrategy.shouldProcessUrl(t.rawUrl)) return Sa(t).pipe(rl(t => { const n = this.transitions.getValue(); return e.next(new bc(t.id, this.serializeUrl(t.extractedUrl), t.source, t.restoredState)), n !== this.transitions.getValue() ? va : [t] }), rl(t => Promise.resolve(t)), (r = this.ngModule.injector, s = this.configLoader, i = this.urlSerializer, o = this.config, function (t) { return t.pipe(rl(t => function (t, e, n, r, s) { return new Jh(t, e, n, r, s).apply() }(r, s, i, t.extractedUrl, o).pipe(H(e => Object.assign({}, t, { urlAfterRedirects: e }))))) }), Ua(t => { this.currentNavigation = Object.assign({}, this.currentNavigation, { finalUrl: t.urlAfterRedirects }) }), function (t, e, n, r, s) { return function (i) { return i.pipe(Q(i => function (t, e, n, r, s = "emptyOnly", i = "legacy") { return new gu(t, e, n, r, s, i).recognize() }(t, e, i.urlAfterRedirects, n(i.urlAfterRedirects), r, s).pipe(H(t => Object.assign({}, i, { targetSnapshot: t }))))) } }(this.rootComponentType, this.config, t => this.serializeUrl(t), this.paramsInheritanceStrategy, this.relativeLinkResolution), Ua(t => { "eager" === this.urlUpdateStrategy && (t.extras.skipLocationChange || this.setBrowserUrl(t.urlAfterRedirects, !!t.extras.replaceUrl, t.id, t.extras.state), this.browserUrlTree = t.urlAfterRedirects) }), Ua(t => { const n = new Cc(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot); e.next(n) })); var r, s, i, o; if (n && this.rawUrlTree && this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)) { const { id: n, extractedUrl: r, source: s, restoredState: i, extras: o } = t, a = new bc(n, this.serializeUrl(r), s, i); e.next(a); const l = Ch(r, this.rootComponentType).snapshot; return Sa(Object.assign({}, t, { targetSnapshot: l, urlAfterRedirects: r, extras: Object.assign({}, o, { skipLocationChange: !1, replaceUrl: !1 }) })) } return this.rawUrlTree = t.rawUrl, this.browserUrlTree = t.urlAfterRedirects, t.resolve(null), va }), xu(t => { const { targetSnapshot: e, id: n, extractedUrl: r, rawUrl: s, extras: { skipLocationChange: i, replaceUrl: o } } = t; return this.hooks.beforePreactivation(e, { navigationId: n, appliedUrlTree: r, rawUrlTree: s, skipLocationChange: !!i, replaceUrl: !!o }) }), Ua(t => { const e = new xc(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot); this.triggerEvent(e) }), H(t => Object.assign({}, t, { guards: ou(t.targetSnapshot, t.currentSnapshot, this.rootContexts) })), function (t, e) { return function (n) { return n.pipe(Q(n => { const { targetSnapshot: r, currentSnapshot: s, guards: { canActivateChecks: i, canDeactivateChecks: o } } = n; return 0 === o.length && 0 === i.length ? Sa(Object.assign({}, n, { guardsResult: !0 })) : function (t, e, n, r) { return W(t).pipe(Q(t => function (t, e, n, r, s) { const i = e && e.routeConfig ? e.routeConfig.canDeactivate : null; return i && 0 !== i.length ? Sa(i.map(i => { const o = au(i, e, s); let a; if (function (t) { return t && Qh(t.canDeactivate) }(o)) a = Yc(o.canDeactivate(t, e, n, r)); else { if (!Qh(o)) throw new Error("Invalid CanDeactivate guard"); a = Yc(o(t, e, n, r)) } return a.pipe(tl()) })).pipe(hu()) : Sa(!0) }(t.component, t.route, n, e, r)), tl(t => !0 !== t, !0)) }(o, r, s, t).pipe(Q(n => n && "boolean" == typeof n ? function (t, e, n, r) { return W(e).pipe(ul(e => W([du(e.route.parent, r), uu(e.route, r), fu(t, e.path, n), pu(t, e.route, n)]).pipe(Pa(), tl(t => !0 !== t, !0))), tl(t => !0 !== t, !0)) }(r, i, t, e) : Sa(n)), H(t => Object.assign({}, n, { guardsResult: t }))) })) } }(this.ngModule.injector, t => this.triggerEvent(t)), Ua(t => { if (Kh(t.guardsResult)) { const e = Uc('Redirecting to "'.concat(this.serializeUrl(t.guardsResult), '"')); throw e.url = t.guardsResult, e } }), Ua(t => { const e = new Tc(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot, !!t.guardsResult); this.triggerEvent(e) }), Ia(t => { if (!t.guardsResult) { this.resetUrlToCurrentUrlTree(); const n = new Sc(t.id, this.serializeUrl(t.extractedUrl), ""); return e.next(n), t.resolve(!1), !1 } return !0 }), xu(t => { if (t.guards.canActivateChecks.length) return Sa(t).pipe(Ua(t => { const e = new kc(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot); this.triggerEvent(e) }), (e = this.paramsInheritanceStrategy, n = this.ngModule.injector, function (t) { return t.pipe(Q(t => { const { targetSnapshot: r, guards: { canActivateChecks: s } } = t; return s.length ? W(s).pipe(ul(t => function (t, e, n, r) { return function (t, e, n, r) { const s = Object.keys(t); if (0 === s.length) return Sa({}); if (1 === s.length) { const i = s[0]; return Cu(t[i], e, n, r).pipe(H(t => ({ [i]: t }))) } const i = {}; return W(s).pipe(Q(s => Cu(t[s], e, n, r).pipe(H(t => (i[s] = t, t))))).pipe(Ka(), H(() => i)) }(t._resolve, t, e, r).pipe(H(e => (t._resolvedData = e, t.data = Object.assign({}, t.data, Th(t, n).resolve), null))) }(t.route, r, e, n)), function (t, e) { return arguments.length >= 2 ? function (n) { return v(ll(t, e), Ma(1), qa(e))(n) } : function (e) { return v(ll((e, n, r) => t(e, n, r + 1)), Ma(1))(e) } }((t, e) => t), H(e => t)) : Sa(t) })) }), Ua(t => { const e = new Ac(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot); this.triggerEvent(e) })); var e, n }), xu(t => { const { targetSnapshot: e, id: n, extractedUrl: r, rawUrl: s, extras: { skipLocationChange: i, replaceUrl: o } } = t; return this.hooks.afterPreactivation(e, { navigationId: n, appliedUrlTree: r, rawUrlTree: s, skipLocationChange: !!i, replaceUrl: !!o }) }), H(t => { const e = function (t, e, n) { const r = function t(e, n, r) { if (r && e.shouldReuseRoute(n.value, r.value.snapshot)) { const s = r.value; s._futureSnapshot = n.value; const i = function (e, n, r) { return n.children.map(n => { for (const s of r.children) if (e.shouldReuseRoute(s.value.snapshot, n.value)) return t(e, n, s); return t(e, n) }) }(e, n, r); return new wh(s, i) } { const r = e.retrieve(n.value); if (r) { const t = r.route; return function t(e, n) { if (e.value.routeConfig !== n.value.routeConfig) throw new Error("Cannot reattach ActivatedRouteSnapshot created from a different route"); if (e.children.length !== n.children.length) throw new Error("Cannot reattach ActivatedRouteSnapshot with a different number of children"); n.value._futureSnapshot = e.value; for (let r = 0; r < e.children.length; ++r)t(e.children[r], n.children[r]) }(n, t), t } { const r = new xh(new Ea((s = n.value).url), new Ea(s.params), new Ea(s.queryParams), new Ea(s.fragment), new Ea(s.data), s.outlet, s.component, s), i = n.children.map(n => t(e, n)); return new wh(r, i) } } var s }(t, e._root, n ? n._root : void 0); return new Eh(r, e) }(this.routeReuseStrategy, t.targetSnapshot, t.currentRouterState); return Object.assign({}, t, { targetRouterState: e }) }), Ua(t => { this.currentUrlTree = t.urlAfterRedirects, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, t.rawUrl), this.routerState = t.targetRouterState, "deferred" === this.urlUpdateStrategy && (t.extras.skipLocationChange || this.setBrowserUrl(this.rawUrlTree, !!t.extras.replaceUrl, t.id, t.extras.state), this.browserUrlTree = t.urlAfterRedirects) }), (i = this.rootContexts, o = this.routeReuseStrategy, a = t => this.triggerEvent(t), H(t => (new qh(o, t.targetRouterState, t.currentRouterState, a).activate(i), t))), Ua({ next() { n = !0 }, complete() { n = !0 } }), (s = () => { if (!n && !r) { this.resetUrlToCurrentUrlTree(); const n = new Sc(t.id, this.serializeUrl(t.extractedUrl), "Navigation ID ".concat(t.id, " is not equal to the current navigation id ").concat(this.navigationId)); e.next(n), t.resolve(!1) } this.currentNavigation = null }, t => t.lift(new dl(s))), Za(n => { if (r = !0, (s = n) && s.ngNavigationCancelingError) { const r = Kh(n.url); r || (this.navigated = !0, this.resetStateAndUrl(t.currentRouterState, t.currentUrlTree, t.rawUrl)); const s = new Sc(t.id, this.serializeUrl(t.extractedUrl), n.message); e.next(s), t.resolve(!1), r && this.navigateByUrl(n.url) } else { this.resetStateAndUrl(t.currentRouterState, t.currentUrlTree, t.rawUrl); const r = new Ec(t.id, this.serializeUrl(t.extractedUrl), n); e.next(r); try { t.resolve(this.errorHandler(n)) } catch (i) { t.reject(i) } } var s; return va })); var s, i, o, a })) } resetRootComponentType(t) { this.rootComponentType = t, this.routerState.root.component = this.rootComponentType } getTransition() { const t = this.transitions.value; return t.urlAfterRedirects = this.browserUrlTree, t } setTransition(t) { this.transitions.next(Object.assign({}, this.getTransition(), t)) } initialNavigation() { this.setUpLocationChangeListener(), 0 === this.navigationId && this.navigateByUrl(this.location.path(!0), { replaceUrl: !0 }) } setUpLocationChangeListener() { this.locationSubscription || (this.locationSubscription = this.location.subscribe(t => { let e = this.parseUrl(t.url); const n = "popstate" === t.type ? "popstate" : "hashchange", r = t.state && t.state.navigationId ? t.state : null; setTimeout(() => { this.scheduleNavigation(e, n, r, { replaceUrl: !0 }) }, 0) })) } get url() { return this.serializeUrl(this.currentUrlTree) } getCurrentNavigation() { return this.currentNavigation } triggerEvent(t) { this.events.next(t) } resetConfig(t) { Vc(t), this.config = t.map(Wc), this.navigated = !1, this.lastSuccessfulId = -1 } ngOnDestroy() { this.dispose() } dispose() { this.locationSubscription && (this.locationSubscription.unsubscribe(), this.locationSubscription = null) } createUrlTree(t, e = {}) { const { relativeTo: n, queryParams: r, fragment: s, preserveQueryParams: i, queryParamsHandling: o, preserveFragment: a } = e; Gt() && i && console && console.warn && console.warn("preserveQueryParams is deprecated, use queryParamsHandling instead."); const l = n || this.routerState.root, c = a ? this.currentUrlTree.fragment : s; let h = null; if (o) switch (o) { case "merge": h = Object.assign({}, this.currentUrlTree.queryParams, r); break; case "preserve": h = this.currentUrlTree.queryParams; break; default: h = r || null } else h = i ? this.currentUrlTree.queryParams : r || null; return null !== h && (h = this.removeEmptyProps(h)), function (t, e, n, r, s) { if (0 === n.length) return Dh(e.root, e.root, e, r, s); const i = function (t) { if ("string" == typeof t[0] && 1 === t.length && "/" === t[0]) return new Fh(!0, 0, t); let e = 0, n = !1; const r = t.reduce((t, r, s) => { if ("object" == typeof r && null != r) { if (r.outlets) { const e = {}; return Gc(r.outlets, (t, n) => { e[n] = "string" == typeof t ? t.split("/") : t }), [...t, { outlets: e }] } if (r.segmentPath) return [...t, r.segmentPath] } return "string" != typeof r ? [...t, r] : 0 === s ? (r.split("/").forEach((r, s) => { 0 == s && "." === r || (0 == s && "" === r ? n = !0 : ".." === r ? e++ : "" != r && t.push(r)) }), t) : [...t, r] }, []); return new Fh(n, e, r) }(n); if (i.toRoot()) return Dh(e.root, new Jc([], {}), e, r, s); const o = function (t, e, n) { if (t.isAbsolute) return new Mh(e.root, !0, 0); if (-1 === n.snapshot._lastPathIndex) return new Mh(n.snapshot._urlSegment, !0, 0); const r = Nh(t.commands[0]) ? 0 : 1; return function (t, e, n) { let r = t, s = e, i = n; for (; i > s;) { if (i -= s, r = r.parent, !r) throw new Error("Invalid number of '../'"); s = r.segments.length } return new Mh(r, !1, s - i) }(n.snapshot._urlSegment, n.snapshot._lastPathIndex + r, t.numberOfDoubleDots) }(i, e, t), a = o.processChildren ? Uh(o.segmentGroup, o.index, i.commands) : jh(o.segmentGroup, o.index, i.commands); return Dh(o.segmentGroup, a, e, r, s) }(l, this.currentUrlTree, t, h, c) } navigateByUrl(t, e = { skipLocationChange: !1 }) { Gt() && this.isNgZoneEnabled && !Ws.isInAngularZone() && this.console.warn("Navigation triggered outside Angular zone, did you forget to call 'ngZone.run()'?"); const n = Kh(t) ? t : this.parseUrl(t), r = this.urlHandlingStrategy.merge(n, this.rawUrlTree); return this.scheduleNavigation(r, "imperative", null, e) } navigate(t, e = { skipLocationChange: !1 }) { return function (t) { for (let e = 0; e < t.length; e++) { const n = t[e]; if (null == n) throw new Error("The requested path contains ".concat(n, " segment at index ").concat(e)) } }(t), this.navigateByUrl(this.createUrlTree(t, e), e) } serializeUrl(t) { return this.urlSerializer.serialize(t) } parseUrl(t) { let e; try { e = this.urlSerializer.parse(t) } catch (n) { e = this.malformedUriErrorHandler(n, this.urlSerializer, t) } return e } isActive(t, e) { if (Kh(t)) return Xc(this.currentUrlTree, t, e); const n = this.parseUrl(t); return Xc(this.currentUrlTree, n, e) } removeEmptyProps(t) { return Object.keys(t).reduce((e, n) => { const r = t[n]; return null != r && (e[n] = r), e }, {}) } processNavigations() { this.navigations.subscribe(t => { this.navigated = !0, this.lastSuccessfulId = t.id, this.events.next(new wc(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(this.currentUrlTree))), this.lastSuccessfulNavigation = this.currentNavigation, this.currentNavigation = null, t.resolve(!0) }, t => { this.console.warn("Unhandled Navigation Error: ") }) } scheduleNavigation(t, e, n, r) { const s = this.getTransition(); if (s && "imperative" !== e && "imperative" === s.source && s.rawUrl.toString() === t.toString()) return Promise.resolve(!0); if (s && "hashchange" == e && "popstate" === s.source && s.rawUrl.toString() === t.toString()) return Promise.resolve(!0); if (s && "popstate" == e && "hashchange" === s.source && s.rawUrl.toString() === t.toString()) return Promise.resolve(!0); let i = null, o = null; const a = new Promise((t, e) => { i = t, o = e }), l = ++this.navigationId; return this.setTransition({ id: l, source: e, restoredState: n, currentUrlTree: this.currentUrlTree, currentRawUrl: this.rawUrlTree, rawUrl: t, extras: r, resolve: i, reject: o, promise: a, currentSnapshot: this.routerState.snapshot, currentRouterState: this.routerState }), a.catch(t => Promise.reject(t)) } setBrowserUrl(t, e, n, r) { const s = this.urlSerializer.serialize(t); r = r || {}, this.location.isCurrentPathEqualTo(s) || e ? this.location.replaceState(s, "", Object.assign({}, r, { navigationId: n })) : this.location.go(s, "", Object.assign({}, r, { navigationId: n })) } resetStateAndUrl(t, e, n) { this.routerState = t, this.currentUrlTree = e, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, n), this.resetUrlToCurrentUrlTree() } resetUrlToCurrentUrlTree() { this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), "", { navigationId: this.lastSuccessfulId }) } } class Mu { constructor() { this.outlet = null, this.route = null, this.resolver = null, this.children = new Lu, this.attachRef = null } } class Lu { constructor() { this.contexts = new Map } onChildOutletCreated(t, e) { const n = this.getOrCreateContext(t); n.outlet = e, this.contexts.set(t, n) } onChildOutletDestroyed(t) { const e = this.getContext(t); e && (e.outlet = null) } onOutletDeactivated() { const t = this.contexts; return this.contexts = new Map, t } onOutletReAttached(t) { this.contexts = t } getOrCreateContext(t) { let e = this.getContext(t); return e || (e = new Mu, this.contexts.set(t, e)), e } getContext(t) { return this.contexts.get(t) || null } } class ju { constructor(t, e, n, r, s) { this.parentContexts = t, this.location = e, this.resolver = n, this.changeDetector = s, this.activated = null, this._activatedRoute = null, this.activateEvents = new ys, this.deactivateEvents = new ys, this.name = r || "primary", t.onChildOutletCreated(this.name, this) } ngOnDestroy() { this.parentContexts.onChildOutletDestroyed(this.name) } ngOnInit() { if (!this.activated) { const t = this.parentContexts.getContext(this.name); t && t.route && (t.attachRef ? this.attach(t.attachRef, t.route) : this.activateWith(t.route, t.resolver || null)) } } get isActivated() { return !!this.activated } get component() { if (!this.activated) throw new Error("Outlet is not activated"); return this.activated.instance } get activatedRoute() { if (!this.activated) throw new Error("Outlet is not activated"); return this._activatedRoute } get activatedRouteData() { return this._activatedRoute ? this._activatedRoute.snapshot.data : {} } detach() { if (!this.activated) throw new Error("Outlet is not activated"); this.location.detach(); const t = this.activated; return this.activated = null, this._activatedRoute = null, t } attach(t, e) { this.activated = t, this._activatedRoute = e, this.location.insert(t.hostView) } deactivate() { if (this.activated) { const t = this.component; this.activated.destroy(), this.activated = null, this._activatedRoute = null, this.deactivateEvents.emit(t) } } activateWith(t, e) { if (this.isActivated) throw new Error("Cannot activate an already activated outlet"); this._activatedRoute = t; const n = (e = e || this.resolver).resolveComponentFactory(t._futureSnapshot.routeConfig.component), r = this.parentContexts.getOrCreateContext(this.name).children, s = new Uu(t, r, this.location.injector); this.activated = this.location.createComponent(n, this.location.length, s), this.changeDetector.markForCheck(), this.activateEvents.emit(this.activated.instance) } } class Uu { constructor(t, e, n) { this.route = t, this.childContexts = e, this.parent = n } get(t, e) { return t === xh ? this.route : t === Lu ? this.childContexts : this.parent.get(t, e) } } class Bu { } class Hu { preload(t, e) { return e().pipe(Za(() => Sa(null))) } } class Vu { preload(t, e) { return Sa(null) } } class zu { constructor(t, e, n, r, s) { this.router = t, this.injector = r, this.preloadingStrategy = s, this.loader = new Ru(e, n, e => t.triggerEvent(new Rc(e)), e => t.triggerEvent(new Pc(e))) } setUpPreloading() { this.subscription = this.router.events.pipe(Ia(t => t instanceof wc), ul(() => this.preload())).subscribe(() => { }) } preload() { const t = this.injector.get(Lt); return this.processRoutes(t, this.router.config) } ngOnDestroy() { this.subscription.unsubscribe() } processRoutes(t, e) { const n = []; for (const r of e) if (r.loadChildren && !r.canLoad && r._loadedConfig) { const t = r._loadedConfig; n.push(this.processRoutes(t.module, t.routes)) } else r.loadChildren && !r.canLoad ? n.push(this.preloadConfig(t, r)) : r.children && n.push(this.processRoutes(t, r.children)); return W(n).pipe(Y(), H(t => { })) } preloadConfig(t, e) { return this.preloadingStrategy.preload(e, () => this.loader.load(t.injector, e).pipe(Q(t => (e._loadedConfig = t, this.processRoutes(t.module, t.routes))))) } } class qu { constructor(t, e, n = {}) { this.router = t, this.viewportScroller = e, this.options = n, this.lastId = 0, this.lastSource = "imperative", this.restoredId = 0, this.store = {}, n.scrollPositionRestoration = n.scrollPositionRestoration || "disabled", n.anchorScrolling = n.anchorScrolling || "disabled" } init() { "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.setHistoryScrollRestoration("manual"), this.routerEventsSubscription = this.createScrollEvents(), this.scrollEventsSubscription = this.consumeScrollEvents() } createScrollEvents() { return this.router.events.subscribe(t => { t instanceof bc ? (this.store[this.lastId] = this.viewportScroller.getScrollPosition(), this.lastSource = t.navigationTrigger, this.restoredId = t.restoredState ? t.restoredState.navigationId : 0) : t instanceof wc && (this.lastId = t.id, this.scheduleScrollEvent(t, this.router.parseUrl(t.urlAfterRedirects).fragment)) }) } consumeScrollEvents() { return this.router.events.subscribe(t => { t instanceof Fc && (t.position ? "top" === this.options.scrollPositionRestoration ? this.viewportScroller.scrollToPosition([0, 0]) : "enabled" === this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition(t.position) : t.anchor && "enabled" === this.options.anchorScrolling ? this.viewportScroller.scrollToAnchor(t.anchor) : "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition([0, 0])) }) } scheduleScrollEvent(t, e) { this.router.triggerEvent(new Fc(t, "popstate" === this.lastSource ? this.store[this.restoredId] : null, e)) } ngOnDestroy() { this.routerEventsSubscription && this.routerEventsSubscription.unsubscribe(), this.scrollEventsSubscription && this.scrollEventsSubscription.unsubscribe() } } const Wu = new Tt("ROUTER_CONFIGURATION"), Qu = new Tt("ROUTER_FORROOT_GUARD"), Ku = [na, { provide: rh, useClass: sh }, { provide: Fu, useFactory: td, deps: [li, rh, Lu, na, ke, hi, Fs, Au, Wu, [Pu, new ct], [Tu, new ct]] }, Lu, { provide: xh, useFactory: ed, deps: [Fu] }, { provide: hi, useClass: pi }, zu, Vu, Hu, { provide: Wu, useValue: { enableTracing: !1 } }]; function Zu() { return new ri("Router", Fu) } class Gu { constructor(t, e) { } static forRoot(t, e) { return { ngModule: Gu, providers: [Ku, Ju(t), { provide: Qu, useFactory: $u, deps: [[Fu, new ct, new ut]] }, { provide: Wu, useValue: e || {} }, { provide: ta, useFactory: Xu, deps: [$o, [new lt(ea), new ct], Wu] }, { provide: qu, useFactory: Yu, deps: [Fu, ya, Wu] }, { provide: Bu, useExisting: e && e.preloadingStrategy ? e.preloadingStrategy : Vu }, { provide: ri, multi: !0, useFactory: Zu }, [nd, { provide: bs, multi: !0, useFactory: rd, deps: [nd] }, { provide: id, useFactory: sd, deps: [nd] }, { provide: ks, multi: !0, useExisting: id }]] } } static forChild(t) { return { ngModule: Gu, providers: [Ju(t)] } } } function Yu(t, e, n) { return n.scrollOffset && e.setOffset(n.scrollOffset), new qu(t, e, n) } function Xu(t, e, n = {}) { return n.useHash ? new sa(t, e) : new ia(t, e) } function $u(t) { if (t) throw new Error("RouterModule.forRoot() called twice. Lazy loaded modules should use RouterModule.forChild() instead."); return "guarded" } function Ju(t) { return [{ provide: Fe, multi: !0, useValue: t }, { provide: Au, multi: !0, useValue: t }] } function td(t, e, n, r, s, i, o, a, l = {}, c, h) { const u = new Fu(null, e, n, r, s, i, o, Kc(a)); if (c && (u.urlHandlingStrategy = c), h && (u.routeReuseStrategy = h), l.errorHandler && (u.errorHandler = l.errorHandler), l.malformedUriErrorHandler && (u.malformedUriErrorHandler = l.malformedUriErrorHandler), l.enableTracing) { const t = ml(); u.events.subscribe(e => { t.logGroup("Router Event: ".concat(e.constructor.name)), t.log(e.toString()), t.log(e), t.logGroupEnd() }) } return l.onSameUrlNavigation && (u.onSameUrlNavigation = l.onSameUrlNavigation), l.paramsInheritanceStrategy && (u.paramsInheritanceStrategy = l.paramsInheritanceStrategy), l.urlUpdateStrategy && (u.urlUpdateStrategy = l.urlUpdateStrategy), l.relativeLinkResolution && (u.relativeLinkResolution = l.relativeLinkResolution), u } function ed(t) { return t.routerState.root } class nd { constructor(t) { this.injector = t, this.initNavigation = !1, this.resultOfPreactivationDone = new k } appInitializer() { return this.injector.get(Jo, Promise.resolve(null)).then(() => { let t = null; const e = new Promise(e => t = e), n = this.injector.get(Fu), r = this.injector.get(Wu); if (this.isLegacyDisabled(r) || this.isLegacyEnabled(r)) t(!0); else if ("disabled" === r.initialNavigation) n.setUpLocationChangeListener(), t(!0); else { if ("enabled" !== r.initialNavigation) throw new Error("Invalid initialNavigation options: '".concat(r.initialNavigation, "'")); n.hooks.afterPreactivation = () => this.initNavigation ? Sa(null) : (this.initNavigation = !0, t(!0), this.resultOfPreactivationDone), n.initialNavigation() } return e }) } bootstrapListener(t) { const e = this.injector.get(Wu), n = this.injector.get(zu), r = this.injector.get(qu), s = this.injector.get(Fu), i = this.injector.get(li); t === i.components[0] && (this.isLegacyEnabled(e) ? s.initialNavigation() : this.isLegacyDisabled(e) && s.setUpLocationChangeListener(), n.setUpPreloading(), r.init(), s.resetRootComponentType(i.componentTypes[0]), this.resultOfPreactivationDone.next(null), this.resultOfPreactivationDone.complete()) } isLegacyEnabled(t) { return "legacy_enabled" === t.initialNavigation || !0 === t.initialNavigation || void 0 === t.initialNavigation } isLegacyDisabled(t) { return "legacy_disabled" === t.initialNavigation || !1 === t.initialNavigation } } function rd(t) { return t.appInitializer.bind(t) } function sd(t) { return t.bootstrapListener.bind(t) } const id = new Tt("Router Initializer"); var od = Vn({ encapsulation: 2, styles: [], data: {} }); function ad(t) { return zi(0, [(t()(), Ai(0, 16777216, null, null, 1, "router-outlet", [], null, null, null, null, null)), $r(1, 212992, null, 0, ju, [Lu, Tn, Ye, [8, null], Ee], null, null)], (function (t, e) { t(e, 1, 0) }), null) } var ld = Ar("ng-component", Mc, (function (t) { return zi(0, [(t()(), Ai(0, 0, null, null, 1, "ng-component", [], null, null, null, ad, od)), $r(1, 49152, null, 0, Mc, [], null, null)], null, null) }), {}, {}, []); class cd { constructor(t, e) { this.route = t, this.service = e, this.index = 0 } ngDoCheck() { } left() { this.index-- } right() { this.index++ } ngOnInit() { this.service.getImg().subscribe(t => this.images = t), this.index = this.service.index } } class hd { } class ud { } class dd { constructor(t) { this.normalizedNames = new Map, this.lazyUpdate = null, t ? this.lazyInit = "string" == typeof t ? () => { this.headers = new Map, t.split("\n").forEach(t => { const e = t.indexOf(":"); if (e > 0) { const n = t.slice(0, e), r = n.toLowerCase(), s = t.slice(e + 1).trim(); this.maybeSetNormalizedName(n, r), this.headers.has(r) ? this.headers.get(r).push(s) : this.headers.set(r, [s]) } }) } : () => { this.headers = new Map, Object.keys(t).forEach(e => { let n = t[e]; const r = e.toLowerCase(); "string" == typeof n && (n = [n]), n.length > 0 && (this.headers.set(r, n), this.maybeSetNormalizedName(e, r)) }) } : this.headers = new Map } has(t) { return this.init(), this.headers.has(t.toLowerCase()) } get(t) { this.init(); const e = this.headers.get(t.toLowerCase()); return e && e.length > 0 ? e[0] : null } keys() { return this.init(), Array.from(this.normalizedNames.values()) } getAll(t) { return this.init(), this.headers.get(t.toLowerCase()) || null } append(t, e) { return this.clone({ name: t, value: e, op: "a" }) } set(t, e) { return this.clone({ name: t, value: e, op: "s" }) } delete(t, e) { return this.clone({ name: t, value: e, op: "d" }) } maybeSetNormalizedName(t, e) { this.normalizedNames.has(e) || this.normalizedNames.set(e, t) } init() { this.lazyInit && (this.lazyInit instanceof dd ? this.copyFrom(this.lazyInit) : this.lazyInit(), this.lazyInit = null, this.lazyUpdate && (this.lazyUpdate.forEach(t => this.applyUpdate(t)), this.lazyUpdate = null)) } copyFrom(t) { t.init(), Array.from(t.headers.keys()).forEach(e => { this.headers.set(e, t.headers.get(e)), this.normalizedNames.set(e, t.normalizedNames.get(e)) }) } clone(t) { const e = new dd; return e.lazyInit = this.lazyInit && this.lazyInit instanceof dd ? this.lazyInit : this, e.lazyUpdate = (this.lazyUpdate || []).concat([t]), e } applyUpdate(t) { const e = t.name.toLowerCase(); switch (t.op) { case "a": case "s": let n = t.value; if ("string" == typeof n && (n = [n]), 0 === n.length) return; this.maybeSetNormalizedName(t.name, e); const r = ("a" === t.op ? this.headers.get(e) : void 0) || []; r.push(...n), this.headers.set(e, r); break; case "d": const s = t.value; if (s) { let t = this.headers.get(e); if (!t) return; t = t.filter(t => -1 === s.indexOf(t)), 0 === t.length ? (this.headers.delete(e), this.normalizedNames.delete(e)) : this.headers.set(e, t) } else this.headers.delete(e), this.normalizedNames.delete(e) } } forEach(t) { this.init(), Array.from(this.normalizedNames.keys()).forEach(e => t(this.normalizedNames.get(e), this.headers.get(e))) } } class pd { encodeKey(t) { return fd(t) } encodeValue(t) { return fd(t) } decodeKey(t) { return decodeURIComponent(t) } decodeValue(t) { return decodeURIComponent(t) } } function fd(t) { return encodeURIComponent(t).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/gi, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%2B/gi, "+").replace(/%3D/gi, "=").replace(/%3F/gi, "?").replace(/%2F/gi, "/") } class md { constructor(t = {}) { if (this.updates = null, this.cloneFrom = null, this.encoder = t.encoder || new pd, t.fromString) { if (t.fromObject) throw new Error("Cannot specify both fromString and fromObject."); this.map = function (t, e) { const n = new Map; return t.length > 0 && t.split("&").forEach(t => { const r = t.indexOf("="), [s, i] = -1 == r ? [e.decodeKey(t), ""] : [e.decodeKey(t.slice(0, r)), e.decodeValue(t.slice(r + 1))], o = n.get(s) || []; o.push(i), n.set(s, o) }), n }(t.fromString, this.encoder) } else t.fromObject ? (this.map = new Map, Object.keys(t.fromObject).forEach(e => { const n = t.fromObject[e]; this.map.set(e, Array.isArray(n) ? n : [n]) })) : this.map = null } has(t) { return this.init(), this.map.has(t) } get(t) { this.init(); const e = this.map.get(t); return e ? e[0] : null } getAll(t) { return this.init(), this.map.get(t) || null } keys() { return this.init(), Array.from(this.map.keys()) } append(t, e) { return this.clone({ param: t, value: e, op: "a" }) } set(t, e) { return this.clone({ param: t, value: e, op: "s" }) } delete(t, e) { return this.clone({ param: t, value: e, op: "d" }) } toString() { return this.init(), this.keys().map(t => { const e = this.encoder.encodeKey(t); return this.map.get(t).map(t => e + "=" + this.encoder.encodeValue(t)).join("&") }).join("&") } clone(t) { const e = new md({ encoder: this.encoder }); return e.cloneFrom = this.cloneFrom || this, e.updates = (this.updates || []).concat([t]), e } init() { null === this.map && (this.map = new Map), null !== this.cloneFrom && (this.cloneFrom.init(), this.cloneFrom.keys().forEach(t => this.map.set(t, this.cloneFrom.map.get(t))), this.updates.forEach(t => { switch (t.op) { case "a": case "s": const e = ("a" === t.op ? this.map.get(t.param) : void 0) || []; e.push(t.value), this.map.set(t.param, e); break; case "d": if (void 0 === t.value) { this.map.delete(t.param); break } { let e = this.map.get(t.param) || []; const n = e.indexOf(t.value); -1 !== n && e.splice(n, 1), e.length > 0 ? this.map.set(t.param, e) : this.map.delete(t.param) } } }), this.cloneFrom = this.updates = null) } } function gd(t) { return "undefined" != typeof ArrayBuffer && t instanceof ArrayBuffer } function yd(t) { return "undefined" != typeof Blob && t instanceof Blob } function _d(t) { return "undefined" != typeof FormData && t instanceof FormData } class vd { constructor(t, e, n, r) { let s; if (this.url = e, this.body = null, this.reportProgress = !1, this.withCredentials = !1, this.responseType = "json", this.method = t.toUpperCase(), function (t) { switch (t) { case "DELETE": case "GET": case "HEAD": case "OPTIONS": case "JSONP": return !1; default: return !0 } }(this.method) || r ? (this.body = void 0 !== n ? n : null, s = r) : s = n, s && (this.reportProgress = !!s.reportProgress, this.withCredentials = !!s.withCredentials, s.responseType && (this.responseType = s.responseType), s.headers && (this.headers = s.headers), s.params && (this.params = s.params)), this.headers || (this.headers = new dd), this.params) { const t = this.params.toString(); if (0 === t.length) this.urlWithParams = e; else { const n = e.indexOf("?"); this.urlWithParams = e + (-1 === n ? "?" : n < e.length - 1 ? "&" : "") + t } } else this.params = new md, this.urlWithParams = e } serializeBody() { return null === this.body ? null : gd(this.body) || yd(this.body) || _d(this.body) || "string" == typeof this.body ? this.body : this.body instanceof md ? this.body.toString() : "object" == typeof this.body || "boolean" == typeof this.body || Array.isArray(this.body) ? JSON.stringify(this.body) : this.body.toString() } detectContentTypeHeader() { return null === this.body ? null : _d(this.body) ? null : yd(this.body) ? this.body.type || null : gd(this.body) ? null : "string" == typeof this.body ? "text/plain" : this.body instanceof md ? "application/x-www-form-urlencoded;charset=UTF-8" : "object" == typeof this.body || "number" == typeof this.body || Array.isArray(this.body) ? "application/json" : null } clone(t = {}) { const e = t.method || this.method, n = t.url || this.url, r = t.responseType || this.responseType, s = void 0 !== t.body ? t.body : this.body, i = void 0 !== t.withCredentials ? t.withCredentials : this.withCredentials, o = void 0 !== t.reportProgress ? t.reportProgress : this.reportProgress; let a = t.headers || this.headers, l = t.params || this.params; return void 0 !== t.setHeaders && (a = Object.keys(t.setHeaders).reduce((e, n) => e.set(n, t.setHeaders[n]), a)), t.setParams && (l = Object.keys(t.setParams).reduce((e, n) => e.set(n, t.setParams[n]), l)), new vd(e, n, s, { params: l, headers: a, reportProgress: o, responseType: r, withCredentials: i }) } } const bd = function () { var t = { Sent: 0, UploadProgress: 1, ResponseHeader: 2, DownloadProgress: 3, Response: 4, User: 5 }; return t[t.Sent] = "Sent", t[t.UploadProgress] = "UploadProgress", t[t.ResponseHeader] = "ResponseHeader", t[t.DownloadProgress] = "DownloadProgress", t[t.Response] = "Response", t[t.User] = "User", t }(); class wd { constructor(t, e = 200, n = "OK") { this.headers = t.headers || new dd, this.status = void 0 !== t.status ? t.status : e, this.statusText = t.statusText || n, this.url = t.url || null, this.ok = this.status >= 200 && this.status < 300 } } class Sd extends wd { constructor(t = {}) { super(t), this.type = bd.ResponseHeader } clone(t = {}) { return new Sd({ headers: t.headers || this.headers, status: void 0 !== t.status ? t.status : this.status, statusText: t.statusText || this.statusText, url: t.url || this.url || void 0 }) } } class Ed extends wd { constructor(t = {}) { super(t), this.type = bd.Response, this.body = void 0 !== t.body ? t.body : null } clone(t = {}) { return new Ed({ body: void 0 !== t.body ? t.body : this.body, headers: t.headers || this.headers, status: void 0 !== t.status ? t.status : this.status, statusText: t.statusText || this.statusText, url: t.url || this.url || void 0 }) } } class Cd extends wd { constructor(t) { super(t, 0, "Unknown Error"), this.name = "HttpErrorResponse", this.ok = !1, this.message = this.status >= 200 && this.status < 300 ? "Http failure during parsing for ".concat(t.url || "(unknown url)") : "Http failure response for ".concat(t.url || "(unknown url)", ": ").concat(t.status, " ").concat(t.statusText), this.error = t.error || null } } function xd(t, e) { return { body: e, headers: t.headers, observe: t.observe, params: t.params, reportProgress: t.reportProgress, responseType: t.responseType, withCredentials: t.withCredentials } } class Td { constructor(t) { this.handler = t } request(t, e, n = {}) { let r; if (t instanceof vd) r = t; else { let s = void 0; s = n.headers instanceof dd ? n.headers : new dd(n.headers); let i = void 0; n.params && (i = n.params instanceof md ? n.params : new md({ fromObject: n.params })), r = new vd(t, e, void 0 !== n.body ? n.body : null, { headers: s, params: i, reportProgress: n.reportProgress, responseType: n.responseType || "json", withCredentials: n.withCredentials }) } const s = Sa(r).pipe(ul(t => this.handler.handle(t))); if (t instanceof vd || "events" === n.observe) return s; const i = s.pipe(Ia(t => t instanceof Ed)); switch (n.observe || "body") { case "body": switch (r.responseType) { case "arraybuffer": return i.pipe(H(t => { if (null !== t.body && !(t.body instanceof ArrayBuffer)) throw new Error("Response is not an ArrayBuffer."); return t.body })); case "blob": return i.pipe(H(t => { if (null !== t.body && !(t.body instanceof Blob)) throw new Error("Response is not a Blob."); return t.body })); case "text": return i.pipe(H(t => { if (null !== t.body && "string" != typeof t.body) throw new Error("Response is not a string."); return t.body })); case "json": default: return i.pipe(H(t => t.body)) }case "response": return i; default: throw new Error("Unreachable: unhandled observe type ".concat(n.observe, "}")) } } delete(t, e = {}) { return this.request("DELETE", t, e) } get(t, e = {}) { return this.request("GET", t, e) } head(t, e = {}) { return this.request("HEAD", t, e) } jsonp(t, e) { return this.request("JSONP", t, { params: (new md).append(e, "JSONP_CALLBACK"), observe: "body", responseType: "json" }) } options(t, e = {}) { return this.request("OPTIONS", t, e) } patch(t, e, n = {}) { return this.request("PATCH", t, xd(n, e)) } post(t, e, n = {}) { return this.request("POST", t, xd(n, e)) } put(t, e, n = {}) { return this.request("PUT", t, xd(n, e)) } } class kd { constructor(t, e) { this.next = t, this.interceptor = e } handle(t) { return this.interceptor.intercept(t, this.next) } } const Ad = new Tt("HTTP_INTERCEPTORS"); class Rd { intercept(t, e) { return e.handle(t) } } const Pd = /^\)\]\}',?\n/; class Id { } class Od { constructor() { } build() { return new XMLHttpRequest } } class Nd { constructor(t) { this.xhrFactory = t } handle(t) { if ("JSONP" === t.method) throw new Error("Attempted to construct Jsonp request without JsonpClientModule installed."); return new w(e => { const n = this.xhrFactory.build(); if (n.open(t.method, t.urlWithParams), t.withCredentials && (n.withCredentials = !0), t.headers.forEach((t, e) => n.setRequestHeader(t, e.join(","))), t.headers.has("Accept") || n.setRequestHeader("Accept", "application/json, text/plain, */*"), !t.headers.has("Content-Type")) { const e = t.detectContentTypeHeader(); null !== e && n.setRequestHeader("Content-Type", e) } if (t.responseType) { const e = t.responseType.toLowerCase(); n.responseType = "json" !== e ? e : "text" } const r = t.serializeBody(); let s = null; const i = () => { if (null !== s) return s; const e = 1223 === n.status ? 204 : n.status, r = n.statusText || "OK", i = new dd(n.getAllResponseHeaders()), o = function (t) { return "responseURL" in t && t.responseURL ? t.responseURL : /^X-Request-URL:/m.test(t.getAllResponseHeaders()) ? t.getResponseHeader("X-Request-URL") : null }(n) || t.url; return s = new Sd({ headers: i, status: e, statusText: r, url: o }), s }, o = () => { let { headers: r, status: s, statusText: o, url: a } = i(), l = null; 204 !== s && (l = void 0 === n.response ? n.responseText : n.response), 0 === s && (s = l ? 200 : 0); let c = s >= 200 && s < 300; if ("json" === t.responseType && "string" == typeof l) { const t = l; l = l.replace(Pd, ""); try { l = "" !== l ? JSON.parse(l) : null } catch (h) { l = t, c && (c = !1, l = { error: h, text: l }) } } c ? (e.next(new Ed({ body: l, headers: r, status: s, statusText: o, url: a || void 0 })), e.complete()) : e.error(new Cd({ error: l, headers: r, status: s, statusText: o, url: a || void 0 })) }, a = t => { const { url: r } = i(), s = new Cd({ error: t, status: n.status || 0, statusText: n.statusText || "Unknown Error", url: r || void 0 }); e.error(s) }; let l = !1; const c = r => { l || (e.next(i()), l = !0); let s = { type: bd.DownloadProgress, loaded: r.loaded }; r.lengthComputable && (s.total = r.total), "text" === t.responseType && n.responseText && (s.partialText = n.responseText), e.next(s) }, h = t => { let n = { type: bd.UploadProgress, loaded: t.loaded }; t.lengthComputable && (n.total = t.total), e.next(n) }; return n.addEventListener("load", o), n.addEventListener("error", a), t.reportProgress && (n.addEventListener("progress", c), null !== r && n.upload && n.upload.addEventListener("progress", h)), n.send(r), e.next({ type: bd.Sent }), () => { n.removeEventListener("error", a), n.removeEventListener("load", o), t.reportProgress && (n.removeEventListener("progress", c), null !== r && n.upload && n.upload.removeEventListener("progress", h)), n.abort() } }) } } const Dd = new Tt("XSRF_COOKIE_NAME"), Fd = new Tt("XSRF_HEADER_NAME"); class Md { } class Ld { constructor(t, e, n) { this.doc = t, this.platform = e, this.cookieName = n, this.lastCookieString = "", this.lastToken = null, this.parseCount = 0 } getToken() { if ("server" === this.platform) return null; const t = this.doc.cookie || ""; return t !== this.lastCookieString && (this.parseCount++, this.lastToken = ha(t, this.cookieName), this.lastCookieString = t), this.lastToken } } class jd { constructor(t, e) { this.tokenService = t, this.headerName = e } intercept(t, e) { const n = t.url.toLowerCase(); if ("GET" === t.method || "HEAD" === t.method || n.startsWith("http://") || n.startsWith("https://")) return e.handle(t); const r = this.tokenService.getToken(); return null === r || t.headers.has(this.headerName) || (t = t.clone({ headers: t.headers.set(this.headerName, r) })), e.handle(t) } } class Ud { constructor(t, e) { this.backend = t, this.injector = e, this.chain = null } handle(t) { if (null === this.chain) { const t = this.injector.get(Ad, []); this.chain = t.reduceRight((t, e) => new kd(t, e), this.backend) } return this.chain.handle(t) } } class Bd { static disable() { return { ngModule: Bd, providers: [{ provide: jd, useClass: Rd }] } } static withOptions(t = {}) { return { ngModule: Bd, providers: [t.cookieName ? { provide: Dd, useValue: t.cookieName } : [], t.headerName ? { provide: Fd, useValue: t.headerName } : []] } } } class Hd { } let Vd = (() => { class t { constructor(t) { this.http = t, this._url = "/assets/images.json" } getImg() { return this.http.get(this._url) } } return t.ngInjectableDef = ft({ factory: function () { return new t(Nt(Td)) }, token: t, providedIn: "root" }), t })(); var zd = Vn({ encapsulation: 0, styles: [[".image[_ngcontent-%COMP%]{width:50%}.box[_ngcontent-%COMP%]{margin-right:20vw;margin-left:20vw}@media only screen and (min-width:992px){.image[_ngcontent-%COMP%]{display:block;max-width:430px;width:auto;height:auto}.swipe[_ngcontent-%COMP%]{text-align:center;display:inline}}@media only screen and (min-width:700px){.image[_ngcontent-%COMP%]{width:60vw}.swipe[_ngcontent-%COMP%]{text-align:center;display:none}}"]], data: {} }); function qd(t) { return zi(0, [(t()(), Ai(0, 0, null, null, 1, "h6", [["class", "swipe"], ["style", "text-align: center;"]], null, null, null, null, null)), (t()(), Bi(-1, null, ["Swipe!"])), (t()(), Ai(2, 0, null, null, 0, "img", [["alt", "..."], ["class", "card-img-top image"]], [[8, "src", 4]], [[null, "swipeleft"], [null, "swiperight"], [null, "keydown.arrowright"], [null, "keydown.arrowleft"]], (function (t, e, n) { var r = !0, s = t.component; return "swipeleft" === e && (r = !1 !== s.left() && r), "swiperight" === e && (r = !1 !== s.right() && r), "keydown.arrowright" === e && (r = !1 !== s.right() && r), "keydown.arrowleft" === e && (r = !1 !== s.left() && r), r }), null, null))], null, (function (t, e) { var n = e.component; t(e, 2, 0, mr(1, "", n.images[n.index].link, "")) })) } var Wd = Ar("app-img", cd, (function (t) { return zi(0, [(t()(), Ai(0, 0, null, null, 1, "app-img", [], null, null, null, qd, zd)), $r(1, 376832, null, 0, cd, [xh, Vd], null, null)], (function (t, e) { t(e, 1, 0) }), null) }), {}, {}, []); class Qd { constructor(t, e, n) { this.service = t, this.dialog = e, this.route = n, this.cols = 3, this.hoverOn = !1, this.showPopover = () => this.hoverOn = !0, this.hidePopover = () => this.hoverOn = !1 } openDialog() { this.service.index = this.index, this.dialog.open(cd) } ngOnInit() { this.service.getImg().subscribe(t => this.images = t) } } class Kd { } function Zd(t, e = null) { return { type: 2, steps: t, options: e } } function Gd(t) { return { type: 6, styles: t, offset: null } } function Yd(t) { Promise.resolve(null).then(t) } class Xd { constructor(t = 0, e = 0) { this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._started = !1, this._destroyed = !1, this._finished = !1, this.parentPlayer = null, this.totalTime = t + e } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = []) } onStart(t) { this._onStartFns.push(t) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } hasStarted() { return this._started } init() { } play() { this.hasStarted() || (this._onStart(), this.triggerMicrotask()), this._started = !0 } triggerMicrotask() { Yd(() => this._onFinish()) } _onStart() { this._onStartFns.forEach(t => t()), this._onStartFns = [] } pause() { } restart() { } finish() { this._onFinish() } destroy() { this._destroyed || (this._destroyed = !0, this.hasStarted() || this._onStart(), this.finish(), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } reset() { } setPosition(t) { } getPosition() { return 0 } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(t => t()), e.length = 0 } } class $d { constructor(t) { this._onDoneFns = [], this._onStartFns = [], this._finished = !1, this._started = !1, this._destroyed = !1, this._onDestroyFns = [], this.parentPlayer = null, this.totalTime = 0, this.players = t; let e = 0, n = 0, r = 0; const s = this.players.length; 0 == s ? Yd(() => this._onFinish()) : this.players.forEach(t => { t.onDone(() => { ++e == s && this._onFinish() }), t.onDestroy(() => { ++n == s && this._onDestroy() }), t.onStart(() => { ++r == s && this._onStart() }) }), this.totalTime = this.players.reduce((t, e) => Math.max(t, e.totalTime), 0) } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = []) } init() { this.players.forEach(t => t.init()) } onStart(t) { this._onStartFns.push(t) } _onStart() { this.hasStarted() || (this._started = !0, this._onStartFns.forEach(t => t()), this._onStartFns = []) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } hasStarted() { return this._started } play() { this.parentPlayer || this.init(), this._onStart(), this.players.forEach(t => t.play()) } pause() { this.players.forEach(t => t.pause()) } restart() { this.players.forEach(t => t.restart()) } finish() { this._onFinish(), this.players.forEach(t => t.finish()) } destroy() { this._onDestroy() } _onDestroy() { this._destroyed || (this._destroyed = !0, this._onFinish(), this.players.forEach(t => t.destroy()), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } reset() { this.players.forEach(t => t.reset()), this._destroyed = !1, this._finished = !1, this._started = !1 } setPosition(t) { const e = t * this.totalTime; this.players.forEach(t => { const n = t.totalTime ? Math.min(1, e / t.totalTime) : 1; t.setPosition(n) }) } getPosition() { let t = 0; return this.players.forEach(e => { const n = e.getPosition(); t = Math.min(n, t) }), t } beforeDestroy() { this.players.forEach(t => { t.beforeDestroy && t.beforeDestroy() }) } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(t => t()), e.length = 0 } } function Jd() { throw Error("Host already has a portal attached") } class tp { attach(t) { return null == t && function () { throw Error("Attempting to attach a portal to a null PortalOutlet") }(), t.hasAttached() && Jd(), this._attachedHost = t, t.attach(this) } detach() { let t = this._attachedHost; null == t ? function () { throw Error("Attempting to detach a portal that is not attached to a host") }() : (this._attachedHost = null, t.detach()) } get isAttached() { return null != this._attachedHost } setAttachedHost(t) { this._attachedHost = t } } class ep extends tp { constructor(t, e, n, r) { super(), this.component = t, this.viewContainerRef = e, this.injector = n, this.componentFactoryResolver = r } } class np extends tp { constructor(t, e, n) { super(), this.templateRef = t, this.viewContainerRef = e, this.context = n } get origin() { return this.templateRef.elementRef } attach(t, e = this.context) { return this.context = e, super.attach(t) } detach() { return this.context = void 0, super.detach() } } class rp { constructor() { this._isDisposed = !1 } hasAttached() { return !!this._attachedPortal } attach(t) { return t || function () { throw Error("Must provide a portal to attach") }(), this.hasAttached() && Jd(), this._isDisposed && function () { throw Error("This PortalOutlet has already been disposed") }(), t instanceof ep ? (this._attachedPortal = t, this.attachComponentPortal(t)) : t instanceof np ? (this._attachedPortal = t, this.attachTemplatePortal(t)) : void function () { throw Error("Attempting to attach an unknown Portal type. BasePortalOutlet accepts either a ComponentPortal or a TemplatePortal.") }() } detach() { this._attachedPortal && (this._attachedPortal.setAttachedHost(null), this._attachedPortal = null), this._invokeDisposeFn() } dispose() { this.hasAttached() && this.detach(), this._invokeDisposeFn(), this._isDisposed = !0 } setDisposeFn(t) { this._disposeFn = t } _invokeDisposeFn() { this._disposeFn && (this._disposeFn(), this._disposeFn = null) } } class sp extends rp { constructor(t, e, n, r) { super(), this.outletElement = t, this._componentFactoryResolver = e, this._appRef = n, this._defaultInjector = r } attachComponentPortal(t) { const e = (t.componentFactoryResolver || this._componentFactoryResolver).resolveComponentFactory(t.component); let n; return t.viewContainerRef ? (n = t.viewContainerRef.createComponent(e, t.viewContainerRef.length, t.injector || t.viewContainerRef.injector), this.setDisposeFn(() => n.destroy())) : (n = e.create(t.injector || this._defaultInjector), this._appRef.attachView(n.hostView), this.setDisposeFn(() => { this._appRef.detachView(n.hostView), n.destroy() })), this.outletElement.appendChild(this._getComponentRootNode(n)), n } attachTemplatePortal(t) { let e = t.viewContainerRef, n = e.createEmbeddedView(t.templateRef, t.context); return n.detectChanges(), n.rootNodes.forEach(t => this.outletElement.appendChild(t)), this.setDisposeFn(() => { let t = e.indexOf(n); -1 !== t && e.remove(t) }), n } dispose() { super.dispose(), null != this.outletElement.parentNode && this.outletElement.parentNode.removeChild(this.outletElement) } _getComponentRootNode(t) { return t.hostView.rootNodes[0] } } class ip extends rp { constructor(t, e) { super(), this._componentFactoryResolver = t, this._viewContainerRef = e, this._isInitialized = !1, this.attached = new ys } get portal() { return this._attachedPortal } set portal(t) { (!this.hasAttached() || t || this._isInitialized) && (this.hasAttached() && super.detach(), t && super.attach(t), this._attachedPortal = t) } get attachedRef() { return this._attachedRef } ngOnInit() { this._isInitialized = !0 } ngOnDestroy() { super.dispose(), this._attachedPortal = null, this._attachedRef = null } attachComponentPortal(t) { t.setAttachedHost(this); const e = null != t.viewContainerRef ? t.viewContainerRef : this._viewContainerRef, n = (t.componentFactoryResolver || this._componentFactoryResolver).resolveComponentFactory(t.component), r = e.createComponent(n, e.length, t.injector || e.injector); return super.setDisposeFn(() => r.destroy()), this._attachedPortal = t, this._attachedRef = r, this.attached.emit(r), r } attachTemplatePortal(t) { t.setAttachedHost(this); const e = this._viewContainerRef.createEmbeddedView(t.templateRef, t.context); return super.setDisposeFn(() => this._viewContainerRef.clear()), this._attachedPortal = t, this._attachedRef = e, this.attached.emit(e), e } } class op { } class ap { constructor(t, e) { this._parentInjector = t, this._customTokens = e } get(t, e) { const n = this._customTokens.get(t); return void 0 !== n ? n : this._parentInjector.get(t, e) } } const lp = new Tt("cdk-dir-doc", { providedIn: "root", factory: function () { return Dt(ma) } }); let cp = (() => { class t { constructor(t) { if (this.value = "ltr", this.change = new ys, t) { const e = t.documentElement ? t.documentElement.dir : null, n = (t.body ? t.body.dir : null) || e; this.value = "ltr" === n || "rtl" === n ? n : "ltr" } } ngOnDestroy() { this.change.complete() } } return t.ngInjectableDef = ft({ factory: function () { return new t(Nt(lp, 8)) }, token: t, providedIn: "root" }), t })(); class hp { } function up(t) { return Array.isArray(t) ? t : [t] } function dp(t) { return null == t ? "" : "string" == typeof t ? t : "".concat(t, "px") } function pp(t, e, n, s) { return r(n) && (s = n, n = void 0), s ? pp(t, e, n).pipe(H(t => l(t) ? s(...t) : s(t))) : new w(r => { !function t(e, n, r, s, i) { let o; if (function (t) { return t && "function" == typeof t.addEventListener && "function" == typeof t.removeEventListener }(e)) { const t = e; e.addEventListener(n, r, i), o = () => t.removeEventListener(n, r, i) } else if (function (t) { return t && "function" == typeof t.on && "function" == typeof t.off }(e)) { const t = e; e.on(n, r), o = () => t.off(n, r) } else if (function (t) { return t && "function" == typeof t.addListener && "function" == typeof t.removeListener }(e)) { const t = e; e.addListener(n, r), o = () => t.removeListener(n, r) } else { if (!e || !e.length) throw new TypeError("Invalid event target"); for (let o = 0, a = e.length; o < a; o++)t(e[o], n, r, s, i) } s.add(o) }(t, e, (function (t) { r.next(arguments.length > 1 ? Array.prototype.slice.call(arguments) : t) }), r, n) }) } class fp extends d { constructor(t, e) { super() } schedule(t, e = 0) { return this } } let mp = (() => { class t { constructor(e, n = t.now) { this.SchedulerAction = e, this.now = n } schedule(t, e = 0, n) { return new this.SchedulerAction(this, t).schedule(n, e) } } return t.now = () => Date.now(), t })(); class gp extends mp { constructor(t, e = mp.now) { super(t, () => gp.delegate && gp.delegate !== this ? gp.delegate.now() : e()), this.actions = [], this.active = !1, this.scheduled = void 0 } schedule(t, e = 0, n) { return gp.delegate && gp.delegate !== this ? gp.delegate.schedule(t, e, n) : super.schedule(t, e, n) } flush(t) { const { actions: e } = this; if (this.active) return void e.push(t); let n; this.active = !0; do { if (n = t.execute(t.state, t.delay)) break } while (t = e.shift()); if (this.active = !1, n) { for (; t = e.shift();)t.unsubscribe(); throw n } } } const yp = new gp(class extends fp { constructor(t, e) { super(t, e), this.scheduler = t, this.work = e, this.pending = !1 } schedule(t, e = 0) { if (this.closed) return this; this.state = t; const n = this.id, r = this.scheduler; return null != n && (this.id = this.recycleAsyncId(r, n, e)), this.pending = !0, this.delay = e, this.id = this.id || this.requestAsyncId(r, this.id, e), this } requestAsyncId(t, e, n = 0) { return setInterval(t.flush.bind(t, this), n) } recycleAsyncId(t, e, n = 0) { if (null !== n && this.delay === n && !1 === this.pending) return e; clearInterval(e) } execute(t, e) { if (this.closed) return new Error("executing a cancelled action"); this.pending = !1; const n = this._execute(t, e); if (n) return n; !1 === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null)) } _execute(t, e) { let n = !1, r = void 0; try { this.work(t) } catch (s) { n = !0, r = !!s && s || new Error(s) } if (n) return this.unsubscribe(), r } _unsubscribe() { const t = this.id, e = this.scheduler, n = e.actions, r = n.indexOf(this); this.work = null, this.state = null, this.pending = !1, this.scheduler = null, -1 !== r && n.splice(r, 1), null != t && (this.id = this.recycleAsyncId(e, t, null)), this.delay = null } }); class _p { constructor(t) { this.durationSelector = t } call(t, e) { return e.subscribe(new vp(t, this.durationSelector)) } } class vp extends B { constructor(t, e) { super(t), this.durationSelector = e, this.hasValue = !1 } _next(t) { if (this.value = t, this.hasValue = !0, !this.throttled) { let n; try { const { durationSelector: e } = this; n = e(t) } catch (e) { return this.destination.error(e) } const r = U(this, n); !r || r.closed ? this.clearThrottle() : this.add(this.throttled = r) } } clearThrottle() { const { value: t, hasValue: e, throttled: n } = this; n && (this.remove(n), this.throttled = null, n.unsubscribe()), e && (this.value = null, this.hasValue = !1, this.destination.next(t)) } notifyNext(t, e, n, r) { this.clearThrottle() } notifyComplete() { this.clearThrottle() } } function bp(t) { return !l(t) && t - parseFloat(t) + 1 >= 0 } function wp(t) { const { index: e, period: n, subscriber: r } = t; if (r.next(e), !r.closed) { if (-1 === n) return r.complete(); t.index = e + 1, this.schedule(t, n) } } function Sp(t, e = yp) { return n = () => function (t = 0, e, n) { let r = -1; return bp(e) ? r = Number(e) < 1 ? 1 : Number(e) : R(e) && (n = e), R(n) || (n = yp), new w(e => { const s = bp(t) ? t : +t - n.now(); return n.schedule(wp, s, { index: 0, period: r, subscriber: e }) }) }(t, e), function (t) { return t.lift(new _p(n)) }; var n } class Ep { constructor(t) { this.notifier = t } call(t, e) { const n = new Cp(t), r = U(n, this.notifier); return r && !n.seenValue ? (n.add(r), e.subscribe(n)) : n } } class Cp extends B { constructor(t) { super(t), this.seenValue = !1 } notifyNext(t, e, n, r, s) { this.seenValue = !0, this.complete() } notifyComplete() { } } function xp(t, e) { return new w(e ? n => e.schedule(Tp, 0, { error: t, subscriber: n }) : e => e.error(t)) } function Tp({ error: t, subscriber: e }) { e.error(t) } let kp, Ap = (() => { class t { constructor(t, e, n) { this.kind = t, this.value = e, this.error = n, this.hasValue = "N" === t } observe(t) { switch (this.kind) { case "N": return t.next && t.next(this.value); case "E": return t.error && t.error(this.error); case "C": return t.complete && t.complete() } } do(t, e, n) { switch (this.kind) { case "N": return t && t(this.value); case "E": return e && e(this.error); case "C": return n && n() } } accept(t, e, n) { return t && "function" == typeof t.next ? this.observe(t) : this.do(t, e, n) } toObservable() { switch (this.kind) { case "N": return Sa(this.value); case "E": return xp(this.error); case "C": return ba() }throw new Error("unexpected notification kind value") } static createNext(e) { return void 0 !== e ? new t("N", e) : t.undefinedValueNotification } static createError(e) { return new t("E", void 0, e) } static createComplete() { return t.completeNotification } } return t.completeNotification = new t("C"), t.undefinedValueNotification = new t("N", void 0), t })(); try { kp = "undefined" != typeof Intl && Intl.v8BreakIterator } catch (Dy) { kp = !1 } let Rp = (() => { class t { constructor(t) { this._platformId = t, this.isBrowser = this._platformId ? ga(this._platformId) : "object" == typeof document && !!document, this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent), this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent), this.BLINK = this.isBrowser && !(!window.chrome && !kp) && "undefined" != typeof CSS && !this.EDGE && !this.TRIDENT, this.WEBKIT = this.isBrowser && /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT, this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !("MSStream" in window), this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent), this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT, this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT } } return t.ngInjectableDef = ft({ factory: function () { return new t(Nt(Ts, 8)) }, token: t, providedIn: "root" }), t })(); class Pp { } let Ip = (() => { class t { constructor(t, e) { this._ngZone = t, this._platform = e, this._scrolled = new k, this._globalSubscription = null, this._scrolledCount = 0, this.scrollContainers = new Map } register(t) { this.scrollContainers.has(t) || this.scrollContainers.set(t, t.elementScrolled().subscribe(() => this._scrolled.next(t))) } deregister(t) { const e = this.scrollContainers.get(t); e && (e.unsubscribe(), this.scrollContainers.delete(t)) } scrolled(t = 20) { return this._platform.isBrowser ? new w(e => { this._globalSubscription || this._addGlobalListener(); const n = t > 0 ? this._scrolled.pipe(Sp(t)).subscribe(e) : this._scrolled.subscribe(e); return this._scrolledCount++, () => { n.unsubscribe(), this._scrolledCount--, this._scrolledCount || this._removeGlobalListener() } }) : Sa() } ngOnDestroy() { this._removeGlobalListener(), this.scrollContainers.forEach((t, e) => this.deregister(e)), this._scrolled.complete() } ancestorScrolled(t, e) { const n = this.getAncestorScrollContainers(t); return this.scrolled(e).pipe(Ia(t => !t || n.indexOf(t) > -1)) } getAncestorScrollContainers(t) { const e = []; return this.scrollContainers.forEach((n, r) => { this._scrollableContainsElement(r, t) && e.push(r) }), e } _scrollableContainsElement(t, e) { let n = e.nativeElement, r = t.getElementRef().nativeElement; do { if (n == r) return !0 } while (n = n.parentElement); return !1 } _addGlobalListener() { this._globalSubscription = this._ngZone.runOutsideAngular(() => pp(window.document, "scroll").subscribe(() => this._scrolled.next())) } _removeGlobalListener() { this._globalSubscription && (this._globalSubscription.unsubscribe(), this._globalSubscription = null) } } return t.ngInjectableDef = ft({ factory: function () { return new t(Nt(Ws), Nt(Rp)) }, token: t, providedIn: "root" }), t })(); class Op { } let Np = (() => { class t { constructor(t, e) { this._platform = t, e.runOutsideAngular(() => { this._change = t.isBrowser ? X(pp(window, "resize"), pp(window, "orientationchange")) : Sa(), this._invalidateCache = this.change().subscribe(() => this._updateViewportSize()) }) } ngOnDestroy() { this._invalidateCache.unsubscribe() } getViewportSize() { this._viewportSize || this._updateViewportSize(); const t = { width: this._viewportSize.width, height: this._viewportSize.height }; return this._platform.isBrowser || (this._viewportSize = null), t } getViewportRect() { const t = this.getViewportScrollPosition(), { width: e, height: n } = this.getViewportSize(); return { top: t.top, left: t.left, bottom: t.top + n, right: t.left + e, height: n, width: e } } getViewportScrollPosition() { if (!this._platform.isBrowser) return { top: 0, left: 0 }; const t = document.documentElement, e = t.getBoundingClientRect(); return { top: -e.top || document.body.scrollTop || window.scrollY || t.scrollTop || 0, left: -e.left || document.body.scrollLeft || window.scrollX || t.scrollLeft || 0 } } change(t = 20) { return t > 0 ? this._change.pipe(Sp(t)) : this._change } _updateViewportSize() { this._viewportSize = this._platform.isBrowser ? { width: window.innerWidth, height: window.innerHeight } : { width: 0, height: 0 } } } return t.ngInjectableDef = ft({ factory: function () { return new t(Nt(Rp), Nt(Ws)) }, token: t, providedIn: "root" }), t })(); class Dp { constructor(t, e) { this._viewportRuler = t, this._previousHTMLStyles = { top: "", left: "" }, this._isEnabled = !1, this._document = e } attach() { } enable() { if (this._canBeEnabled()) { const t = this._document.documentElement; this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition(), this._previousHTMLStyles.left = t.style.left || "", this._previousHTMLStyles.top = t.style.top || "", t.style.left = dp(-this._previousScrollPosition.left), t.style.top = dp(-this._previousScrollPosition.top), t.classList.add("cdk-global-scrollblock"), this._isEnabled = !0 } } disable() { if (this._isEnabled) { const t = this._document.documentElement, e = t.style, n = this._document.body.style, r = e.scrollBehavior || "", s = n.scrollBehavior || ""; this._isEnabled = !1, e.left = this._previousHTMLStyles.left, e.top = this._previousHTMLStyles.top, t.classList.remove("cdk-global-scrollblock"), e.scrollBehavior = n.scrollBehavior = "auto", window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top), e.scrollBehavior = r, n.scrollBehavior = s } } _canBeEnabled() { if (this._document.documentElement.classList.contains("cdk-global-scrollblock") || this._isEnabled) return !1; const t = this._document.body, e = this._viewportRuler.getViewportSize(); return t.scrollHeight > e.height || t.scrollWidth > e.width } } function Fp() { return Error("Scroll strategy has already been attached.") } class Mp { constructor(t, e, n, r) { this._scrollDispatcher = t, this._ngZone = e, this._viewportRuler = n, this._config = r, this._scrollSubscription = null, this._detach = () => { this.disable(), this._overlayRef.hasAttached() && this._ngZone.run(() => this._overlayRef.detach()) } } attach(t) { if (this._overlayRef) throw Fp(); this._overlayRef = t } enable() { if (this._scrollSubscription) return; const t = this._scrollDispatcher.scrolled(0); this._config && this._config.threshold && this._config.threshold > 1 ? (this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top, this._scrollSubscription = t.subscribe(() => { const t = this._viewportRuler.getViewportScrollPosition().top; Math.abs(t - this._initialScrollPosition) > this._config.threshold ? this._detach() : this._overlayRef.updatePosition() })) : this._scrollSubscription = t.subscribe(this._detach) } disable() { this._scrollSubscription && (this._scrollSubscription.unsubscribe(), this._scrollSubscription = null) } detach() { this.disable(), this._overlayRef = null } } class Lp { enable() { } disable() { } attach() { } } function jp(t, e) { return e.some(e => t.bottom < e.top || t.top > e.bottom || t.right < e.left || t.left > e.right) } function Up(t, e) { return e.some(e => t.top < e.top || t.bottom > e.bottom || t.left < e.left || t.right > e.right) } class Bp { constructor(t, e, n, r) { this._scrollDispatcher = t, this._viewportRuler = e, this._ngZone = n, this._config = r, this._scrollSubscription = null } attach(t) { if (this._overlayRef) throw Fp(); this._overlayRef = t } enable() { this._scrollSubscription || (this._scrollSubscription = this._scrollDispatcher.scrolled(this._config ? this._config.scrollThrottle : 0).subscribe(() => { if (this._overlayRef.updatePosition(), this._config && this._config.autoClose) { const t = this._overlayRef.overlayElement.getBoundingClientRect(), { width: e, height: n } = this._viewportRuler.getViewportSize(); jp(t, [{ width: e, height: n, bottom: n, right: e, top: 0, left: 0 }]) && (this.disable(), this._ngZone.run(() => this._overlayRef.detach())) } })) } disable() { this._scrollSubscription && (this._scrollSubscription.unsubscribe(), this._scrollSubscription = null) } detach() { this.disable(), this._overlayRef = null } } let Hp = (() => { class t { constructor(t, e, n, r) { this._scrollDispatcher = t, this._viewportRuler = e, this._ngZone = n, this.noop = () => new Lp, this.close = t => new Mp(this._scrollDispatcher, this._ngZone, this._viewportRuler, t), this.block = () => new Dp(this._viewportRuler, this._document), this.reposition = t => new Bp(this._scrollDispatcher, this._viewportRuler, this._ngZone, t), this._document = r } } return t.ngInjectableDef = ft({ factory: function () { return new t(Nt(Ip), Nt(Np), Nt(Ws), Nt(ma)) }, token: t, providedIn: "root" }), t })(); class Vp { constructor(t) { if (this.scrollStrategy = new Lp, this.panelClass = "", this.hasBackdrop = !1, this.backdropClass = "cdk-overlay-dark-backdrop", this.disposeOnNavigation = !1, t) { const e = Object.keys(t); for (const n of e) void 0 !== t[n] && (this[n] = t[n]) } } } class zp { constructor(t, e, n, r, s) { this.offsetX = n, this.offsetY = r, this.panelClass = s, this.originX = t.originX, this.originY = t.originY, this.overlayX = e.overlayX, this.overlayY = e.overlayY } } class qp { constructor(t, e) { this.connectionPair = t, this.scrollableViewProperties = e } } function Wp(t, e) { if ("top" !== e && "bottom" !== e && "center" !== e) throw Error("ConnectedPosition: Invalid ".concat(t, ' "').concat(e, '". ') + 'Expected "top", "bottom" or "center".') } function Qp(t, e) { if ("start" !== e && "end" !== e && "center" !== e) throw Error("ConnectedPosition: Invalid ".concat(t, ' "').concat(e, '". ') + 'Expected "start", "end" or "center".') } let Kp = (() => { class t { constructor(t) { this._attachedOverlays = [], this._keydownListener = t => { const e = this._attachedOverlays; for (let n = e.length - 1; n > -1; n--)if (e[n]._keydownEventSubscriptions > 0) { e[n]._keydownEvents.next(t); break } }, this._document = t } ngOnDestroy() { this._detach() } add(t) { this.remove(t), this._isAttached || (this._document.body.addEventListener("keydown", this._keydownListener), this._isAttached = !0), this._attachedOverlays.push(t) } remove(t) { const e = this._attachedOverlays.indexOf(t); e > -1 && this._attachedOverlays.splice(e, 1), 0 === this._attachedOverlays.length && this._detach() } _detach() { this._isAttached && (this._document.body.removeEventListener("keydown", this._keydownListener), this._isAttached = !1) } } return t.ngInjectableDef = ft({ factory: function () { return new t(Nt(ma)) }, token: t, providedIn: "root" }), t })(), Zp = (() => { class t { constructor(t) { this._document = t } ngOnDestroy() { this._containerElement && this._containerElement.parentNode && this._containerElement.parentNode.removeChild(this._containerElement) } getContainerElement() { return this._containerElement || this._createContainer(), this._containerElement } _createContainer() { const t = this._document.getElementsByClassName("cdk-overlay-container"); for (let n = 0; n < t.length; n++)t[n].parentNode.removeChild(t[n]); const e = this._document.createElement("div"); e.classList.add("cdk-overlay-container"), this._document.body.appendChild(e), this._containerElement = e } } return t.ngInjectableDef = ft({ factory: function () { return new t(Nt(ma)) }, token: t, providedIn: "root" }), t })(); class Gp { constructor(t, e, n, r, s, i, o, a) { this._portalOutlet = t, this._host = e, this._pane = n, this._config = r, this._ngZone = s, this._keyboardDispatcher = i, this._document = o, this._location = a, this._backdropElement = null, this._backdropClick = new k, this._attachments = new k, this._detachments = new k, this._locationChanges = d.EMPTY, this._backdropClickHandler = t => this._backdropClick.next(t), this._keydownEventsObservable = new w(t => { const e = this._keydownEvents.subscribe(t); return this._keydownEventSubscriptions++, () => { e.unsubscribe(), this._keydownEventSubscriptions-- } }), this._keydownEvents = new k, this._keydownEventSubscriptions = 0, r.scrollStrategy && (this._scrollStrategy = r.scrollStrategy, this._scrollStrategy.attach(this)), this._positionStrategy = r.positionStrategy } get overlayElement() { return this._pane } get backdropElement() { return this._backdropElement } get hostElement() { return this._host } attach(t) { let e = this._portalOutlet.attach(t); return this._positionStrategy && this._positionStrategy.attach(this), !this._host.parentElement && this._previousHostParent && this._previousHostParent.appendChild(this._host), this._updateStackingOrder(), this._updateElementSize(), this._updateElementDirection(), this._scrollStrategy && this._scrollStrategy.enable(), this._ngZone.onStable.asObservable().pipe(Xa(1)).subscribe(() => { this.hasAttached() && this.updatePosition() }), this._togglePointerEvents(!0), this._config.hasBackdrop && this._attachBackdrop(), this._config.panelClass && this._toggleClasses(this._pane, this._config.panelClass, !0), this._attachments.next(), this._keyboardDispatcher.add(this), this._config.disposeOnNavigation && this._location && (this._locationChanges = this._location.subscribe(() => this.dispose())), e } detach() { if (!this.hasAttached()) return; this.detachBackdrop(), this._togglePointerEvents(!1), this._positionStrategy && this._positionStrategy.detach && this._positionStrategy.detach(), this._scrollStrategy && this._scrollStrategy.disable(); const t = this._portalOutlet.detach(); return this._detachments.next(), this._keyboardDispatcher.remove(this), this._detachContentWhenStable(), this._locationChanges.unsubscribe(), t } dispose() { const t = this.hasAttached(); this._positionStrategy && this._positionStrategy.dispose(), this._disposeScrollStrategy(), this.detachBackdrop(), this._locationChanges.unsubscribe(), this._keyboardDispatcher.remove(this), this._portalOutlet.dispose(), this._attachments.complete(), this._backdropClick.complete(), this._keydownEvents.complete(), this._host && this._host.parentNode && (this._host.parentNode.removeChild(this._host), this._host = null), this._previousHostParent = this._pane = null, t && this._detachments.next(), this._detachments.complete() } hasAttached() { return this._portalOutlet.hasAttached() } backdropClick() { return this._backdropClick.asObservable() } attachments() { return this._attachments.asObservable() } detachments() { return this._detachments.asObservable() } keydownEvents() { return this._keydownEventsObservable } getConfig() { return this._config } updatePosition() { this._positionStrategy && this._positionStrategy.apply() } updatePositionStrategy(t) { t !== this._positionStrategy && (this._positionStrategy && this._positionStrategy.dispose(), this._positionStrategy = t, this.hasAttached() && (t.attach(this), this.updatePosition())) } updateSize(t) { this._config = Object.assign({}, this._config, t), this._updateElementSize() } setDirection(t) { this._config = Object.assign({}, this._config, { direction: t }), this._updateElementDirection() } addPanelClass(t) { this._pane && this._toggleClasses(this._pane, t, !0) } removePanelClass(t) { this._pane && this._toggleClasses(this._pane, t, !1) } getDirection() { const t = this._config.direction; return t ? "string" == typeof t ? t : t.value : "ltr" } updateScrollStrategy(t) { t !== this._scrollStrategy && (this._disposeScrollStrategy(), this._scrollStrategy = t, this.hasAttached() && (t.attach(this), t.enable())) } _updateElementDirection() { this._host.setAttribute("dir", this.getDirection()) } _updateElementSize() { if (!this._pane) return; const t = this._pane.style; t.width = dp(this._config.width), t.height = dp(this._config.height), t.minWidth = dp(this._config.minWidth), t.minHeight = dp(this._config.minHeight), t.maxWidth = dp(this._config.maxWidth), t.maxHeight = dp(this._config.maxHeight) } _togglePointerEvents(t) { this._pane.style.pointerEvents = t ? "auto" : "none" } _attachBackdrop() { this._backdropElement = this._document.createElement("div"), this._backdropElement.classList.add("cdk-overlay-backdrop"), this._config.backdropClass && this._toggleClasses(this._backdropElement, this._config.backdropClass, !0), this._host.parentElement.insertBefore(this._backdropElement, this._host), this._backdropElement.addEventListener("click", this._backdropClickHandler), "undefined" != typeof requestAnimationFrame ? this._ngZone.runOutsideAngular(() => { requestAnimationFrame(() => { this._backdropElement && this._backdropElement.classList.add("cdk-overlay-backdrop-showing") }) }) : this._backdropElement.classList.add("cdk-overlay-backdrop-showing") } _updateStackingOrder() { this._host.nextSibling && this._host.parentNode.appendChild(this._host) } detachBackdrop() { let t, e = this._backdropElement; if (!e) return; let n = () => { e && (e.removeEventListener("click", this._backdropClickHandler), e.removeEventListener("transitionend", n), e.parentNode && e.parentNode.removeChild(e)), this._backdropElement == e && (this._backdropElement = null), this._config.backdropClass && this._toggleClasses(e, this._config.backdropClass, !1), clearTimeout(t) }; e.classList.remove("cdk-overlay-backdrop-showing"), this._ngZone.runOutsideAngular(() => { e.addEventListener("transitionend", n) }), e.style.pointerEvents = "none", t = this._ngZone.runOutsideAngular(() => setTimeout(n, 500)) } _toggleClasses(t, e, n) { const r = t.classList; up(e).forEach(t => { t && (n ? r.add(t) : r.remove(t)) }) } _detachContentWhenStable() { this._ngZone.runOutsideAngular(() => { const t = this._ngZone.onStable.asObservable().pipe((e = X(this._attachments, this._detachments), t => t.lift(new Ep(e)))).subscribe(() => { this._pane && this._host && 0 !== this._pane.children.length || (this._pane && this._config.panelClass && this._toggleClasses(this._pane, this._config.panelClass, !1), this._host && this._host.parentElement && (this._previousHostParent = this._host.parentElement, this._previousHostParent.removeChild(this._host)), t.unsubscribe()) }); var e }) } _disposeScrollStrategy() { const t = this._scrollStrategy; t && (t.disable(), t.detach && t.detach()) } } class Yp { constructor(t, e, n, r, s) { this._viewportRuler = e, this._document = n, this._platform = r, this._overlayContainer = s, this._lastBoundingBoxSize = { width: 0, height: 0 }, this._isPushed = !1, this._canPush = !0, this._growAfterOpen = !1, this._hasFlexibleDimensions = !0, this._positionLocked = !1, this._viewportMargin = 0, this._scrollables = [], this._preferredPositions = [], this._positionChanges = new k, this._resizeSubscription = d.EMPTY, this._offsetX = 0, this._offsetY = 0, this._appliedPanelClasses = [], this.positionChanges = this._positionChanges.asObservable(), this.setOrigin(t) } get positions() { return this._preferredPositions } attach(t) { if (this._overlayRef && t !== this._overlayRef) throw Error("This position strategy is already attached to an overlay"); this._validatePositions(), t.hostElement.classList.add("cdk-overlay-connected-position-bounding-box"), this._overlayRef = t, this._boundingBox = t.hostElement, this._pane = t.overlayElement, this._isDisposed = !1, this._isInitialRender = !0, this._lastPosition = null, this._resizeSubscription.unsubscribe(), this._resizeSubscription = this._viewportRuler.change().subscribe(() => { this._isInitialRender = !0, this.apply() }) } apply() { if (this._isDisposed || !this._platform.isBrowser) return; if (!this._isInitialRender && this._positionLocked && this._lastPosition) return void this.reapplyLastPosition(); this._clearPanelClasses(), this._resetOverlayElementStyles(), this._resetBoundingBoxStyles(), this._viewportRect = this._getNarrowedViewportRect(), this._originRect = this._getOriginRect(), this._overlayRect = this._pane.getBoundingClientRect(); const t = this._originRect, e = this._overlayRect, n = this._viewportRect, r = []; let s; for (let i of this._preferredPositions) { let o = this._getOriginPoint(t, i), a = this._getOverlayPoint(o, e, i), l = this._getOverlayFit(a, e, n, i); if (l.isCompletelyWithinViewport) return this._isPushed = !1, void this._applyPosition(i, o); this._canFitWithFlexibleDimensions(l, a, n) ? r.push({ position: i, origin: o, overlayRect: e, boundingBoxRect: this._calculateBoundingBoxRect(o, i) }) : (!s || s.overlayFit.visibleArea < l.visibleArea) && (s = { overlayFit: l, overlayPoint: a, originPoint: o, position: i, overlayRect: e }) } if (r.length) { let t = null, e = -1; for (const n of r) { const r = n.boundingBoxRect.width * n.boundingBoxRect.height * (n.position.weight || 1); r > e && (e = r, t = n) } return this._isPushed = !1, void this._applyPosition(t.position, t.origin) } if (this._canPush) return this._isPushed = !0, void this._applyPosition(s.position, s.originPoint); this._applyPosition(s.position, s.originPoint) } detach() { this._clearPanelClasses(), this._lastPosition = null, this._previousPushAmount = null, this._resizeSubscription.unsubscribe() } dispose() { this._isDisposed || (this._boundingBox && Xp(this._boundingBox.style, { top: "", left: "", right: "", bottom: "", height: "", width: "", alignItems: "", justifyContent: "" }), this._pane && this._resetOverlayElementStyles(), this._overlayRef && this._overlayRef.hostElement.classList.remove("cdk-overlay-connected-position-bounding-box"), this.detach(), this._positionChanges.complete(), this._overlayRef = this._boundingBox = null, this._isDisposed = !0) } reapplyLastPosition() { if (!this._isDisposed && (!this._platform || this._platform.isBrowser)) { this._originRect = this._getOriginRect(), this._overlayRect = this._pane.getBoundingClientRect(), this._viewportRect = this._getNarrowedViewportRect(); const t = this._lastPosition || this._preferredPositions[0], e = this._getOriginPoint(this._originRect, t); this._applyPosition(t, e) } } withScrollableContainers(t) { return this._scrollables = t, this } withPositions(t) { return this._preferredPositions = t, -1 === t.indexOf(this._lastPosition) && (this._lastPosition = null), this._validatePositions(), this } withViewportMargin(t) { return this._viewportMargin = t, this } withFlexibleDimensions(t = !0) { return this._hasFlexibleDimensions = t, this } withGrowAfterOpen(t = !0) { return this._growAfterOpen = t, this } withPush(t = !0) { return this._canPush = t, this } withLockedPosition(t = !0) { return this._positionLocked = t, this } setOrigin(t) { return this._origin = t, this } withDefaultOffsetX(t) { return this._offsetX = t, this } withDefaultOffsetY(t) { return this._offsetY = t, this } withTransformOriginOn(t) { return this._transformOriginSelector = t, this } _getOriginPoint(t, e) { let n, r; if ("center" == e.originX) n = t.left + t.width / 2; else { const r = this._isRtl() ? t.right : t.left, s = this._isRtl() ? t.left : t.right; n = "start" == e.originX ? r : s } return r = "center" == e.originY ? t.top + t.height / 2 : "top" == e.originY ? t.top : t.bottom, { x: n, y: r } } _getOverlayPoint(t, e, n) { let r, s; return r = "center" == n.overlayX ? -e.width / 2 : "start" === n.overlayX ? this._isRtl() ? -e.width : 0 : this._isRtl() ? 0 : -e.width, s = "center" == n.overlayY ? -e.height / 2 : "top" == n.overlayY ? 0 : -e.height, { x: t.x + r, y: t.y + s } } _getOverlayFit(t, e, n, r) { let { x: s, y: i } = t, o = this._getOffset(r, "x"), a = this._getOffset(r, "y"); o && (s += o), a && (i += a); let l = 0 - i, c = i + e.height - n.height, h = this._subtractOverflows(e.width, 0 - s, s + e.width - n.width), u = this._subtractOverflows(e.height, l, c), d = h * u; return { visibleArea: d, isCompletelyWithinViewport: e.width * e.height === d, fitsInViewportVertically: u === e.height, fitsInViewportHorizontally: h == e.width } } _canFitWithFlexibleDimensions(t, e, n) { if (this._hasFlexibleDimensions) { const r = n.bottom - e.y, s = n.right - e.x, i = this._overlayRef.getConfig().minHeight, o = this._overlayRef.getConfig().minWidth, a = t.fitsInViewportHorizontally || null != o && o <= s; return (t.fitsInViewportVertically || null != i && i <= r) && a } return !1 } _pushOverlayOnScreen(t, e, n) { if (this._previousPushAmount && this._positionLocked) return { x: t.x + this._previousPushAmount.x, y: t.y + this._previousPushAmount.y }; const r = this._viewportRect, s = Math.max(t.x + e.width - r.right, 0), i = Math.max(t.y + e.height - r.bottom, 0), o = Math.max(r.top - n.top - t.y, 0), a = Math.max(r.left - n.left - t.x, 0); let l = 0, c = 0; return l = e.width <= r.width ? a || -s : t.x < this._viewportMargin ? r.left - n.left - t.x : 0, c = e.height <= r.height ? o || -i : t.y < this._viewportMargin ? r.top - n.top - t.y : 0, this._previousPushAmount = { x: l, y: c }, { x: t.x + l, y: t.y + c } } _applyPosition(t, e) { if (this._setTransformOrigin(t), this._setOverlayElementStyles(e, t), this._setBoundingBoxStyles(e, t), t.panelClass && this._addPanelClasses(t.panelClass), this._lastPosition = t, this._positionChanges.observers.length) { const e = this._getScrollVisibility(), n = new qp(t, e); this._positionChanges.next(n) } this._isInitialRender = !1 } _setTransformOrigin(t) { if (!this._transformOriginSelector) return; const e = this._boundingBox.querySelectorAll(this._transformOriginSelector); let n, r = t.overlayY; n = "center" === t.overlayX ? "center" : this._isRtl() ? "start" === t.overlayX ? "right" : "left" : "start" === t.overlayX ? "left" : "right"; for (let s = 0; s < e.length; s++)e[s].style.transformOrigin = "".concat(n, " ").concat(r) } _calculateBoundingBoxRect(t, e) { const n = this._viewportRect, r = this._isRtl(); let s, i, o, a, l, c; if ("top" === e.overlayY) i = t.y, s = n.height - i + this._viewportMargin; else if ("bottom" === e.overlayY) o = n.height - t.y + 2 * this._viewportMargin, s = n.height - o + this._viewportMargin; else { const e = Math.min(n.bottom - t.y + n.top, t.y), r = this._lastBoundingBoxSize.height; s = 2 * e, i = t.y - e, s > r && !this._isInitialRender && !this._growAfterOpen && (i = t.y - r / 2) } if ("end" === e.overlayX && !r || "start" === e.overlayX && r) c = n.width - t.x + this._viewportMargin, a = t.x - this._viewportMargin; else if ("start" === e.overlayX && !r || "end" === e.overlayX && r) l = t.x, a = n.right - t.x; else { const e = Math.min(n.right - t.x + n.left, t.x), r = this._lastBoundingBoxSize.width; a = 2 * e, l = t.x - e, a > r && !this._isInitialRender && !this._growAfterOpen && (l = t.x - r / 2) } return { top: i, left: l, bottom: o, right: c, width: a, height: s } } _setBoundingBoxStyles(t, e) { const n = this._calculateBoundingBoxRect(t, e); this._isInitialRender || this._growAfterOpen || (n.height = Math.min(n.height, this._lastBoundingBoxSize.height), n.width = Math.min(n.width, this._lastBoundingBoxSize.width)); const r = {}; if (this._hasExactPosition()) r.top = r.left = "0", r.bottom = r.right = "", r.width = r.height = "100%"; else { const t = this._overlayRef.getConfig().maxHeight, s = this._overlayRef.getConfig().maxWidth; r.height = dp(n.height), r.top = dp(n.top), r.bottom = dp(n.bottom), r.width = dp(n.width), r.left = dp(n.left), r.right = dp(n.right), r.alignItems = "center" === e.overlayX ? "center" : "end" === e.overlayX ? "flex-end" : "flex-start", r.justifyContent = "center" === e.overlayY ? "center" : "bottom" === e.overlayY ? "flex-end" : "flex-start", t && (r.maxHeight = dp(t)), s && (r.maxWidth = dp(s)) } this._lastBoundingBoxSize = n, Xp(this._boundingBox.style, r) } _resetBoundingBoxStyles() { Xp(this._boundingBox.style, { top: "0", left: "0", right: "0", bottom: "0", height: "", width: "", alignItems: "", justifyContent: "" }) } _resetOverlayElementStyles() { Xp(this._pane.style, { top: "", left: "", bottom: "", right: "", position: "", transform: "" }) } _setOverlayElementStyles(t, e) { const n = {}; if (this._hasExactPosition()) { const r = this._viewportRuler.getViewportScrollPosition(); Xp(n, this._getExactOverlayY(e, t, r)), Xp(n, this._getExactOverlayX(e, t, r)) } else n.position = "static"; let r = "", s = this._getOffset(e, "x"), i = this._getOffset(e, "y"); s && (r += "translateX(".concat(s, "px) ")), i && (r += "translateY(".concat(i, "px)")), n.transform = r.trim(), this._hasFlexibleDimensions && this._overlayRef.getConfig().maxHeight && (n.maxHeight = ""), this._hasFlexibleDimensions && this._overlayRef.getConfig().maxWidth && (n.maxWidth = ""), Xp(this._pane.style, n) } _getExactOverlayY(t, e, n) { let r = { top: null, bottom: null }, s = this._getOverlayPoint(e, this._overlayRect, t); this._isPushed && (s = this._pushOverlayOnScreen(s, this._overlayRect, n)); let i = this._overlayContainer.getContainerElement().getBoundingClientRect().top; return s.y -= i, "bottom" === t.overlayY ? r.bottom = "".concat(this._document.documentElement.clientHeight - (s.y + this._overlayRect.height), "px") : r.top = dp(s.y), r } _getExactOverlayX(t, e, n) { let r, s = { left: null, right: null }, i = this._getOverlayPoint(e, this._overlayRect, t); return this._isPushed && (i = this._pushOverlayOnScreen(i, this._overlayRect, n)), r = this._isRtl() ? "end" === t.overlayX ? "left" : "right" : "end" === t.overlayX ? "right" : "left", "right" === r ? s.right = "".concat(this._document.documentElement.clientWidth - (i.x + this._overlayRect.width), "px") : s.left = dp(i.x), s } _getScrollVisibility() { const t = this._getOriginRect(), e = this._pane.getBoundingClientRect(), n = this._scrollables.map(t => t.getElementRef().nativeElement.getBoundingClientRect()); return { isOriginClipped: Up(t, n), isOriginOutsideView: jp(t, n), isOverlayClipped: Up(e, n), isOverlayOutsideView: jp(e, n) } } _subtractOverflows(t, ...e) { return e.reduce((t, e) => t - Math.max(e, 0), t) } _getNarrowedViewportRect() { const t = this._document.documentElement.clientWidth, e = this._document.documentElement.clientHeight, n = this._viewportRuler.getViewportScrollPosition(); return { top: n.top + this._viewportMargin, left: n.left + this._viewportMargin, right: n.left + t - this._viewportMargin, bottom: n.top + e - this._viewportMargin, width: t - 2 * this._viewportMargin, height: e - 2 * this._viewportMargin } } _isRtl() { return "rtl" === this._overlayRef.getDirection() } _hasExactPosition() { return !this._hasFlexibleDimensions || this._isPushed } _getOffset(t, e) { return "x" === e ? null == t.offsetX ? this._offsetX : t.offsetX : null == t.offsetY ? this._offsetY : t.offsetY } _validatePositions() { if (!this._preferredPositions.length) throw Error("FlexibleConnectedPositionStrategy: At least one position is required."); this._preferredPositions.forEach(t => { Qp("originX", t.originX), Wp("originY", t.originY), Qp("overlayX", t.overlayX), Wp("overlayY", t.overlayY) }) } _addPanelClasses(t) { this._pane && up(t).forEach(t => { "" !== t && -1 === this._appliedPanelClasses.indexOf(t) && (this._appliedPanelClasses.push(t), this._pane.classList.add(t)) }) } _clearPanelClasses() { this._pane && (this._appliedPanelClasses.forEach(t => { this._pane.classList.remove(t) }), this._appliedPanelClasses = []) } _getOriginRect() { const t = this._origin; if (t instanceof tn) return t.nativeElement.getBoundingClientRect(); if (t instanceof HTMLElement) return t.getBoundingClientRect(); const e = t.width || 0, n = t.height || 0; return { top: t.y, bottom: t.y + n, left: t.x, right: t.x + e, height: n, width: e } } } function Xp(t, e) { for (let n in e) e.hasOwnProperty(n) && (t[n] = e[n]); return t } class $p { constructor(t, e, n, r, s, i, o) { this._preferredPositions = [], this._positionStrategy = new Yp(n, r, s, i, o).withFlexibleDimensions(!1).withPush(!1).withViewportMargin(0), this.withFallbackPosition(t, e) } get _isRtl() { return "rtl" === this._overlayRef.getDirection() } get onPositionChange() { return this._positionStrategy.positionChanges } get positions() { return this._preferredPositions } attach(t) { this._overlayRef = t, this._positionStrategy.attach(t), this._direction && (t.setDirection(this._direction), this._direction = null) } dispose() { this._positionStrategy.dispose() } detach() { this._positionStrategy.detach() } apply() { this._positionStrategy.apply() } recalculateLastPosition() { this._positionStrategy.reapplyLastPosition() } withScrollableContainers(t) { this._positionStrategy.withScrollableContainers(t) } withFallbackPosition(t, e, n, r) { const s = new zp(t, e, n, r); return this._preferredPositions.push(s), this._positionStrategy.withPositions(this._preferredPositions), this } withDirection(t) { return this._overlayRef ? this._overlayRef.setDirection(t) : this._direction = t, this } withOffsetX(t) { return this._positionStrategy.withDefaultOffsetX(t), this } withOffsetY(t) { return this._positionStrategy.withDefaultOffsetY(t), this } withLockedPosition(t) { return this._positionStrategy.withLockedPosition(t), this } withPositions(t) { return this._preferredPositions = t.slice(), this._positionStrategy.withPositions(this._preferredPositions), this } setOrigin(t) { return this._positionStrategy.setOrigin(t), this } } class Jp { constructor() { this._cssPosition = "static", this._topOffset = "", this._bottomOffset = "", this._leftOffset = "", this._rightOffset = "", this._alignItems = "", this._justifyContent = "", this._width = "", this._height = "" } attach(t) { const e = t.getConfig(); this._overlayRef = t, this._width && !e.width && t.updateSize({ width: this._width }), this._height && !e.height && t.updateSize({ height: this._height }), t.hostElement.classList.add("cdk-global-overlay-wrapper"), this._isDisposed = !1 } top(t = "") { return this._bottomOffset = "", this._topOffset = t, this._alignItems = "flex-start", this } left(t = "") { return this._rightOffset = "", this._leftOffset = t, this._justifyContent = "flex-start", this } bottom(t = "") { return this._topOffset = "", this._bottomOffset = t, this._alignItems = "flex-end", this } right(t = "") { return this._leftOffset = "", this._rightOffset = t, this._justifyContent = "flex-end", this } width(t = "") { return this._overlayRef ? this._overlayRef.updateSize({ width: t }) : this._width = t, this } height(t = "") { return this._overlayRef ? this._overlayRef.updateSize({ height: t }) : this._height = t, this } centerHorizontally(t = "") { return this.left(t), this._justifyContent = "center", this } centerVertically(t = "") { return this.top(t), this._alignItems = "center", this } apply() { if (!this._overlayRef || !this._overlayRef.hasAttached()) return; const t = this._overlayRef.overlayElement.style, e = this._overlayRef.hostElement.style, n = this._overlayRef.getConfig(); t.position = this._cssPosition, t.marginLeft = "100%" === n.width ? "0" : this._leftOffset, t.marginTop = "100%" === n.height ? "0" : this._topOffset, t.marginBottom = this._bottomOffset, t.marginRight = this._rightOffset, "100%" === n.width ? e.justifyContent = "flex-start" : "center" === this._justifyContent ? e.justifyContent = "center" : "rtl" === this._overlayRef.getConfig().direction ? "flex-start" === this._justifyContent ? e.justifyContent = "flex-end" : "flex-end" === this._justifyContent && (e.justifyContent = "flex-start") : e.justifyContent = this._justifyContent, e.alignItems = "100%" === n.height ? "flex-start" : this._alignItems } dispose() { if (this._isDisposed || !this._overlayRef) return; const t = this._overlayRef.overlayElement.style, e = this._overlayRef.hostElement, n = e.style; e.classList.remove("cdk-global-overlay-wrapper"), n.justifyContent = n.alignItems = t.marginTop = t.marginBottom = t.marginLeft = t.marginRight = t.position = "", this._overlayRef = null, this._isDisposed = !0 } } let tf = (() => { class t { constructor(t, e, n, r) { this._viewportRuler = t, this._document = e, this._platform = n, this._overlayContainer = r } global() { return new Jp } connectedTo(t, e, n) { return new $p(e, n, t, this._viewportRuler, this._document, this._platform, this._overlayContainer) } flexibleConnectedTo(t) { return new Yp(t, this._viewportRuler, this._document, this._platform, this._overlayContainer) } } return t.ngInjectableDef = ft({ factory: function () { return new t(Nt(Np), Nt(ma), Nt(Rp), Nt(Zp)) }, token: t, providedIn: "root" }), t })(), ef = 0; class nf { constructor(t, e, n, r, s, i, o, a, l, c) { this.scrollStrategies = t, this._overlayContainer = e, this._componentFactoryResolver = n, this._positionBuilder = r, this._keyboardDispatcher = s, this._injector = i, this._ngZone = o, this._document = a, this._directionality = l, this._location = c } create(t) { const e = this._createHostElement(), n = this._createPaneElement(e), r = this._createPortalOutlet(n), s = new Vp(t); return s.direction = s.direction || this._directionality.value, new Gp(r, e, n, s, this._ngZone, this._keyboardDispatcher, this._document, this._location) } position() { return this._positionBuilder } _createPaneElement(t) { const e = this._document.createElement("div"); return e.id = "cdk-overlay-".concat(ef++), e.classList.add("cdk-overlay-pane"), t.appendChild(e), e } _createHostElement() { const t = this._document.createElement("div"); return this._overlayContainer.getContainerElement().appendChild(t), t } _createPortalOutlet(t) { return this._appRef || (this._appRef = this._injector.get(li)), new sp(t, this._componentFactoryResolver, this._appRef, this._injector) } } const rf = new Tt("cdk-connected-overlay-scroll-strategy"); function sf(t) { return () => t.scrollStrategies.reposition() } class of { } class af { constructor() { this.role = "dialog", this.panelClass = "", this.hasBackdrop = !0, this.backdropClass = "", this.disableClose = !1, this.width = "", this.height = "", this.maxWidth = "80vw", this.data = null, this.ariaDescribedBy = null, this.ariaLabelledBy = null, this.ariaLabel = null, this.autoFocus = !0, this.restoreFocus = !0, this.closeOnNavigation = !0 } } function lf() { throw Error("Attempting to attach dialog content after content is already attached") } class cf extends rp { constructor(t, e, n, r, s) { super(), this._elementRef = t, this._focusTrapFactory = e, this._changeDetectorRef = n, this._document = r, this._config = s, this._elementFocusedBeforeDialogWasOpened = null, this._state = "enter", this._animationStateChanged = new ys, this._ariaLabelledBy = s.ariaLabelledBy || null } attachComponentPortal(t) { return this._portalOutlet.hasAttached() && lf(), this._savePreviouslyFocusedElement(), this._portalOutlet.attachComponentPortal(t) } attachTemplatePortal(t) { return this._portalOutlet.hasAttached() && lf(), this._savePreviouslyFocusedElement(), this._portalOutlet.attachTemplatePortal(t) } _trapFocus() { const t = this._elementRef.nativeElement; if (this._focusTrap || (this._focusTrap = this._focusTrapFactory.create(t)), this._config.autoFocus) this._focusTrap.focusInitialElementWhenReady(); else { const e = this._document.activeElement; e === t || t.contains(e) || t.focus() } } _restoreFocus() { const t = this._elementFocusedBeforeDialogWasOpened; this._config.restoreFocus && t && "function" == typeof t.focus && t.focus(), this._focusTrap && this._focusTrap.destroy() } _savePreviouslyFocusedElement() { this._document && (this._elementFocusedBeforeDialogWasOpened = this._document.activeElement, this._elementRef.nativeElement.focus && Promise.resolve().then(() => this._elementRef.nativeElement.focus())) } _onAnimationDone(t) { "enter" === t.toState ? this._trapFocus() : "exit" === t.toState && this._restoreFocus(), this._animationStateChanged.emit(t) } _onAnimationStart(t) { this._animationStateChanged.emit(t) } _startExitAnimation() { this._state = "exit", this._changeDetectorRef.markForCheck() } } let hf = 0; class uf { constructor(t, e, n, r = "mat-dialog-".concat(hf++)) { this._overlayRef = t, this._containerInstance = e, this.id = r, this.disableClose = this._containerInstance._config.disableClose, this._afterOpened = new k, this._afterClosed = new k, this._beforeClosed = new k, this._state = 0, e._id = r, e._animationStateChanged.pipe(Ia(t => "done" === t.phaseName && "enter" === t.toState), Xa(1)).subscribe(() => { this._afterOpened.next(), this._afterOpened.complete() }), e._animationStateChanged.pipe(Ia(t => "done" === t.phaseName && "exit" === t.toState), Xa(1)).subscribe(() => { clearTimeout(this._closeFallbackTimeout), this._overlayRef.dispose() }), t.detachments().subscribe(() => { this._beforeClosed.next(this._result), this._beforeClosed.complete(), this._afterClosed.next(this._result), this._afterClosed.complete(), this.componentInstance = null, this._overlayRef.dispose() }), t.keydownEvents().pipe(Ia(t => 27 === t.keyCode && !this.disableClose && !function (t, ...e) { return e.length ? e.some(e => t[e]) : t.altKey || t.shiftKey || t.ctrlKey || t.metaKey }(t))).subscribe(t => { t.preventDefault(), this.close() }) } close(t) { this._result = t, this._containerInstance._animationStateChanged.pipe(Ia(t => "start" === t.phaseName), Xa(1)).subscribe(e => { this._beforeClosed.next(t), this._beforeClosed.complete(), this._state = 2, this._overlayRef.detachBackdrop(), this._closeFallbackTimeout = setTimeout(() => { this._overlayRef.dispose() }, e.totalTime + 100) }), this._containerInstance._startExitAnimation(), this._state = 1 } afterOpened() { return this._afterOpened.asObservable() } afterClosed() { return this._afterClosed.asObservable() } beforeClosed() { return this._beforeClosed.asObservable() } backdropClick() { return this._overlayRef.backdropClick() } keydownEvents() { return this._overlayRef.keydownEvents() } updatePosition(t) { let e = this._getPositionStrategy(); return t && (t.left || t.right) ? t.left ? e.left(t.left) : e.right(t.right) : e.centerHorizontally(), t && (t.top || t.bottom) ? t.top ? e.top(t.top) : e.bottom(t.bottom) : e.centerVertically(), this._overlayRef.updatePosition(), this } updateSize(t = "", e = "") { return this._getPositionStrategy().width(t).height(e), this._overlayRef.updatePosition(), this } addPanelClass(t) { return this._overlayRef.addPanelClass(t), this } removePanelClass(t) { return this._overlayRef.removePanelClass(t), this } afterOpen() { return this.afterOpened() } beforeClose() { return this.beforeClosed() } getState() { return this._state } _getPositionStrategy() { return this._overlayRef.getConfig().positionStrategy } } const df = new Tt("MatDialogData"), pf = new Tt("mat-dialog-default-options"), ff = new Tt("mat-dialog-scroll-strategy"); function mf(t) { return () => t.scrollStrategies.block() } class gf { constructor(t, e, n, r, s, i, o) { this._overlay = t, this._injector = e, this._location = n, this._defaultOptions = r, this._parentDialog = i, this._overlayContainer = o, this._openDialogsAtThisLevel = [], this._afterAllClosedAtThisLevel = new k, this._afterOpenedAtThisLevel = new k, this._ariaHiddenElements = new Map, this.afterAllClosed = Ra(() => this.openDialogs.length ? this._afterAllClosed : this._afterAllClosed.pipe(al(void 0))), this._scrollStrategy = s } get openDialogs() { return this._parentDialog ? this._parentDialog.openDialogs : this._openDialogsAtThisLevel } get afterOpened() { return this._parentDialog ? this._parentDialog.afterOpened : this._afterOpenedAtThisLevel } get afterOpen() { return this.afterOpened } get _afterAllClosed() { const t = this._parentDialog; return t ? t._afterAllClosed : this._afterAllClosedAtThisLevel } open(t, e) { if ((e = function (t, e) { return Object.assign({}, e, t) }(e, this._defaultOptions || new af)).id && this.getDialogById(e.id)) throw Error('Dialog with id "'.concat(e.id, '" exists already. The dialog id must be unique.')); const n = this._createOverlay(e), r = this._attachDialogContainer(n, e), s = this._attachDialogContent(t, r, n, e); return this.openDialogs.length || this._hideNonDialogContentFromAssistiveTechnology(), this.openDialogs.push(s), s.afterClosed().subscribe(() => this._removeOpenDialog(s)), this.afterOpened.next(s), s } closeAll() { this._closeDialogs(this.openDialogs) } getDialogById(t) { return this.openDialogs.find(e => e.id === t) } ngOnDestroy() { this._closeDialogs(this._openDialogsAtThisLevel), this._afterAllClosedAtThisLevel.complete(), this._afterOpenedAtThisLevel.complete() } _createOverlay(t) { const e = this._getOverlayConfig(t); return this._overlay.create(e) } _getOverlayConfig(t) { const e = new Vp({ positionStrategy: this._overlay.position().global(), scrollStrategy: t.scrollStrategy || this._scrollStrategy(), panelClass: t.panelClass, hasBackdrop: t.hasBackdrop, direction: t.direction, minWidth: t.minWidth, minHeight: t.minHeight, maxWidth: t.maxWidth, maxHeight: t.maxHeight, disposeOnNavigation: t.closeOnNavigation }); return t.backdropClass && (e.backdropClass = t.backdropClass), e } _attachDialogContainer(t, e) { const n = new ap(e && e.viewContainerRef && e.viewContainerRef.injector || this._injector, new WeakMap([[af, e]])), r = new ep(cf, e.viewContainerRef, n, e.componentFactoryResolver); return t.attach(r).instance } _attachDialogContent(t, e, n, r) { const s = new uf(n, e, this._location, r.id); if (r.hasBackdrop && n.backdropClick().subscribe(() => { s.disableClose || s.close() }), t instanceof Cn) e.attachTemplatePortal(new np(t, null, { $implicit: r.data, dialogRef: s })); else { const n = this._createInjector(r, s, e), i = e.attachComponentPortal(new ep(t, void 0, n)); s.componentInstance = i.instance } return s.updateSize(r.width, r.height).updatePosition(r.position), s } _createInjector(t, e, n) { const r = t && t.viewContainerRef && t.viewContainerRef.injector, s = new WeakMap([[cf, n], [df, t.data], [uf, e]]); return !t.direction || r && r.get(cp, null) || s.set(cp, { value: t.direction, change: Sa() }), new ap(r || this._injector, s) } _removeOpenDialog(t) { const e = this.openDialogs.indexOf(t); e > -1 && (this.openDialogs.splice(e, 1), this.openDialogs.length || (this._ariaHiddenElements.forEach((t, e) => { t ? e.setAttribute("aria-hidden", t) : e.removeAttribute("aria-hidden") }), this._ariaHiddenElements.clear(), this._afterAllClosed.next())) } _hideNonDialogContentFromAssistiveTechnology() { const t = this._overlayContainer.getContainerElement(); if (t.parentElement) { const e = t.parentElement.children; for (let n = e.length - 1; n > -1; n--) { let r = e[n]; r === t || "SCRIPT" === r.nodeName || "STYLE" === r.nodeName || r.hasAttribute("aria-live") || (this._ariaHiddenElements.set(r, r.getAttribute("aria-hidden")), r.setAttribute("aria-hidden", "true")) } } } _closeDialogs(t) { let e = t.length; for (; e--;)t[e].close() } } class yf { } var _f = Vn({ encapsulation: 0, styles: [[".profile[_ngcontent-%COMP%]{width:15vh;height:15vh;border-radius:100%}.eachImage[_ngcontent-%COMP%]{border:1px solid #ddd;border-radius:4px;padding:5px;width:100%;align-self:start}.eachImage[_ngcontent-%COMP%]:hover{box-shadow:0 0 2px 1px rgba(0,140,186,.5)}@media only screen and (max-width:600px){.card-tall[_ngcontent-%COMP%]{grid-row:span 2/auto}.card-wide[_ngcontent-%COMP%]{grid-column:span 2/auto}.gallery-grid[_ngcontent-%COMP%]{display:grid;row-gap:1rem;-webkit-box-pack:center;justify-content:center;overflow:hidden;margin-right:10%;margin-left:10%;justify-items:center;grid-template-columns:1fr}}@media only screen and (min-width:700px){.gallery-grid[_ngcontent-%COMP%]{display:grid;grid-template-columns:1fr 1fr 1fr;margin-right:10%;margin-left:10%;-webkit-column-gap:2%;-moz-column-gap:2%;column-gap:2%;grid-auto-flow:dense}}@media only screen and (min-width:992px){.gallery-grid[_ngcontent-%COMP%]{display:grid;margin-right:20%;margin-left:20%;-webkit-column-gap:2%;-moz-column-gap:2%;column-gap:2%;grid-auto-flow:row;justify-items:center;-webkit-box-align:stretch;align-items:stretch;grid-row-start:auto;grid-template-columns:repeat(4,1fr)}}"]], data: {} }); function vf(t) { return zi(0, [(t()(), Ai(0, 0, null, null, 1, "div", [], null, null, null, null, null)), (t()(), Ai(1, 0, null, null, 0, "img", [["class", "eachImage"]], [[8, "src", 4]], [[null, "click"]], (function (t, e, n) { var r = !0, s = t.component; return "click" === e && (s.index = t.context.index, r = !1 !== s.openDialog() && r), r }), null, null))], null, (function (t, e) { t(e, 1, 0, mr(1, "", e.context.$implicit.link, "")) })) } function bf(t) { return zi(0, [(t()(), Ai(0, 0, null, null, 4, "div", [["class", "jumbotron"]], null, null, null, null, null)), (t()(), Ai(1, 0, null, null, 0, "img", [["alt", ".."], ["class", "mx-auto d-block profile"], ["src", "https://upload.wikimedia.org/wikipedia/commons/a/a5/Red_Kitten_01.jpg"]], null, null, null, null, null)), (t()(), Ai(2, 0, null, null, 0, "br", [], null, null, null, null, null)), (t()(), Ai(3, 0, null, null, 1, "h4", [["class", "mx-auto"], ["style", "text-align: center;"]], null, null, null, null, null)), (t()(), Bi(-1, null, ["Vallari Agrawal"])), (t()(), Ai(5, 0, null, null, 2, "div", [["class", "gallery-grid"]], null, null, null, null, null)), (t()(), ki(16777216, null, null, 1, null, vf)), $r(7, 278528, null, 0, da, [Tn, Cn, vn], { ngForOf: [0, "ngForOf"] }, null)], (function (t, e) { t(e, 7, 0, e.component.images) }), null) } var wf = Ar("app-gallery", Qd, (function (t) { return zi(0, [(t()(), Ai(0, 0, null, null, 1, "app-gallery", [], null, null, null, bf, _f)), $r(1, 114688, null, 0, Qd, [Vd, gf, Fu], null, null)], (function (t, e) { t(e, 1, 0) }), null) }), {}, {}, []); const Sf = new an("8.2.3"); let Ef = (() => { class t { constructor(t) { this._platform = t } isDisabled(t) { return t.hasAttribute("disabled") } isVisible(t) { return function (t) { return !!(t.offsetWidth || t.offsetHeight || "function" == typeof t.getClientRects && t.getClientRects().length) }(t) && "visible" === getComputedStyle(t).visibility } isTabbable(t) { if (!this._platform.isBrowser) return !1; const e = function (t) { try { return t.frameElement } catch (Dy) { return null } }((n = t).ownerDocument && n.ownerDocument.defaultView || window); var n; if (e) { const t = e && e.nodeName.toLowerCase(); if (-1 === xf(e)) return !1; if ((this._platform.BLINK || this._platform.WEBKIT) && "object" === t) return !1; if ((this._platform.BLINK || this._platform.WEBKIT) && !this.isVisible(e)) return !1 } let r = t.nodeName.toLowerCase(), s = xf(t); if (t.hasAttribute("contenteditable")) return -1 !== s; if ("iframe" === r) return !1; if ("audio" === r) { if (!t.hasAttribute("controls")) return !1; if (this._platform.BLINK) return !0 } if ("video" === r) { if (!t.hasAttribute("controls") && this._platform.TRIDENT) return !1; if (this._platform.BLINK || this._platform.FIREFOX) return !0 } return ("object" !== r || !this._platform.BLINK && !this._platform.WEBKIT) && !(this._platform.WEBKIT && this._platform.IOS && !function (t) { let e = t.nodeName.toLowerCase(), n = "input" === e && t.type; return "text" === n || "password" === n || "select" === e || "textarea" === e }(t)) && t.tabIndex >= 0 } isFocusable(t) { return function (t) { return !function (t) { return function (t) { return "input" == t.nodeName.toLowerCase() }(t) && "hidden" == t.type }(t) && (function (t) { let e = t.nodeName.toLowerCase(); return "input" === e || "select" === e || "button" === e || "textarea" === e }(t) || function (t) { return function (t) { return "a" == t.nodeName.toLowerCase() }(t) && t.hasAttribute("href") }(t) || t.hasAttribute("contenteditable") || Cf(t)) }(t) && !this.isDisabled(t) && this.isVisible(t) } } return t.ngInjectableDef = ft({ factory: function () { return new t(Nt(Rp)) }, token: t, providedIn: "root" }), t })(); function Cf(t) { if (!t.hasAttribute("tabindex") || void 0 === t.tabIndex) return !1; let e = t.getAttribute("tabindex"); return "-32768" != e && !(!e || isNaN(parseInt(e, 10))) } function xf(t) { if (!Cf(t)) return null; const e = parseInt(t.getAttribute("tabindex") || "", 10); return isNaN(e) ? -1 : e } class Tf { constructor(t, e, n, r, s = !1) { this._element = t, this._checker = e, this._ngZone = n, this._document = r, this._hasAttached = !1, this.startAnchorListener = () => this.focusLastTabbableElement(), this.endAnchorListener = () => this.focusFirstTabbableElement(), this._enabled = !0, s || this.attachAnchors() } get enabled() { return this._enabled } set enabled(t) { this._enabled = t, this._startAnchor && this._endAnchor && (this._toggleAnchorTabIndex(t, this._startAnchor), this._toggleAnchorTabIndex(t, this._endAnchor)) } destroy() { const t = this._startAnchor, e = this._endAnchor; t && (t.removeEventListener("focus", this.startAnchorListener), t.parentNode && t.parentNode.removeChild(t)), e && (e.removeEventListener("focus", this.endAnchorListener), e.parentNode && e.parentNode.removeChild(e)), this._startAnchor = this._endAnchor = null } attachAnchors() { return !!this._hasAttached || (this._ngZone.runOutsideAngular(() => { this._startAnchor || (this._startAnchor = this._createAnchor(), this._startAnchor.addEventListener("focus", this.startAnchorListener)), this._endAnchor || (this._endAnchor = this._createAnchor(), this._endAnchor.addEventListener("focus", this.endAnchorListener)) }), this._element.parentNode && (this._element.parentNode.insertBefore(this._startAnchor, this._element), this._element.parentNode.insertBefore(this._endAnchor, this._element.nextSibling), this._hasAttached = !0), this._hasAttached) } focusInitialElementWhenReady() { return new Promise(t => { this._executeOnStable(() => t(this.focusInitialElement())) }) } focusFirstTabbableElementWhenReady() { return new Promise(t => { this._executeOnStable(() => t(this.focusFirstTabbableElement())) }) } focusLastTabbableElementWhenReady() { return new Promise(t => { this._executeOnStable(() => t(this.focusLastTabbableElement())) }) } _getRegionBoundary(t) { let e = this._element.querySelectorAll("[cdk-focus-region-".concat(t, "], ") + "[cdkFocusRegion".concat(t, "], ") + "[cdk-focus-".concat(t, "]")); for (let n = 0; n < e.length; n++)e[n].hasAttribute("cdk-focus-".concat(t)) ? console.warn("Found use of deprecated attribute 'cdk-focus-".concat(t, "', ") + "use 'cdkFocusRegion".concat(t, "' instead. The deprecated ") + "attribute will be removed in 8.0.0.", e[n]) : e[n].hasAttribute("cdk-focus-region-".concat(t)) && console.warn("Found use of deprecated attribute 'cdk-focus-region-".concat(t, "', ") + "use 'cdkFocusRegion".concat(t, "' instead. The deprecated attribute ") + "will be removed in 8.0.0.", e[n]); return "start" == t ? e.length ? e[0] : this._getFirstTabbableElement(this._element) : e.length ? e[e.length - 1] : this._getLastTabbableElement(this._element) } focusInitialElement() { const t = this._element.querySelector("[cdk-focus-initial], [cdkFocusInitial]"); return t ? (t.hasAttribute("cdk-focus-initial") && console.warn("Found use of deprecated attribute 'cdk-focus-initial', use 'cdkFocusInitial' instead. The deprecated attribute will be removed in 8.0.0", t), Gt() && !this._checker.isFocusable(t) && console.warn("Element matching '[cdkFocusInitial]' is not focusable.", t), t.focus(), !0) : this.focusFirstTabbableElement() } focusFirstTabbableElement() { const t = this._getRegionBoundary("start"); return t && t.focus(), !!t } focusLastTabbableElement() { const t = this._getRegionBoundary("end"); return t && t.focus(), !!t } hasAttached() { return this._hasAttached } _getFirstTabbableElement(t) { if (this._checker.isFocusable(t) && this._checker.isTabbable(t)) return t; let e = t.children || t.childNodes; for (let n = 0; n < e.length; n++) { let t = e[n].nodeType === this._document.ELEMENT_NODE ? this._getFirstTabbableElement(e[n]) : null; if (t) return t } return null } _getLastTabbableElement(t) { if (this._checker.isFocusable(t) && this._checker.isTabbable(t)) return t; let e = t.children || t.childNodes; for (let n = e.length - 1; n >= 0; n--) { let t = e[n].nodeType === this._document.ELEMENT_NODE ? this._getLastTabbableElement(e[n]) : null; if (t) return t } return null } _createAnchor() { const t = this._document.createElement("div"); return this._toggleAnchorTabIndex(this._enabled, t), t.classList.add("cdk-visually-hidden"), t.classList.add("cdk-focus-trap-anchor"), t.setAttribute("aria-hidden", "true"), t } _toggleAnchorTabIndex(t, e) { t ? e.setAttribute("tabindex", "0") : e.removeAttribute("tabindex") } _executeOnStable(t) { this._ngZone.isStable ? t() : this._ngZone.onStable.asObservable().pipe(Xa(1)).subscribe(t) } } let kf = (() => { class t { constructor(t, e, n) { this._checker = t, this._ngZone = e, this._document = n } create(t, e = !1) { return new Tf(t, this._checker, this._ngZone, this._document, e) } } return t.ngInjectableDef = ft({ factory: function () { return new t(Nt(Ef), Nt(Ws), Nt(ma)) }, token: t, providedIn: "root" }), t })(); class Af { } const Rf = new an("8.2.3"), Pf = new Tt("mat-sanity-checks", { providedIn: "root", factory: function () { return !0 } }); class If { constructor(t, e) { this._sanityChecksEnabled = t, this._hammerLoader = e, this._hasDoneGlobalChecks = !1, this._hasCheckedHammer = !1, this._document = "object" == typeof document && document ? document : null, this._window = "object" == typeof window && window ? window : null, this._areChecksEnabled() && !this._hasDoneGlobalChecks && (this._checkDoctypeIsDefined(), this._checkThemeIsPresent(), this._checkCdkVersionMatch(), this._hasDoneGlobalChecks = !0) } _areChecksEnabled() { return this._sanityChecksEnabled && Gt() && !this._isTestEnv() } _isTestEnv() { const t = this._window; return t && (t.__karma__ || t.jasmine) } _checkDoctypeIsDefined() { this._document && !this._document.doctype && console.warn("Current document does not have a doctype. This may cause some Angular Material components not to behave as expected.") } _checkThemeIsPresent() { if (!this._document || !this._document.body || "function" != typeof getComputedStyle) return; const t = this._document.createElement("div"); t.classList.add("mat-theme-loaded-marker"), this._document.body.appendChild(t); const e = getComputedStyle(t); e && "none" !== e.display && console.warn("Could not find Angular Material core theme. Most Material components may not work as expected. For more info refer to the theming guide: https://material.angular.io/guide/theming"), this._document.body.removeChild(t) } _checkCdkVersionMatch() { Rf.full !== Sf.full && console.warn("The Angular Material version (" + Rf.full + ") does not match the Angular CDK version (" + Sf.full + ").\nPlease ensure the versions of these two packages exactly match.") } _checkHammerIsAvailable() { !this._hasCheckedHammer && this._window && (!this._areChecksEnabled() || this._window.Hammer || this._hammerLoader || console.warn("Could not find HammerJS. Certain Angular Material components may not work correctly."), this._hasCheckedHammer = !0) } } let Of; try { Of = "undefined" != typeof Intl } catch (Dy) { Of = !1 } class Nf { } class Df { } var Ff = Vn({ encapsulation: 2, styles: [".mat-dialog-container{display:block;padding:24px;border-radius:4px;box-sizing:border-box;overflow:auto;outline:0;width:100%;height:100%;min-height:inherit;max-height:inherit}@media (-ms-high-contrast:active){.mat-dialog-container{outline:solid 1px}}.mat-dialog-content{display:block;margin:0 -24px;padding:0 24px;max-height:65vh;overflow:auto;-webkit-overflow-scrolling:touch}.mat-dialog-title{margin:0 0 20px;display:block}.mat-dialog-actions{padding:8px 0;display:flex;flex-wrap:wrap;min-height:52px;align-items:center;margin-bottom:-24px}.mat-dialog-actions[align=end]{justify-content:flex-end}.mat-dialog-actions[align=center]{justify-content:center}.mat-dialog-actions .mat-button-base+.mat-button-base{margin-left:8px}[dir=rtl] .mat-dialog-actions .mat-button-base+.mat-button-base{margin-left:0;margin-right:8px}"], data: { animation: [{ type: 7, name: "dialogContainer", definitions: [{ type: 0, name: "void, exit", styles: { type: 6, styles: { opacity: 0, transform: "scale(0.7)" }, offset: null }, options: void 0 }, { type: 0, name: "enter", styles: { type: 6, styles: { transform: "none" }, offset: null }, options: void 0 }, { type: 1, expr: "* => enter", animation: { type: 4, styles: { type: 6, styles: { transform: "none", opacity: 1 }, offset: null }, timings: "150ms cubic-bezier(0, 0, 0.2, 1)" }, options: null }, { type: 1, expr: "* => void, * => exit", animation: { type: 4, styles: { type: 6, styles: { opacity: 0 }, offset: null }, timings: "75ms cubic-bezier(0.4, 0.0, 0.2, 1)" }, options: null }], options: {} }] } }); function Mf(t) { return zi(0, [(t()(), ki(0, null, null, 0))], null, null) } function Lf(t) { return zi(0, [Ni(402653184, 1, { _portalOutlet: 0 }), (t()(), ki(16777216, null, null, 1, null, Mf)), $r(2, 212992, [[1, 4]], 0, ip, [Ye, Tn], { portal: [0, "portal"] }, null)], (function (t, e) { t(e, 2, 0, "") }), null) } var jf = Ar("mat-dialog-container", cf, (function (t) { return zi(0, [(t()(), Ai(0, 0, null, null, 1, "mat-dialog-container", [["aria-modal", "true"], ["class", "mat-dialog-container"], ["tabindex", "-1"]], [[1, "id", 0], [1, "role", 0], [1, "aria-labelledby", 0], [1, "aria-label", 0], [1, "aria-describedby", 0], [40, "@dialogContainer", 0]], [["component", "@dialogContainer.start"], ["component", "@dialogContainer.done"]], (function (t, e, n) { var r = !0; return "component:@dialogContainer.start" === e && (r = !1 !== Ur(t, 1)._onAnimationStart(n) && r), "component:@dialogContainer.done" === e && (r = !1 !== Ur(t, 1)._onAnimationDone(n) && r), r }), Lf, Ff)), $r(1, 49152, null, 0, cf, [tn, kf, Ee, [2, ma], af], null, null)], null, (function (t, e) { t(e, 0, 0, Ur(e, 1)._id, Ur(e, 1)._config.role, Ur(e, 1)._config.ariaLabel ? null : Ur(e, 1)._ariaLabelledBy, Ur(e, 1)._config.ariaLabel, Ur(e, 1)._config.ariaDescribedBy || null, Ur(e, 1)._state) })) }), {}, {}, []); const Uf = (Bf = class { constructor(t) { this._elementRef = t } }, class extends Bf { get color() { return this._color } set color(t) { const e = t || Hf; e !== this._color && (this._color && this._elementRef.nativeElement.classList.remove("mat-".concat(this._color)), e && this._elementRef.nativeElement.classList.add("mat-".concat(e)), this._color = e) } constructor(...t) { super(...t), this.color = Hf } }); var Bf, Hf; class Vf extends Uf { constructor(t, e, n) { super(t), this._platform = e, this._document = n } ngAfterViewInit() { Gt() && this._platform.isBrowser && (this._checkToolbarMixedModes(), this._toolbarRows.changes.subscribe(() => this._checkToolbarMixedModes())) } _checkToolbarMixedModes() { this._toolbarRows.length && Array.from(this._elementRef.nativeElement.childNodes).filter(t => !(t.classList && t.classList.contains("mat-toolbar-row"))).filter(t => t.nodeType !== (this._document ? this._document.COMMENT_NODE : 8)).some(t => !(!t.textContent || !t.textContent.trim())) && function () { throw Error("MatToolbar: Attempting to combine different toolbar modes. Either specify multiple `<mat-toolbar-row>` elements explicitly or just place content inside of a `<mat-toolbar>` for a single row.") }() } } class zf { } var qf = Vn({ encapsulation: 2, styles: ["@media (-ms-high-contrast:active){.mat-toolbar{outline:solid 1px}}.mat-toolbar-row,.mat-toolbar-single-row{display:flex;box-sizing:border-box;padding:0 16px;width:100%;flex-direction:row;align-items:center;white-space:nowrap}.mat-toolbar-multiple-rows{display:flex;box-sizing:border-box;flex-direction:column;width:100%}.mat-toolbar-multiple-rows{min-height:64px}.mat-toolbar-row,.mat-toolbar-single-row{height:64px}@media (max-width:599px){.mat-toolbar-multiple-rows{min-height:56px}.mat-toolbar-row,.mat-toolbar-single-row{height:56px}}"], data: {} }); function Wf(t) { return zi(2, [ji(null, 0), ji(null, 1)], null, null) } class Qf { constructor() { } ngOnInit() { } } var Kf = Vn({ encapsulation: 0, styles: [[""]], data: {} }); function Zf(t) { return zi(0, [(t()(), Ai(0, 0, null, null, 4, "mat-toolbar", [["class", "mat-toolbar"], ["color", "primary"], ["role", "heading"], ["style", "position: fixed;"]], [[2, "mat-toolbar-multiple-rows", null], [2, "mat-toolbar-single-row", null]], null, null, Wf, qf)), $r(1, 4243456, null, 1, Vf, [tn, Rp, ma], { color: [0, "color"] }, null), Ni(603979776, 1, { _toolbarRows: 1 }), (t()(), Ai(3, 0, null, 0, 1, "span", [], null, null, null, null, null)), (t()(), Bi(-1, null, ["Gallery Library"]))], (function (t, e) { t(e, 1, 0, "primary") }), (function (t, e) { t(e, 0, 0, Ur(e, 1)._toolbarRows.length > 0, 0 === Ur(e, 1)._toolbarRows.length) })) } var Gf = Vn({ encapsulation: 0, styles: [[""]], data: {} }); function Yf(t) { return zi(0, [(t()(), Ai(0, 0, null, null, 1, "app-header", [], null, null, null, Zf, Kf)), $r(1, 114688, null, 0, Qf, [], null, null), (t()(), Ai(2, 0, null, null, 0, "br", [], null, null, null, null, null)), (t()(), Ai(3, 0, null, null, 0, "br", [], null, null, null, null, null)), (t()(), Ai(4, 0, null, null, 0, "br", [], null, null, null, null, null)), (t()(), Ai(5, 16777216, null, null, 1, "router-outlet", [], null, null, null, null, null)), $r(6, 212992, null, 0, ju, [Lu, Tn, Ye, [8, null], Ee], null, null)], (function (t, e) { t(e, 1, 0), t(e, 6, 0) }), null) } var Xf = Ar("app-root", Xo, (function (t) { return zi(0, [(t()(), Ai(0, 0, null, null, 1, "app-root", [], null, null, null, Yf, Gf)), $r(1, 49152, null, 0, Xo, [], null, null)], null, null) }), {}, {}, []); function $f() { return "undefined" != typeof process } function Jf(t) { switch (t.length) { case 0: return new Xd; case 1: return t[0]; default: return new $d(t) } } function tm(t, e, n, r, s = {}, i = {}) { const o = [], a = []; let l = -1, c = null; if (r.forEach(t => { const n = t.offset, r = n == l, h = r && c || {}; Object.keys(t).forEach(n => { let r = n, a = t[n]; if ("offset" !== n) switch (r = e.normalizePropertyName(r, o), a) { case "!": a = s[n]; break; case "*": a = i[n]; break; default: a = e.normalizeStyleValue(n, r, a, o) }h[r] = a }), r || a.push(h), c = h, l = n }), o.length) { const t = "\n - "; throw new Error("Unable to animate due to the following errors:".concat(t).concat(o.join(t))) } return a } function em(t, e, n, r) { switch (e) { case "start": t.onStart(() => r(n && nm(n, "start", t))); break; case "done": t.onDone(() => r(n && nm(n, "done", t))); break; case "destroy": t.onDestroy(() => r(n && nm(n, "destroy", t))) } } function nm(t, e, n) { const r = n.totalTime, s = rm(t.element, t.triggerName, t.fromState, t.toState, e || t.phaseName, null == r ? t.totalTime : r, !!n.disabled), i = t._data; return null != i && (s._data = i), s } function rm(t, e, n, r, s = "", i = 0, o) { return { element: t, triggerName: e, fromState: n, toState: r, phaseName: s, totalTime: i, disabled: !!o } } function sm(t, e, n) { let r; return t instanceof Map ? (r = t.get(e), r || t.set(e, r = n)) : (r = t[e], r || (r = t[e] = n)), r } function im(t) { const e = t.indexOf(":"); return [t.substring(1, e), t.substr(e + 1)] } let om = (t, e) => !1, am = (t, e) => !1, lm = (t, e, n) => []; const cm = $f(); (cm || "undefined" != typeof Element) && (om = (t, e) => t.contains(e), am = (() => { if (cm || Element.prototype.matches) return (t, e) => t.matches(e); { const t = Element.prototype, e = t.matchesSelector || t.mozMatchesSelector || t.msMatchesSelector || t.oMatchesSelector || t.webkitMatchesSelector; return e ? (t, n) => e.apply(t, [n]) : am } })(), lm = (t, e, n) => { let r = []; if (n) r.push(...t.querySelectorAll(e)); else { const n = t.querySelector(e); n && r.push(n) } return r }); let hm = null, um = !1; function dm(t) { hm || (hm = ("undefined" != typeof document ? document.body : null) || {}, um = !!hm.style && "WebkitAppearance" in hm.style); let e = !0; return hm.style && !function (t) { return "ebkit" == t.substring(1, 6) }(t) && (e = t in hm.style, !e && um) && (e = "Webkit" + t.charAt(0).toUpperCase() + t.substr(1) in hm.style), e } const pm = am, fm = om, mm = lm; function gm(t) { const e = {}; return Object.keys(t).forEach(n => { const r = n.replace(/([a-z])([A-Z])/g, "$1-$2"); e[r] = t[n] }), e } class ym { validateStyleProperty(t) { return dm(t) } matchesElement(t, e) { return pm(t, e) } containsElement(t, e) { return fm(t, e) } query(t, e, n) { return mm(t, e, n) } computeStyle(t, e, n) { return n || "" } animate(t, e, n, r, s, i = [], o) { return new Xd(n, r) } } let _m = (() => { class t { } return t.NOOP = new ym, t })(); function vm(t) { if ("number" == typeof t) return t; const e = t.match(/^(-?[\.\d]+)(m?s)/); return !e || e.length < 2 ? 0 : bm(parseFloat(e[1]), e[2]) } function bm(t, e) { switch (e) { case "s": return 1e3 * t; default: return t } } function wm(t, e, n) { return t.hasOwnProperty("duration") ? t : function (t, e, n) { let r, s = 0, i = ""; if ("string" == typeof t) { const n = t.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i); if (null === n) return e.push('The provided timing value "'.concat(t, '" is invalid.')), { duration: 0, delay: 0, easing: "" }; r = bm(parseFloat(n[1]), n[2]); const o = n[3]; null != o && (s = bm(parseFloat(o), n[4])); const a = n[5]; a && (i = a) } else r = t; if (!n) { let n = !1, i = e.length; r < 0 && (e.push("Duration values below 0 are not allowed for this animation step."), n = !0), s < 0 && (e.push("Delay values below 0 are not allowed for this animation step."), n = !0), n && e.splice(i, 0, 'The provided timing value "'.concat(t, '" is invalid.')) } return { duration: r, delay: s, easing: i } }(t, e, n) } function Sm(t, e = {}) { return Object.keys(t).forEach(n => { e[n] = t[n] }), e } function Em(t, e, n = {}) { if (e) for (let r in t) n[r] = t[r]; else Sm(t, n); return n } function Cm(t, e, n) { return n ? e + ":" + n + ";" : "" } function xm(t) { let e = ""; for (let n = 0; n < t.style.length; n++) { const r = t.style.item(n); e += Cm(0, r, t.style.getPropertyValue(r)) } for (const n in t.style) t.style.hasOwnProperty(n) && !n.startsWith("_") && (e += Cm(0, n.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(), t.style[n])); t.setAttribute("style", e) } function Tm(t, e, n) { t.style && (Object.keys(e).forEach(r => { const s = Dm(r); n && !n.hasOwnProperty(r) && (n[r] = t.style[s]), t.style[s] = e[r] }), $f() && xm(t)) } function km(t, e) { t.style && (Object.keys(e).forEach(e => { const n = Dm(e); t.style[n] = "" }), $f() && xm(t)) } function Am(t) { return Array.isArray(t) ? 1 == t.length ? t[0] : Zd(t) : t } const Rm = new RegExp("{{\\s*(.+?)\\s*}}", "g"); function Pm(t) { let e = []; if ("string" == typeof t) { const n = t.toString(); let r; for (; r = Rm.exec(n);)e.push(r[1]); Rm.lastIndex = 0 } return e } function Im(t, e, n) { const r = t.toString(), s = r.replace(Rm, (t, r) => { let s = e[r]; return e.hasOwnProperty(r) || (n.push("Please provide a value for the animation param ".concat(r)), s = ""), s.toString() }); return s == r ? t : s } function Om(t) { const e = []; let n = t.next(); for (; !n.done;)e.push(n.value), n = t.next(); return e } const Nm = /-+([a-z0-9])/g; function Dm(t) { return t.replace(Nm, (...t) => t[1].toUpperCase()) } function Fm(t, e) { return 0 === t || 0 === e } function Mm(t, e, n) { const r = Object.keys(n); if (r.length && e.length) { let i = e[0], o = []; if (r.forEach(t => { i.hasOwnProperty(t) || o.push(t), i[t] = n[t] }), o.length) for (var s = 1; s < e.length; s++) { let n = e[s]; o.forEach((function (e) { n[e] = jm(t, e) })) } } return e } function Lm(t, e, n) { switch (e.type) { case 7: return t.visitTrigger(e, n); case 0: return t.visitState(e, n); case 1: return t.visitTransition(e, n); case 2: return t.visitSequence(e, n); case 3: return t.visitGroup(e, n); case 4: return t.visitAnimate(e, n); case 5: return t.visitKeyframes(e, n); case 6: return t.visitStyle(e, n); case 8: return t.visitReference(e, n); case 9: return t.visitAnimateChild(e, n); case 10: return t.visitAnimateRef(e, n); case 11: return t.visitQuery(e, n); case 12: return t.visitStagger(e, n); default: throw new Error("Unable to resolve animation metadata node #".concat(e.type)) } } function jm(t, e) { return window.getComputedStyle(t)[e] } function Um(t, e) { const n = []; return "string" == typeof t ? t.split(/\s*,\s*/).forEach(t => function (t, e, n) { if (":" == t[0]) { const r = function (t, e) { switch (t) { case ":enter": return "void => *"; case ":leave": return "* => void"; case ":increment": return (t, e) => parseFloat(e) > parseFloat(t); case ":decrement": return (t, e) => parseFloat(e) < parseFloat(t); default: return e.push('The transition alias value "'.concat(t, '" is not supported')), "* => *" } }(t, n); if ("function" == typeof r) return void e.push(r); t = r } const r = t.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/); if (null == r || r.length < 4) return n.push('The provided transition expression "'.concat(t, '" is not supported')), e; const s = r[1], i = r[2], o = r[3]; e.push(Vm(s, o)), "<" != i[0] || "*" == s && "*" == o || e.push(Vm(o, s)) }(t, n, e)) : n.push(t), n } const Bm = new Set(["true", "1"]), Hm = new Set(["false", "0"]); function Vm(t, e) { const n = Bm.has(t) || Hm.has(t), r = Bm.has(e) || Hm.has(e); return (s, i) => { let o = "*" == t || t == s, a = "*" == e || e == i; return !o && n && "boolean" == typeof s && (o = s ? Bm.has(t) : Hm.has(t)), !a && r && "boolean" == typeof i && (a = i ? Bm.has(e) : Hm.has(e)), o && a } } const zm = new RegExp("s*:selfs*,?", "g"); function qm(t, e, n) { return new Wm(t).build(e, n) } class Wm { constructor(t) { this._driver = t } build(t, e) { const n = new Qm(e); return this._resetContextStyleTimingState(n), Lm(this, Am(t), n) } _resetContextStyleTimingState(t) { t.currentQuerySelector = "", t.collectedStyles = {}, t.collectedStyles[""] = {}, t.currentTime = 0 } visitTrigger(t, e) { let n = e.queryCount = 0, r = e.depCount = 0; const s = [], i = []; return "@" == t.name.charAt(0) && e.errors.push("animation triggers cannot be prefixed with an `@` sign (e.g. trigger('@foo', [...]))"), t.definitions.forEach(t => { if (this._resetContextStyleTimingState(e), 0 == t.type) { const n = t, r = n.name; r.toString().split(/\s*,\s*/).forEach(t => { n.name = t, s.push(this.visitState(n, e)) }), n.name = r } else if (1 == t.type) { const s = this.visitTransition(t, e); n += s.queryCount, r += s.depCount, i.push(s) } else e.errors.push("only state() and transition() definitions can sit inside of a trigger()") }), { type: 7, name: t.name, states: s, transitions: i, queryCount: n, depCount: r, options: null } } visitState(t, e) { const n = this.visitStyle(t.styles, e), r = t.options && t.options.params || null; if (n.containsDynamicStyles) { const s = new Set, i = r || {}; if (n.styles.forEach(t => { if (Km(t)) { const e = t; Object.keys(e).forEach(t => { Pm(e[t]).forEach(t => { i.hasOwnProperty(t) || s.add(t) }) }) } }), s.size) { const n = Om(s.values()); e.errors.push('state("'.concat(t.name, '", ...) must define default values for all the following style substitutions: ').concat(n.join(", "))) } } return { type: 0, name: t.name, style: n, options: r ? { params: r } : null } } visitTransition(t, e) { e.queryCount = 0, e.depCount = 0; const n = Lm(this, Am(t.animation), e); return { type: 1, matchers: Um(t.expr, e.errors), animation: n, queryCount: e.queryCount, depCount: e.depCount, options: Zm(t.options) } } visitSequence(t, e) { return { type: 2, steps: t.steps.map(t => Lm(this, t, e)), options: Zm(t.options) } } visitGroup(t, e) { const n = e.currentTime; let r = 0; const s = t.steps.map(t => { e.currentTime = n; const s = Lm(this, t, e); return r = Math.max(r, e.currentTime), s }); return e.currentTime = r, { type: 3, steps: s, options: Zm(t.options) } } visitAnimate(t, e) { const n = function (t, e) { let n = null; if (t.hasOwnProperty("duration")) n = t; else if ("number" == typeof t) return Gm(wm(t, e).duration, 0, ""); const r = t; if (r.split(/\s+/).some(t => "{" == t.charAt(0) && "{" == t.charAt(1))) { const t = Gm(0, 0, ""); return t.dynamic = !0, t.strValue = r, t } return n = n || wm(r, e), Gm(n.duration, n.delay, n.easing) }(t.timings, e.errors); let r; e.currentAnimateTimings = n; let s = t.styles ? t.styles : Gd({}); if (5 == s.type) r = this.visitKeyframes(s, e); else { let s = t.styles, i = !1; if (!s) { i = !0; const t = {}; n.easing && (t.easing = n.easing), s = Gd(t) } e.currentTime += n.duration + n.delay; const o = this.visitStyle(s, e); o.isEmptyStep = i, r = o } return e.currentAnimateTimings = null, { type: 4, timings: n, style: r, options: null } } visitStyle(t, e) { const n = this._makeStyleAst(t, e); return this._validateStyleAst(n, e), n } _makeStyleAst(t, e) { const n = []; Array.isArray(t.styles) ? t.styles.forEach(t => { "string" == typeof t ? "*" == t ? n.push(t) : e.errors.push("The provided style string value ".concat(t, " is not allowed.")) : n.push(t) }) : n.push(t.styles); let r = !1, s = null; return n.forEach(t => { if (Km(t)) { const e = t, n = e.easing; if (n && (s = n, delete e.easing), !r) for (let t in e) if (e[t].toString().indexOf("{{") >= 0) { r = !0; break } } }), { type: 6, styles: n, easing: s, offset: t.offset, containsDynamicStyles: r, options: null } } _validateStyleAst(t, e) { const n = e.currentAnimateTimings; let r = e.currentTime, s = e.currentTime; n && s > 0 && (s -= n.duration + n.delay), t.styles.forEach(t => { "string" != typeof t && Object.keys(t).forEach(n => { if (!this._driver.validateStyleProperty(n)) return void e.errors.push('The provided animation property "'.concat(n, '" is not a supported CSS property for animations')); const i = e.collectedStyles[e.currentQuerySelector], o = i[n]; let a = !0; o && (s != r && s >= o.startTime && r <= o.endTime && (e.errors.push('The CSS property "'.concat(n, '" that exists between the times of "').concat(o.startTime, 'ms" and "').concat(o.endTime, 'ms" is also being animated in a parallel animation between the times of "').concat(s, 'ms" and "').concat(r, 'ms"')), a = !1), s = o.startTime), a && (i[n] = { startTime: s, endTime: r }), e.options && function (t, e, n) { const r = e.params || {}, s = Pm(t); s.length && s.forEach(t => { r.hasOwnProperty(t) || n.push("Unable to resolve the local animation param ".concat(t, " in the given list of values")) }) }(t[n], e.options, e.errors) }) }) } visitKeyframes(t, e) { const n = { type: 5, styles: [], options: null }; if (!e.currentAnimateTimings) return e.errors.push("keyframes() must be placed inside of a call to animate()"), n; let r = 0; const s = []; let i = !1, o = !1, a = 0; const l = t.steps.map(t => { const n = this._makeStyleAst(t, e); let l = null != n.offset ? n.offset : function (t) { if ("string" == typeof t) return null; let e = null; if (Array.isArray(t)) t.forEach(t => { if (Km(t) && t.hasOwnProperty("offset")) { const n = t; e = parseFloat(n.offset), delete n.offset } }); else if (Km(t) && t.hasOwnProperty("offset")) { const n = t; e = parseFloat(n.offset), delete n.offset } return e }(n.styles), c = 0; return null != l && (r++, c = n.offset = l), o = o || c < 0 || c > 1, i = i || c < a, a = c, s.push(c), n }); o && e.errors.push("Please ensure that all keyframe offsets are between 0 and 1"), i && e.errors.push("Please ensure that all keyframe offsets are in order"); const c = t.steps.length; let h = 0; r > 0 && r < c ? e.errors.push("Not all style() steps within the declared keyframes() contain offsets") : 0 == r && (h = 1 / (c - 1)); const u = c - 1, d = e.currentTime, p = e.currentAnimateTimings, f = p.duration; return l.forEach((t, r) => { const i = h > 0 ? r == u ? 1 : h * r : s[r], o = i * f; e.currentTime = d + p.delay + o, p.duration = o, this._validateStyleAst(t, e), t.offset = i, n.styles.push(t) }), n } visitReference(t, e) { return { type: 8, animation: Lm(this, Am(t.animation), e), options: Zm(t.options) } } visitAnimateChild(t, e) { return e.depCount++, { type: 9, options: Zm(t.options) } } visitAnimateRef(t, e) { return { type: 10, animation: this.visitReference(t.animation, e), options: Zm(t.options) } } visitQuery(t, e) { const n = e.currentQuerySelector, r = t.options || {}; e.queryCount++, e.currentQuery = t; const [s, i] = function (t) { const e = !!t.split(/\s*,\s*/).find(t => ":self" == t); return e && (t = t.replace(zm, "")), [t = t.replace(/@\*/g, ".ng-trigger").replace(/@\w+/g, t => ".ng-trigger-" + t.substr(1)).replace(/:animating/g, ".ng-animating"), e] }(t.selector); e.currentQuerySelector = n.length ? n + " " + s : s, sm(e.collectedStyles, e.currentQuerySelector, {}); const o = Lm(this, Am(t.animation), e); return e.currentQuery = null, e.currentQuerySelector = n, { type: 11, selector: s, limit: r.limit || 0, optional: !!r.optional, includeSelf: i, animation: o, originalSelector: t.selector, options: Zm(t.options) } } visitStagger(t, e) { e.currentQuery || e.errors.push("stagger() can only be used inside of query()"); const n = "full" === t.timings ? { duration: 0, delay: 0, easing: "full" } : wm(t.timings, e.errors, !0); return { type: 12, animation: Lm(this, Am(t.animation), e), timings: n, options: null } } } class Qm { constructor(t) { this.errors = t, this.queryCount = 0, this.depCount = 0, this.currentTransition = null, this.currentQuery = null, this.currentQuerySelector = null, this.currentAnimateTimings = null, this.currentTime = 0, this.collectedStyles = {}, this.options = null } } function Km(t) { return !Array.isArray(t) && "object" == typeof t } function Zm(t) { var e; return t ? (t = Sm(t)).params && (t.params = (e = t.params) ? Sm(e) : null) : t = {}, t } function Gm(t, e, n) { return { duration: t, delay: e, easing: n } } function Ym(t, e, n, r, s, i, o = null, a = !1) { return { type: 1, element: t, keyframes: e, preStyleProps: n, postStyleProps: r, duration: s, delay: i, totalTime: s + i, easing: o, subTimeline: a } } class Xm { constructor() { this._map = new Map } consume(t) { let e = this._map.get(t); return e ? this._map.delete(t) : e = [], e } append(t, e) { let n = this._map.get(t); n || this._map.set(t, n = []), n.push(...e) } has(t) { return this._map.has(t) } clear() { this._map.clear() } } const $m = new RegExp(":enter", "g"), Jm = new RegExp(":leave", "g"); function tg(t, e, n, r, s, i = {}, o = {}, a, l, c = []) { return (new eg).buildKeyframes(t, e, n, r, s, i, o, a, l, c) } class eg { buildKeyframes(t, e, n, r, s, i, o, a, l, c = []) { l = l || new Xm; const h = new rg(t, e, l, r, s, c, []); h.options = a, h.currentTimeline.setStyles([i], null, h.errors, a), Lm(this, n, h); const u = h.timelines.filter(t => t.containsAnimation()); if (u.length && Object.keys(o).length) { const t = u[u.length - 1]; t.allowOnlyTimelineStyles() || t.setStyles([o], null, h.errors, a) } return u.length ? u.map(t => t.buildKeyframes()) : [Ym(e, [], [], [], 0, 0, "", !1)] } visitTrigger(t, e) { } visitState(t, e) { } visitTransition(t, e) { } visitAnimateChild(t, e) { const n = e.subInstructions.consume(e.element); if (n) { const r = e.createSubContext(t.options), s = e.currentTimeline.currentTime, i = this._visitSubInstructions(n, r, r.options); s != i && e.transformIntoNewTimeline(i) } e.previousNode = t } visitAnimateRef(t, e) { const n = e.createSubContext(t.options); n.transformIntoNewTimeline(), this.visitReference(t.animation, n), e.transformIntoNewTimeline(n.currentTimeline.currentTime), e.previousNode = t } _visitSubInstructions(t, e, n) { let r = e.currentTimeline.currentTime; const s = null != n.duration ? vm(n.duration) : null, i = null != n.delay ? vm(n.delay) : null; return 0 !== s && t.forEach(t => { const n = e.appendInstructionToTimeline(t, s, i); r = Math.max(r, n.duration + n.delay) }), r } visitReference(t, e) { e.updateOptions(t.options, !0), Lm(this, t.animation, e), e.previousNode = t } visitSequence(t, e) { const n = e.subContextCount; let r = e; const s = t.options; if (s && (s.params || s.delay) && (r = e.createSubContext(s), r.transformIntoNewTimeline(), null != s.delay)) { 6 == r.previousNode.type && (r.currentTimeline.snapshotCurrentStyles(), r.previousNode = ng); const t = vm(s.delay); r.delayNextStep(t) } t.steps.length && (t.steps.forEach(t => Lm(this, t, r)), r.currentTimeline.applyStylesToKeyframe(), r.subContextCount > n && r.transformIntoNewTimeline()), e.previousNode = t } visitGroup(t, e) { const n = []; let r = e.currentTimeline.currentTime; const s = t.options && t.options.delay ? vm(t.options.delay) : 0; t.steps.forEach(i => { const o = e.createSubContext(t.options); s && o.delayNextStep(s), Lm(this, i, o), r = Math.max(r, o.currentTimeline.currentTime), n.push(o.currentTimeline) }), n.forEach(t => e.currentTimeline.mergeTimelineCollectedStyles(t)), e.transformIntoNewTimeline(r), e.previousNode = t } _visitTiming(t, e) { if (t.dynamic) { const n = t.strValue; return wm(e.params ? Im(n, e.params, e.errors) : n, e.errors) } return { duration: t.duration, delay: t.delay, easing: t.easing } } visitAnimate(t, e) { const n = e.currentAnimateTimings = this._visitTiming(t.timings, e), r = e.currentTimeline; n.delay && (e.incrementTime(n.delay), r.snapshotCurrentStyles()); const s = t.style; 5 == s.type ? this.visitKeyframes(s, e) : (e.incrementTime(n.duration), this.visitStyle(s, e), r.applyStylesToKeyframe()), e.currentAnimateTimings = null, e.previousNode = t } visitStyle(t, e) { const n = e.currentTimeline, r = e.currentAnimateTimings; !r && n.getCurrentStyleProperties().length && n.forwardFrame(); const s = r && r.easing || t.easing; t.isEmptyStep ? n.applyEmptyStep(s) : n.setStyles(t.styles, s, e.errors, e.options), e.previousNode = t } visitKeyframes(t, e) { const n = e.currentAnimateTimings, r = e.currentTimeline.duration, s = n.duration, i = e.createSubContext().currentTimeline; i.easing = n.easing, t.styles.forEach(t => { i.forwardTime((t.offset || 0) * s), i.setStyles(t.styles, t.easing, e.errors, e.options), i.applyStylesToKeyframe() }), e.currentTimeline.mergeTimelineCollectedStyles(i), e.transformIntoNewTimeline(r + s), e.previousNode = t } visitQuery(t, e) { const n = e.currentTimeline.currentTime, r = t.options || {}, s = r.delay ? vm(r.delay) : 0; s && (6 === e.previousNode.type || 0 == n && e.currentTimeline.getCurrentStyleProperties().length) && (e.currentTimeline.snapshotCurrentStyles(), e.previousNode = ng); let i = n; const o = e.invokeQuery(t.selector, t.originalSelector, t.limit, t.includeSelf, !!r.optional, e.errors); e.currentQueryTotal = o.length; let a = null; o.forEach((n, r) => { e.currentQueryIndex = r; const o = e.createSubContext(t.options, n); s && o.delayNextStep(s), n === e.element && (a = o.currentTimeline), Lm(this, t.animation, o), o.currentTimeline.applyStylesToKeyframe(), i = Math.max(i, o.currentTimeline.currentTime) }), e.currentQueryIndex = 0, e.currentQueryTotal = 0, e.transformIntoNewTimeline(i), a && (e.currentTimeline.mergeTimelineCollectedStyles(a), e.currentTimeline.snapshotCurrentStyles()), e.previousNode = t } visitStagger(t, e) { const n = e.parentContext, r = e.currentTimeline, s = t.timings, i = Math.abs(s.duration), o = i * (e.currentQueryTotal - 1); let a = i * e.currentQueryIndex; switch (s.duration < 0 ? "reverse" : s.easing) { case "reverse": a = o - a; break; case "full": a = n.currentStaggerTime }const l = e.currentTimeline; a && l.delayNextStep(a); const c = l.currentTime; Lm(this, t.animation, e), e.previousNode = t, n.currentStaggerTime = r.currentTime - c + (r.startTime - n.currentTimeline.startTime) } } const ng = {}; class rg { constructor(t, e, n, r, s, i, o, a) { this._driver = t, this.element = e, this.subInstructions = n, this._enterClassName = r, this._leaveClassName = s, this.errors = i, this.timelines = o, this.parentContext = null, this.currentAnimateTimings = null, this.previousNode = ng, this.subContextCount = 0, this.options = {}, this.currentQueryIndex = 0, this.currentQueryTotal = 0, this.currentStaggerTime = 0, this.currentTimeline = a || new sg(this._driver, e, 0), o.push(this.currentTimeline) } get params() { return this.options.params } updateOptions(t, e) { if (!t) return; const n = t; let r = this.options; null != n.duration && (r.duration = vm(n.duration)), null != n.delay && (r.delay = vm(n.delay)); const s = n.params; if (s) { let t = r.params; t || (t = this.options.params = {}), Object.keys(s).forEach(n => { e && t.hasOwnProperty(n) || (t[n] = Im(s[n], t, this.errors)) }) } } _copyOptions() { const t = {}; if (this.options) { const e = this.options.params; if (e) { const n = t.params = {}; Object.keys(e).forEach(t => { n[t] = e[t] }) } } return t } createSubContext(t = null, e, n) { const r = e || this.element, s = new rg(this._driver, r, this.subInstructions, this._enterClassName, this._leaveClassName, this.errors, this.timelines, this.currentTimeline.fork(r, n || 0)); return s.previousNode = this.previousNode, s.currentAnimateTimings = this.currentAnimateTimings, s.options = this._copyOptions(), s.updateOptions(t), s.currentQueryIndex = this.currentQueryIndex, s.currentQueryTotal = this.currentQueryTotal, s.parentContext = this, this.subContextCount++, s } transformIntoNewTimeline(t) { return this.previousNode = ng, this.currentTimeline = this.currentTimeline.fork(this.element, t), this.timelines.push(this.currentTimeline), this.currentTimeline } appendInstructionToTimeline(t, e, n) { const r = { duration: null != e ? e : t.duration, delay: this.currentTimeline.currentTime + (null != n ? n : 0) + t.delay, easing: "" }, s = new ig(this._driver, t.element, t.keyframes, t.preStyleProps, t.postStyleProps, r, t.stretchStartingKeyframe); return this.timelines.push(s), r } incrementTime(t) { this.currentTimeline.forwardTime(this.currentTimeline.duration + t) } delayNextStep(t) { t > 0 && this.currentTimeline.delayNextStep(t) } invokeQuery(t, e, n, r, s, i) { let o = []; if (r && o.push(this.element), t.length > 0) { t = (t = t.replace($m, "." + this._enterClassName)).replace(Jm, "." + this._leaveClassName); let e = this._driver.query(this.element, t, 1 != n); 0 !== n && (e = n < 0 ? e.slice(e.length + n, e.length) : e.slice(0, n)), o.push(...e) } return s || 0 != o.length || i.push('`query("'.concat(e, '")` returned zero elements. (Use `query("').concat(e, '", { optional: true })` if you wish to allow this.)')), o } } class sg { constructor(t, e, n, r) { this._driver = t, this.element = e, this.startTime = n, this._elementTimelineStylesLookup = r, this.duration = 0, this._previousKeyframe = {}, this._currentKeyframe = {}, this._keyframes = new Map, this._styleSummary = {}, this._pendingStyles = {}, this._backFill = {}, this._currentEmptyStepKeyframe = null, this._elementTimelineStylesLookup || (this._elementTimelineStylesLookup = new Map), this._localTimelineStyles = Object.create(this._backFill, {}), this._globalTimelineStyles = this._elementTimelineStylesLookup.get(e), this._globalTimelineStyles || (this._globalTimelineStyles = this._localTimelineStyles, this._elementTimelineStylesLookup.set(e, this._localTimelineStyles)), this._loadKeyframe() } containsAnimation() { switch (this._keyframes.size) { case 0: return !1; case 1: return this.getCurrentStyleProperties().length > 0; default: return !0 } } getCurrentStyleProperties() { return Object.keys(this._currentKeyframe) } get currentTime() { return this.startTime + this.duration } delayNextStep(t) { const e = 1 == this._keyframes.size && Object.keys(this._pendingStyles).length; this.duration || e ? (this.forwardTime(this.currentTime + t), e && this.snapshotCurrentStyles()) : this.startTime += t } fork(t, e) { return this.applyStylesToKeyframe(), new sg(this._driver, t, e || this.currentTime, this._elementTimelineStylesLookup) } _loadKeyframe() { this._currentKeyframe && (this._previousKeyframe = this._currentKeyframe), this._currentKeyframe = this._keyframes.get(this.duration), this._currentKeyframe || (this._currentKeyframe = Object.create(this._backFill, {}), this._keyframes.set(this.duration, this._currentKeyframe)) } forwardFrame() { this.duration += 1, this._loadKeyframe() } forwardTime(t) { this.applyStylesToKeyframe(), this.duration = t, this._loadKeyframe() } _updateStyle(t, e) { this._localTimelineStyles[t] = e, this._globalTimelineStyles[t] = e, this._styleSummary[t] = { time: this.currentTime, value: e } } allowOnlyTimelineStyles() { return this._currentEmptyStepKeyframe !== this._currentKeyframe } applyEmptyStep(t) { t && (this._previousKeyframe.easing = t), Object.keys(this._globalTimelineStyles).forEach(t => { this._backFill[t] = this._globalTimelineStyles[t] || "*", this._currentKeyframe[t] = "*" }), this._currentEmptyStepKeyframe = this._currentKeyframe } setStyles(t, e, n, r) { e && (this._previousKeyframe.easing = e); const s = r && r.params || {}, i = function (t, e) { const n = {}; let r; return t.forEach(t => { "*" === t ? (r = r || Object.keys(e), r.forEach(t => { n[t] = "*" })) : Em(t, !1, n) }), n }(t, this._globalTimelineStyles); Object.keys(i).forEach(t => { const e = Im(i[t], s, n); this._pendingStyles[t] = e, this._localTimelineStyles.hasOwnProperty(t) || (this._backFill[t] = this._globalTimelineStyles.hasOwnProperty(t) ? this._globalTimelineStyles[t] : "*"), this._updateStyle(t, e) }) } applyStylesToKeyframe() { const t = this._pendingStyles, e = Object.keys(t); 0 != e.length && (this._pendingStyles = {}, e.forEach(e => { this._currentKeyframe[e] = t[e] }), Object.keys(this._localTimelineStyles).forEach(t => { this._currentKeyframe.hasOwnProperty(t) || (this._currentKeyframe[t] = this._localTimelineStyles[t]) })) } snapshotCurrentStyles() { Object.keys(this._localTimelineStyles).forEach(t => { const e = this._localTimelineStyles[t]; this._pendingStyles[t] = e, this._updateStyle(t, e) }) } getFinalKeyframe() { return this._keyframes.get(this.duration) } get properties() { const t = []; for (let e in this._currentKeyframe) t.push(e); return t } mergeTimelineCollectedStyles(t) { Object.keys(t._styleSummary).forEach(e => { const n = this._styleSummary[e], r = t._styleSummary[e]; (!n || r.time > n.time) && this._updateStyle(e, r.value) }) } buildKeyframes() { this.applyStylesToKeyframe(); const t = new Set, e = new Set, n = 1 === this._keyframes.size && 0 === this.duration; let r = []; this._keyframes.forEach((s, i) => { const o = Em(s, !0); Object.keys(o).forEach(n => { const r = o[n]; "!" == r ? t.add(n) : "*" == r && e.add(n) }), n || (o.offset = i / this.duration), r.push(o) }); const s = t.size ? Om(t.values()) : [], i = e.size ? Om(e.values()) : []; if (n) { const t = r[0], e = Sm(t); t.offset = 0, e.offset = 1, r = [t, e] } return Ym(this.element, r, s, i, this.duration, this.startTime, this.easing, !1) } } class ig extends sg { constructor(t, e, n, r, s, i, o = !1) { super(t, e, i.delay), this.element = e, this.keyframes = n, this.preStyleProps = r, this.postStyleProps = s, this._stretchStartingKeyframe = o, this.timings = { duration: i.duration, delay: i.delay, easing: i.easing } } containsAnimation() { return this.keyframes.length > 1 } buildKeyframes() { let t = this.keyframes, { delay: e, duration: n, easing: r } = this.timings; if (this._stretchStartingKeyframe && e) { const s = [], i = n + e, o = e / i, a = Em(t[0], !1); a.offset = 0, s.push(a); const l = Em(t[0], !1); l.offset = og(o), s.push(l); const c = t.length - 1; for (let r = 1; r <= c; r++) { let o = Em(t[r], !1); o.offset = og((e + o.offset * n) / i), s.push(o) } n = i, e = 0, r = "", t = s } return Ym(this.element, t, this.preStyleProps, this.postStyleProps, n, e, r, !0) } } function og(t, e = 3) { const n = Math.pow(10, e - 1); return Math.round(t * n) / n } class ag { } class lg extends ag { normalizePropertyName(t, e) { return Dm(t) } normalizeStyleValue(t, e, n, r) { let s = ""; const i = n.toString().trim(); if (cg[e] && 0 !== n && "0" !== n) if ("number" == typeof n) s = "px"; else { const e = n.match(/^[+-]?[\d\.]+([a-z]*)$/); e && 0 == e[1].length && r.push("Please provide a CSS unit value for ".concat(t, ":").concat(n)) } return i + s } } const cg = function (t) { const e = {}; return t.forEach(t => e[t] = !0), e }("width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent,perspective".split(",")); function hg(t, e, n, r, s, i, o, a, l, c, h, u, d) { return { type: 0, element: t, triggerName: e, isRemovalTransition: s, fromState: n, fromStyles: i, toState: r, toStyles: o, timelines: a, queriedElements: l, preStyleProps: c, postStyleProps: h, totalTime: u, errors: d } } const ug = {}; class dg { constructor(t, e, n) { this._triggerName = t, this.ast = e, this._stateStyles = n } match(t, e, n, r) { return function (t, e, n, r, s) { return t.some(t => t(e, n, r, s)) }(this.ast.matchers, t, e, n, r) } buildStyles(t, e, n) { const r = this._stateStyles["*"], s = this._stateStyles[t], i = r ? r.buildStyles(e, n) : {}; return s ? s.buildStyles(e, n) : i } build(t, e, n, r, s, i, o, a, l, c) { const h = [], u = this.ast.options && this.ast.options.params || ug, d = this.buildStyles(n, o && o.params || ug, h), p = a && a.params || ug, f = this.buildStyles(r, p, h), m = new Set, g = new Map, y = new Map, _ = "void" === r, v = { params: Object.assign({}, u, p) }, b = c ? [] : tg(t, e, this.ast.animation, s, i, d, f, v, l, h); let w = 0; if (b.forEach(t => { w = Math.max(t.duration + t.delay, w) }), h.length) return hg(e, this._triggerName, n, r, _, d, f, [], [], g, y, w, h); b.forEach(t => { const n = t.element, r = sm(g, n, {}); t.preStyleProps.forEach(t => r[t] = !0); const s = sm(y, n, {}); t.postStyleProps.forEach(t => s[t] = !0), n !== e && m.add(n) }); const S = Om(m.values()); return hg(e, this._triggerName, n, r, _, d, f, b, S, g, y, w) } } class pg { constructor(t, e) { this.styles = t, this.defaultParams = e } buildStyles(t, e) { const n = {}, r = Sm(this.defaultParams); return Object.keys(t).forEach(e => { const n = t[e]; null != n && (r[e] = n) }), this.styles.styles.forEach(t => { if ("string" != typeof t) { const s = t; Object.keys(s).forEach(t => { let i = s[t]; i.length > 1 && (i = Im(i, r, e)), n[t] = i }) } }), n } } class fg { constructor(t, e) { this.name = t, this.ast = e, this.transitionFactories = [], this.states = {}, e.states.forEach(t => { this.states[t.name] = new pg(t.style, t.options && t.options.params || {}) }), mg(this.states, "true", "1"), mg(this.states, "false", "0"), e.transitions.forEach(e => { this.transitionFactories.push(new dg(t, e, this.states)) }), this.fallbackTransition = new dg(t, { type: 1, animation: { type: 2, steps: [], options: null }, matchers: [(t, e) => !0], options: null, queryCount: 0, depCount: 0 }, this.states) } get containsQueries() { return this.ast.queryCount > 0 } matchTransition(t, e, n, r) { return this.transitionFactories.find(s => s.match(t, e, n, r)) || null } matchStyles(t, e, n) { return this.fallbackTransition.buildStyles(t, e, n) } } function mg(t, e, n) { t.hasOwnProperty(e) ? t.hasOwnProperty(n) || (t[n] = t[e]) : t.hasOwnProperty(n) && (t[e] = t[n]) } const gg = new Xm; class yg { constructor(t, e, n) { this.bodyNode = t, this._driver = e, this._normalizer = n, this._animations = {}, this._playersById = {}, this.players = [] } register(t, e) { const n = [], r = qm(this._driver, e, n); if (n.length) throw new Error("Unable to build the animation due to the following errors: ".concat(n.join("\n"))); this._animations[t] = r } _buildPlayer(t, e, n) { const r = t.element, s = tm(0, this._normalizer, 0, t.keyframes, e, n); return this._driver.animate(r, s, t.duration, t.delay, t.easing, [], !0) } create(t, e, n = {}) { const r = [], s = this._animations[t]; let i; const o = new Map; if (s ? (i = tg(this._driver, e, s, "ng-enter", "ng-leave", {}, {}, n, gg, r), i.forEach(t => { const e = sm(o, t.element, {}); t.postStyleProps.forEach(t => e[t] = null) })) : (r.push("The requested animation doesn't exist or has already been destroyed"), i = []), r.length) throw new Error("Unable to create the animation due to the following errors: ".concat(r.join("\n"))); o.forEach((t, e) => { Object.keys(t).forEach(n => { t[n] = this._driver.computeStyle(e, n, "*") }) }); const a = Jf(i.map(t => { const e = o.get(t.element); return this._buildPlayer(t, {}, e) })); return this._playersById[t] = a, a.onDestroy(() => this.destroy(t)), this.players.push(a), a } destroy(t) { const e = this._getPlayer(t); e.destroy(), delete this._playersById[t]; const n = this.players.indexOf(e); n >= 0 && this.players.splice(n, 1) } _getPlayer(t) { const e = this._playersById[t]; if (!e) throw new Error("Unable to find the timeline player referenced by ".concat(t)); return e } listen(t, e, n, r) { const s = rm(e, "", "", ""); return em(this._getPlayer(t), n, s, r), () => { } } command(t, e, n, r) { if ("register" == n) return void this.register(t, r[0]); if ("create" == n) return void this.create(t, e, r[0] || {}); const s = this._getPlayer(t); switch (n) { case "play": s.play(); break; case "pause": s.pause(); break; case "reset": s.reset(); break; case "restart": s.restart(); break; case "finish": s.finish(); break; case "init": s.init(); break; case "setPosition": s.setPosition(parseFloat(r[0])); break; case "destroy": this.destroy(t) } } } const _g = [], vg = { namespaceId: "", setForRemoval: !1, setForMove: !1, hasAnimation: !1, removedBeforeQueried: !1 }, bg = { namespaceId: "", setForMove: !1, setForRemoval: !1, hasAnimation: !1, removedBeforeQueried: !0 }; class wg { constructor(t, e = "") { this.namespaceId = e; const n = t && t.hasOwnProperty("value"); if (this.value = null != (r = n ? t.value : t) ? r : null, n) { const e = Sm(t); delete e.value, this.options = e } else this.options = {}; var r; this.options.params || (this.options.params = {}) } get params() { return this.options.params } absorbOptions(t) { const e = t.params; if (e) { const t = this.options.params; Object.keys(e).forEach(n => { null == t[n] && (t[n] = e[n]) }) } } } const Sg = new wg("void"); class Eg { constructor(t, e, n) { this.id = t, this.hostElement = e, this._engine = n, this.players = [], this._triggers = {}, this._queue = [], this._elementListeners = new Map, this._hostClassName = "ng-tns-" + t, Pg(e, this._hostClassName) } listen(t, e, n, r) { if (!this._triggers.hasOwnProperty(e)) throw new Error('Unable to listen on the animation trigger event "'.concat(n, '" because the animation trigger "').concat(e, "\" doesn't exist!")); if (null == n || 0 == n.length) throw new Error('Unable to listen on the animation trigger "'.concat(e, '" because the provided event is undefined!')); if ("start" != (s = n) && "done" != s) throw new Error('The provided animation trigger event "'.concat(n, '" for the animation trigger "').concat(e, '" is not supported!')); var s; const i = sm(this._elementListeners, t, []), o = { name: e, phase: n, callback: r }; i.push(o); const a = sm(this._engine.statesByElement, t, {}); return a.hasOwnProperty(e) || (Pg(t, "ng-trigger"), Pg(t, "ng-trigger-" + e), a[e] = Sg), () => { this._engine.afterFlush(() => { const t = i.indexOf(o); t >= 0 && i.splice(t, 1), this._triggers[e] || delete a[e] }) } } register(t, e) { return !this._triggers[t] && (this._triggers[t] = e, !0) } _getTrigger(t) { const e = this._triggers[t]; if (!e) throw new Error('The provided animation trigger "'.concat(t, '" has not been registered!')); return e } trigger(t, e, n, r = !0) { const s = this._getTrigger(e), i = new xg(this.id, e, t); let o = this._engine.statesByElement.get(t); o || (Pg(t, "ng-trigger"), Pg(t, "ng-trigger-" + e), this._engine.statesByElement.set(t, o = {})); let a = o[e]; const l = new wg(n, this.id); if (!(n && n.hasOwnProperty("value")) && a && l.absorbOptions(a.options), o[e] = l, a || (a = Sg), "void" !== l.value && a.value === l.value) { if (!function (t, e) { const n = Object.keys(t), r = Object.keys(e); if (n.length != r.length) return !1; for (let s = 0; s < n.length; s++) { const r = n[s]; if (!e.hasOwnProperty(r) || t[r] !== e[r]) return !1 } return !0 }(a.params, l.params)) { const e = [], n = s.matchStyles(a.value, a.params, e), r = s.matchStyles(l.value, l.params, e); e.length ? this._engine.reportError(e) : this._engine.afterFlush(() => { km(t, n), Tm(t, r) }) } return } const c = sm(this._engine.playersByElement, t, []); c.forEach(t => { t.namespaceId == this.id && t.triggerName == e && t.queued && t.destroy() }); let h = s.matchTransition(a.value, l.value, t, l.params), u = !1; if (!h) { if (!r) return; h = s.fallbackTransition, u = !0 } return this._engine.totalQueuedPlayers++, this._queue.push({ element: t, triggerName: e, transition: h, fromState: a, toState: l, player: i, isFallbackTransition: u }), u || (Pg(t, "ng-animate-queued"), i.onStart(() => { Ig(t, "ng-animate-queued") })), i.onDone(() => { let e = this.players.indexOf(i); e >= 0 && this.players.splice(e, 1); const n = this._engine.playersByElement.get(t); if (n) { let t = n.indexOf(i); t >= 0 && n.splice(t, 1) } }), this.players.push(i), c.push(i), i } deregister(t) { delete this._triggers[t], this._engine.statesByElement.forEach((e, n) => { delete e[t] }), this._elementListeners.forEach((e, n) => { this._elementListeners.set(n, e.filter(e => e.name != t)) }) } clearElementCache(t) { this._engine.statesByElement.delete(t), this._elementListeners.delete(t); const e = this._engine.playersByElement.get(t); e && (e.forEach(t => t.destroy()), this._engine.playersByElement.delete(t)) } _signalRemovalForInnerTriggers(t, e, n = !1) { this._engine.driver.query(t, ".ng-trigger", !0).forEach(t => { if (t.__ng_removed) return; const n = this._engine.fetchNamespacesByElement(t); n.size ? n.forEach(n => n.triggerLeaveAnimation(t, e, !1, !0)) : this.clearElementCache(t) }) } triggerLeaveAnimation(t, e, n, r) { const s = this._engine.statesByElement.get(t); if (s) { const i = []; if (Object.keys(s).forEach(e => { if (this._triggers[e]) { const n = this.trigger(t, e, "void", r); n && i.push(n) } }), i.length) return this._engine.markElementAsRemoved(this.id, t, !0, e), n && Jf(i).onDone(() => this._engine.processLeaveNode(t)), !0 } return !1 } prepareLeaveAnimationListeners(t) { const e = this._elementListeners.get(t); if (e) { const n = new Set; e.forEach(e => { const r = e.name; if (n.has(r)) return; n.add(r); const s = this._triggers[r].fallbackTransition, i = this._engine.statesByElement.get(t)[r] || Sg, o = new wg("void"), a = new xg(this.id, r, t); this._engine.totalQueuedPlayers++, this._queue.push({ element: t, triggerName: r, transition: s, fromState: i, toState: o, player: a, isFallbackTransition: !0 }) }) } } removeNode(t, e) { const n = this._engine; if (t.childElementCount && this._signalRemovalForInnerTriggers(t, e, !0), this.triggerLeaveAnimation(t, e, !0)) return; let r = !1; if (n.totalAnimations) { const e = n.players.length ? n.playersByQueriedElement.get(t) : []; if (e && e.length) r = !0; else { let e = t; for (; e = e.parentNode;)if (n.statesByElement.get(e)) { r = !0; break } } } this.prepareLeaveAnimationListeners(t), r ? n.markElementAsRemoved(this.id, t, !1, e) : (n.afterFlush(() => this.clearElementCache(t)), n.destroyInnerAnimations(t), n._onRemovalComplete(t, e)) } insertNode(t, e) { Pg(t, this._hostClassName) } drainQueuedTransitions(t) { const e = []; return this._queue.forEach(n => { const r = n.player; if (r.destroyed) return; const s = n.element, i = this._elementListeners.get(s); i && i.forEach(e => { if (e.name == n.triggerName) { const r = rm(s, n.triggerName, n.fromState.value, n.toState.value); r._data = t, em(n.player, e.phase, r, e.callback) } }), r.markedForDestroy ? this._engine.afterFlush(() => { r.destroy() }) : e.push(n) }), this._queue = [], e.sort((t, e) => { const n = t.transition.ast.depCount, r = e.transition.ast.depCount; return 0 == n || 0 == r ? n - r : this._engine.driver.containsElement(t.element, e.element) ? 1 : -1 }) } destroy(t) { this.players.forEach(t => t.destroy()), this._signalRemovalForInnerTriggers(this.hostElement, t) } elementContainsData(t) { let e = !1; return this._elementListeners.has(t) && (e = !0), e = !!this._queue.find(e => e.element === t) || e, e } } class Cg { constructor(t, e, n) { this.bodyNode = t, this.driver = e, this._normalizer = n, this.players = [], this.newHostElements = new Map, this.playersByElement = new Map, this.playersByQueriedElement = new Map, this.statesByElement = new Map, this.disabledNodes = new Set, this.totalAnimations = 0, this.totalQueuedPlayers = 0, this._namespaceLookup = {}, this._namespaceList = [], this._flushFns = [], this._whenQuietFns = [], this.namespacesByHostElement = new Map, this.collectedEnterElements = [], this.collectedLeaveElements = [], this.onRemovalComplete = (t, e) => { } } _onRemovalComplete(t, e) { this.onRemovalComplete(t, e) } get queuedPlayers() { const t = []; return this._namespaceList.forEach(e => { e.players.forEach(e => { e.queued && t.push(e) }) }), t } createNamespace(t, e) { const n = new Eg(t, e, this); return e.parentNode ? this._balanceNamespaceList(n, e) : (this.newHostElements.set(e, n), this.collectEnterElement(e)), this._namespaceLookup[t] = n } _balanceNamespaceList(t, e) { const n = this._namespaceList.length - 1; if (n >= 0) { let r = !1; for (let s = n; s >= 0; s--)if (this.driver.containsElement(this._namespaceList[s].hostElement, e)) { this._namespaceList.splice(s + 1, 0, t), r = !0; break } r || this._namespaceList.splice(0, 0, t) } else this._namespaceList.push(t); return this.namespacesByHostElement.set(e, t), t } register(t, e) { let n = this._namespaceLookup[t]; return n || (n = this.createNamespace(t, e)), n } registerTrigger(t, e, n) { let r = this._namespaceLookup[t]; r && r.register(e, n) && this.totalAnimations++ } destroy(t, e) { if (!t) return; const n = this._fetchNamespace(t); this.afterFlush(() => { this.namespacesByHostElement.delete(n.hostElement), delete this._namespaceLookup[t]; const e = this._namespaceList.indexOf(n); e >= 0 && this._namespaceList.splice(e, 1) }), this.afterFlushAnimationsDone(() => n.destroy(e)) } _fetchNamespace(t) { return this._namespaceLookup[t] } fetchNamespacesByElement(t) { const e = new Set, n = this.statesByElement.get(t); if (n) { const t = Object.keys(n); for (let r = 0; r < t.length; r++) { const s = n[t[r]].namespaceId; if (s) { const t = this._fetchNamespace(s); t && e.add(t) } } } return e } trigger(t, e, n, r) { if (Tg(e)) { const s = this._fetchNamespace(t); if (s) return s.trigger(e, n, r), !0 } return !1 } insertNode(t, e, n, r) { if (!Tg(e)) return; const s = e.__ng_removed; if (s && s.setForRemoval) { s.setForRemoval = !1, s.setForMove = !0; const t = this.collectedLeaveElements.indexOf(e); t >= 0 && this.collectedLeaveElements.splice(t, 1) } if (t) { const r = this._fetchNamespace(t); r && r.insertNode(e, n) } r && this.collectEnterElement(e) } collectEnterElement(t) { this.collectedEnterElements.push(t) } markElementAsDisabled(t, e) { e ? this.disabledNodes.has(t) || (this.disabledNodes.add(t), Pg(t, "ng-animate-disabled")) : this.disabledNodes.has(t) && (this.disabledNodes.delete(t), Ig(t, "ng-animate-disabled")) } removeNode(t, e, n, r) { if (Tg(e)) { const s = t ? this._fetchNamespace(t) : null; if (s ? s.removeNode(e, r) : this.markElementAsRemoved(t, e, !1, r), n) { const n = this.namespacesByHostElement.get(e); n && n.id !== t && n.removeNode(e, r) } } else this._onRemovalComplete(e, r) } markElementAsRemoved(t, e, n, r) { this.collectedLeaveElements.push(e), e.__ng_removed = { namespaceId: t, setForRemoval: r, hasAnimation: n, removedBeforeQueried: !1 } } listen(t, e, n, r, s) { return Tg(e) ? this._fetchNamespace(t).listen(e, n, r, s) : () => { } } _buildInstruction(t, e, n, r, s) { return t.transition.build(this.driver, t.element, t.fromState.value, t.toState.value, n, r, t.fromState.options, t.toState.options, e, s) } destroyInnerAnimations(t) { let e = this.driver.query(t, ".ng-trigger", !0); e.forEach(t => this.destroyActiveAnimationsForElement(t)), 0 != this.playersByQueriedElement.size && (e = this.driver.query(t, ".ng-animating", !0), e.forEach(t => this.finishActiveQueriedAnimationOnElement(t))) } destroyActiveAnimationsForElement(t) { const e = this.playersByElement.get(t); e && e.forEach(t => { t.queued ? t.markedForDestroy = !0 : t.destroy() }) } finishActiveQueriedAnimationOnElement(t) { const e = this.playersByQueriedElement.get(t); e && e.forEach(t => t.finish()) } whenRenderingDone() { return new Promise(t => { if (this.players.length) return Jf(this.players).onDone(() => t()); t() }) } processLeaveNode(t) { const e = t.__ng_removed; if (e && e.setForRemoval) { if (t.__ng_removed = vg, e.namespaceId) { this.destroyInnerAnimations(t); const n = this._fetchNamespace(e.namespaceId); n && n.clearElementCache(t) } this._onRemovalComplete(t, e.setForRemoval) } this.driver.matchesElement(t, ".ng-animate-disabled") && this.markElementAsDisabled(t, !1), this.driver.query(t, ".ng-animate-disabled", !0).forEach(t => { this.markElementAsDisabled(t, !1) }) } flush(t = -1) { let e = []; if (this.newHostElements.size && (this.newHostElements.forEach((t, e) => this._balanceNamespaceList(t, e)), this.newHostElements.clear()), this.totalAnimations && this.collectedEnterElements.length) for (let n = 0; n < this.collectedEnterElements.length; n++)Pg(this.collectedEnterElements[n], "ng-star-inserted"); if (this._namespaceList.length && (this.totalQueuedPlayers || this.collectedLeaveElements.length)) { const n = []; try { e = this._flushAnimations(n, t) } finally { for (let t = 0; t < n.length; t++)n[t]() } } else for (let n = 0; n < this.collectedLeaveElements.length; n++)this.processLeaveNode(this.collectedLeaveElements[n]); if (this.totalQueuedPlayers = 0, this.collectedEnterElements.length = 0, this.collectedLeaveElements.length = 0, this._flushFns.forEach(t => t()), this._flushFns = [], this._whenQuietFns.length) { const t = this._whenQuietFns; this._whenQuietFns = [], e.length ? Jf(e).onDone(() => { t.forEach(t => t()) }) : t.forEach(t => t()) } } reportError(t) { throw new Error("Unable to process animations due to the following failed trigger transitions\n ".concat(t.join("\n"))) } _flushAnimations(t, e) { const n = new Xm, r = [], s = new Map, i = [], o = new Map, a = new Map, l = new Map, c = new Set; this.disabledNodes.forEach(t => { c.add(t); const e = this.driver.query(t, ".ng-animate-queued", !0); for (let n = 0; n < e.length; n++)c.add(e[n]) }); const h = this.bodyNode, u = Array.from(this.statesByElement.keys()), d = Rg(u, this.collectedEnterElements), p = new Map; let f = 0; d.forEach((t, e) => { const n = "ng-enter" + f++; p.set(e, n), t.forEach(t => Pg(t, n)) }); const m = [], g = new Set, y = new Set; for (let P = 0; P < this.collectedLeaveElements.length; P++) { const t = this.collectedLeaveElements[P], e = t.__ng_removed; e && e.setForRemoval && (m.push(t), g.add(t), e.hasAnimation ? this.driver.query(t, ".ng-star-inserted", !0).forEach(t => g.add(t)) : y.add(t)) } const _ = new Map, v = Rg(u, Array.from(g)); v.forEach((t, e) => { const n = "ng-leave" + f++; _.set(e, n), t.forEach(t => Pg(t, n)) }), t.push(() => { d.forEach((t, e) => { const n = p.get(e); t.forEach(t => Ig(t, n)) }), v.forEach((t, e) => { const n = _.get(e); t.forEach(t => Ig(t, n)) }), m.forEach(t => { this.processLeaveNode(t) }) }); const b = [], w = []; for (let P = this._namespaceList.length - 1; P >= 0; P--)this._namespaceList[P].drainQueuedTransitions(e).forEach(t => { const e = t.player, s = t.element; if (b.push(e), this.collectedEnterElements.length) { const t = s.__ng_removed; if (t && t.setForMove) return void e.destroy() } const c = !h || !this.driver.containsElement(h, s), u = _.get(s), d = p.get(s), f = this._buildInstruction(t, n, d, u, c); if (!f.errors || !f.errors.length) return c ? (e.onStart(() => km(s, f.fromStyles)), e.onDestroy(() => Tm(s, f.toStyles)), void r.push(e)) : t.isFallbackTransition ? (e.onStart(() => km(s, f.fromStyles)), e.onDestroy(() => Tm(s, f.toStyles)), void r.push(e)) : (f.timelines.forEach(t => t.stretchStartingKeyframe = !0), n.append(s, f.timelines), i.push({ instruction: f, player: e, element: s }), f.queriedElements.forEach(t => sm(o, t, []).push(e)), f.preStyleProps.forEach((t, e) => { const n = Object.keys(t); if (n.length) { let t = a.get(e); t || a.set(e, t = new Set), n.forEach(e => t.add(e)) } }), void f.postStyleProps.forEach((t, e) => { const n = Object.keys(t); let r = l.get(e); r || l.set(e, r = new Set), n.forEach(t => r.add(t)) })); w.push(f) }); if (w.length) { const t = []; w.forEach(e => { t.push("@".concat(e.triggerName, " has failed due to:\n")), e.errors.forEach(e => t.push("- ".concat(e, "\n"))) }), b.forEach(t => t.destroy()), this.reportError(t) } const S = new Map, E = new Map; i.forEach(t => { const e = t.element; n.has(e) && (E.set(e, e), this._beforeAnimationBuild(t.player.namespaceId, t.instruction, S)) }), r.forEach(t => { const e = t.element; this._getPreviousPlayers(e, !1, t.namespaceId, t.triggerName, null).forEach(t => { sm(S, e, []).push(t), t.destroy() }) }); const C = m.filter(t => Ng(t, a, l)), x = new Map; Ag(x, this.driver, y, l, "*").forEach(t => { Ng(t, a, l) && C.push(t) }); const T = new Map; d.forEach((t, e) => { Ag(T, this.driver, new Set(t), a, "!") }), C.forEach(t => { const e = x.get(t), n = T.get(t); x.set(t, Object.assign({}, e, n)) }); const k = [], A = [], R = {}; i.forEach(t => { const { element: e, player: i, instruction: o } = t; if (n.has(e)) { if (c.has(e)) return i.onDestroy(() => Tm(e, o.toStyles)), i.disabled = !0, i.overrideTotalTime(o.totalTime), void r.push(i); let t = R; if (E.size > 1) { let n = e; const r = []; for (; n = n.parentNode;) { const e = E.get(n); if (e) { t = e; break } r.push(n) } r.forEach(e => E.set(e, t)) } const n = this._buildAnimation(i.namespaceId, o, S, s, T, x); if (i.setRealPlayer(n), t === R) k.push(i); else { const e = this.playersByElement.get(t); e && e.length && (i.parentPlayer = Jf(e)), r.push(i) } } else km(e, o.fromStyles), i.onDestroy(() => Tm(e, o.toStyles)), A.push(i), c.has(e) && r.push(i) }), A.forEach(t => { const e = s.get(t.element); if (e && e.length) { const n = Jf(e); t.setRealPlayer(n) } }), r.forEach(t => { t.parentPlayer ? t.syncPlayerEvents(t.parentPlayer) : t.destroy() }); for (let P = 0; P < m.length; P++) { const t = m[P], e = t.__ng_removed; if (Ig(t, "ng-leave"), e && e.hasAnimation) continue; let n = []; if (o.size) { let e = o.get(t); e && e.length && n.push(...e); let r = this.driver.query(t, ".ng-animating", !0); for (let t = 0; t < r.length; t++) { let e = o.get(r[t]); e && e.length && n.push(...e) } } const r = n.filter(t => !t.destroyed); r.length ? Og(this, t, r) : this.processLeaveNode(t) } return m.length = 0, k.forEach(t => { this.players.push(t), t.onDone(() => { t.destroy(); const e = this.players.indexOf(t); this.players.splice(e, 1) }), t.play() }), k } elementContainsData(t, e) { let n = !1; const r = e.__ng_removed; return r && r.setForRemoval && (n = !0), this.playersByElement.has(e) && (n = !0), this.playersByQueriedElement.has(e) && (n = !0), this.statesByElement.has(e) && (n = !0), this._fetchNamespace(t).elementContainsData(e) || n } afterFlush(t) { this._flushFns.push(t) } afterFlushAnimationsDone(t) { this._whenQuietFns.push(t) } _getPreviousPlayers(t, e, n, r, s) { let i = []; if (e) { const e = this.playersByQueriedElement.get(t); e && (i = e) } else { const e = this.playersByElement.get(t); if (e) { const t = !s || "void" == s; e.forEach(e => { e.queued || (t || e.triggerName == r) && i.push(e) }) } } return (n || r) && (i = i.filter(t => !(n && n != t.namespaceId || r && r != t.triggerName))), i } _beforeAnimationBuild(t, e, n) { const r = e.element, s = e.isRemovalTransition ? void 0 : t, i = e.isRemovalTransition ? void 0 : e.triggerName; for (const o of e.timelines) { const t = o.element, a = t !== r, l = sm(n, t, []); this._getPreviousPlayers(t, a, s, i, e.toState).forEach(t => { const e = t.getRealPlayer(); e.beforeDestroy && e.beforeDestroy(), t.destroy(), l.push(t) }) } km(r, e.fromStyles) } _buildAnimation(t, e, n, r, s, i) { const o = e.triggerName, a = e.element, l = [], c = new Set, h = new Set, u = e.timelines.map(e => { const u = e.element; c.add(u); const d = u.__ng_removed; if (d && d.removedBeforeQueried) return new Xd(e.duration, e.delay); const p = u !== a, f = function (t) { const e = []; return function t(e, n) { for (let r = 0; r < e.length; r++) { const s = e[r]; s instanceof $d ? t(s.players, n) : n.push(s) } }(t, e), e }((n.get(u) || _g).map(t => t.getRealPlayer())).filter(t => !!t.element && t.element === u), m = s.get(u), g = i.get(u), y = tm(0, this._normalizer, 0, e.keyframes, m, g), _ = this._buildPlayer(e, y, f); if (e.subTimeline && r && h.add(u), p) { const e = new xg(t, o, u); e.setRealPlayer(_), l.push(e) } return _ }); l.forEach(t => { sm(this.playersByQueriedElement, t.element, []).push(t), t.onDone(() => function (t, e, n) { let r; if (t instanceof Map) { if (r = t.get(e), r) { if (r.length) { const t = r.indexOf(n); r.splice(t, 1) } 0 == r.length && t.delete(e) } } else if (r = t[e], r) { if (r.length) { const t = r.indexOf(n); r.splice(t, 1) } 0 == r.length && delete t[e] } return r }(this.playersByQueriedElement, t.element, t)) }), c.forEach(t => Pg(t, "ng-animating")); const d = Jf(u); return d.onDestroy(() => { c.forEach(t => Ig(t, "ng-animating")), Tm(a, e.toStyles) }), h.forEach(t => { sm(r, t, []).push(d) }), d } _buildPlayer(t, e, n) { return e.length > 0 ? this.driver.animate(t.element, e, t.duration, t.delay, t.easing, n) : new Xd(t.duration, t.delay) } } class xg { constructor(t, e, n) { this.namespaceId = t, this.triggerName = e, this.element = n, this._player = new Xd, this._containsRealPlayer = !1, this._queuedCallbacks = {}, this.destroyed = !1, this.markedForDestroy = !1, this.disabled = !1, this.queued = !0, this.totalTime = 0 } setRealPlayer(t) { this._containsRealPlayer || (this._player = t, Object.keys(this._queuedCallbacks).forEach(e => { this._queuedCallbacks[e].forEach(n => em(t, e, void 0, n)) }), this._queuedCallbacks = {}, this._containsRealPlayer = !0, this.overrideTotalTime(t.totalTime), this.queued = !1) } getRealPlayer() { return this._player } overrideTotalTime(t) { this.totalTime = t } syncPlayerEvents(t) { const e = this._player; e.triggerCallback && t.onStart(() => e.triggerCallback("start")), t.onDone(() => this.finish()), t.onDestroy(() => this.destroy()) } _queueEvent(t, e) { sm(this._queuedCallbacks, t, []).push(e) } onDone(t) { this.queued && this._queueEvent("done", t), this._player.onDone(t) } onStart(t) { this.queued && this._queueEvent("start", t), this._player.onStart(t) } onDestroy(t) { this.queued && this._queueEvent("destroy", t), this._player.onDestroy(t) } init() { this._player.init() } hasStarted() { return !this.queued && this._player.hasStarted() } play() { !this.queued && this._player.play() } pause() { !this.queued && this._player.pause() } restart() { !this.queued && this._player.restart() } finish() { this._player.finish() } destroy() { this.destroyed = !0, this._player.destroy() } reset() { !this.queued && this._player.reset() } setPosition(t) { this.queued || this._player.setPosition(t) } getPosition() { return this.queued ? 0 : this._player.getPosition() } triggerCallback(t) { const e = this._player; e.triggerCallback && e.triggerCallback(t) } } function Tg(t) { return t && 1 === t.nodeType } function kg(t, e) { const n = t.style.display; return t.style.display = null != e ? e : "none", n } function Ag(t, e, n, r, s) { const i = []; n.forEach(t => i.push(kg(t))); const o = []; r.forEach((n, r) => { const i = {}; n.forEach(t => { const n = i[t] = e.computeStyle(r, t, s); n && 0 != n.length || (r.__ng_removed = bg, o.push(r)) }), t.set(r, i) }); let a = 0; return n.forEach(t => kg(t, i[a++])), o } function Rg(t, e) { const n = new Map; if (t.forEach(t => n.set(t, [])), 0 == e.length) return n; const r = new Set(e), s = new Map; return e.forEach(t => { const e = function t(e) { if (!e) return 1; let i = s.get(e); if (i) return i; const o = e.parentNode; return i = n.has(o) ? o : r.has(o) ? 1 : t(o), s.set(e, i), i }(t); 1 !== e && n.get(e).push(t) }), n } function Pg(t, e) { if (t.classList) t.classList.add(e); else { let n = t.$$classes; n || (n = t.$$classes = {}), n[e] = !0 } } function Ig(t, e) { if (t.classList) t.classList.remove(e); else { let n = t.$$classes; n && delete n[e] } } function Og(t, e, n) { Jf(n).onDone(() => t.processLeaveNode(e)) } function Ng(t, e, n) { const r = n.get(t); if (!r) return !1; let s = e.get(t); return s ? r.forEach(t => s.add(t)) : e.set(t, r), n.delete(t), !0 } class Dg { constructor(t, e, n) { this.bodyNode = t, this._driver = e, this._triggerCache = {}, this.onRemovalComplete = (t, e) => { }, this._transitionEngine = new Cg(t, e, n), this._timelineEngine = new yg(t, e, n), this._transitionEngine.onRemovalComplete = (t, e) => this.onRemovalComplete(t, e) } registerTrigger(t, e, n, r, s) { const i = t + "-" + r; let o = this._triggerCache[i]; if (!o) { const t = [], e = qm(this._driver, s, t); if (t.length) throw new Error('The animation trigger "'.concat(r, '" has failed to build due to the following errors:\n - ').concat(t.join("\n - "))); o = function (t, e) { return new fg(t, e) }(r, e), this._triggerCache[i] = o } this._transitionEngine.registerTrigger(e, r, o) } register(t, e) { this._transitionEngine.register(t, e) } destroy(t, e) { this._transitionEngine.destroy(t, e) } onInsert(t, e, n, r) { this._transitionEngine.insertNode(t, e, n, r) } onRemove(t, e, n, r) { this._transitionEngine.removeNode(t, e, r || !1, n) } disableAnimations(t, e) { this._transitionEngine.markElementAsDisabled(t, e) } process(t, e, n, r) { if ("@" == n.charAt(0)) { const [t, s] = im(n); this._timelineEngine.command(t, e, s, r) } else this._transitionEngine.trigger(t, e, n, r) } listen(t, e, n, r, s) { if ("@" == n.charAt(0)) { const [t, r] = im(n); return this._timelineEngine.listen(t, e, r, s) } return this._transitionEngine.listen(t, e, n, r, s) } flush(t = -1) { this._transitionEngine.flush(t) } get players() { return this._transitionEngine.players.concat(this._timelineEngine.players) } whenRenderingDone() { return this._transitionEngine.whenRenderingDone() } } function Fg(t, e) { let n = null, r = null; return Array.isArray(e) && e.length ? (n = Lg(e[0]), e.length > 1 && (r = Lg(e[e.length - 1]))) : e && (n = Lg(e)), n || r ? new Mg(t, n, r) : null } let Mg = (() => { class t { constructor(e, n, r) { this._element = e, this._startStyles = n, this._endStyles = r, this._state = 0; let s = t.initialStylesByElement.get(e); s || t.initialStylesByElement.set(e, s = {}), this._initialStyles = s } start() { this._state < 1 && (this._startStyles && Tm(this._element, this._startStyles, this._initialStyles), this._state = 1) } finish() { this.start(), this._state < 2 && (Tm(this._element, this._initialStyles), this._endStyles && (Tm(this._element, this._endStyles), this._endStyles = null), this._state = 1) } destroy() { this.finish(), this._state < 3 && (t.initialStylesByElement.delete(this._element), this._startStyles && (km(this._element, this._startStyles), this._endStyles = null), this._endStyles && (km(this._element, this._endStyles), this._endStyles = null), Tm(this._element, this._initialStyles), this._state = 3) } } return t.initialStylesByElement = new WeakMap, t })(); function Lg(t) { let e = null; const n = Object.keys(t); for (let r = 0; r < n.length; r++) { const s = n[r]; jg(s) && (e = e || {}, e[s] = t[s]) } return e } function jg(t) { return "display" === t || "position" === t } class Ug { constructor(t, e, n, r, s, i, o) { this._element = t, this._name = e, this._duration = n, this._delay = r, this._easing = s, this._fillMode = i, this._onDoneFn = o, this._finished = !1, this._destroyed = !1, this._startTime = 0, this._position = 0, this._eventFn = t => this._handleCallback(t) } apply() { !function (t, e) { const n = Wg(t, "").trim(); n.length && (function (t, e) { for (let n = 0; n < t.length; n++)"," === t.charAt(n) && 0 }(n), e = "".concat(n, ", ").concat(e)), qg(t, "", e) }(this._element, "".concat(this._duration, "ms ").concat(this._easing, " ").concat(this._delay, "ms 1 normal ").concat(this._fillMode, " ").concat(this._name)), zg(this._element, this._eventFn, !1), this._startTime = Date.now() } pause() { Bg(this._element, this._name, "paused") } resume() { Bg(this._element, this._name, "running") } setPosition(t) { const e = Hg(this._element, this._name); this._position = t * this._duration, qg(this._element, "Delay", "-".concat(this._position, "ms"), e) } getPosition() { return this._position } _handleCallback(t) { const e = t._ngTestManualTimestamp || Date.now(), n = 1e3 * parseFloat(t.elapsedTime.toFixed(3)); t.animationName == this._name && Math.max(e - this._startTime, 0) >= this._delay && n >= this._duration && this.finish() } finish() { this._finished || (this._finished = !0, this._onDoneFn(), zg(this._element, this._eventFn, !0)) } destroy() { this._destroyed || (this._destroyed = !0, this.finish(), function (t, e) { const n = Wg(t, "").split(","), r = Vg(n, e); r >= 0 && (n.splice(r, 1), qg(t, "", n.join(","))) }(this._element, this._name)) } } function Bg(t, e, n) { qg(t, "PlayState", n, Hg(t, e)) } function Hg(t, e) { const n = Wg(t, ""); return n.indexOf(",") > 0 ? Vg(n.split(","), e) : Vg([n], e) } function Vg(t, e) { for (let n = 0; n < t.length; n++)if (t[n].indexOf(e) >= 0) return n; return -1 } function zg(t, e, n) { n ? t.removeEventListener("animationend", e) : t.addEventListener("animationend", e) } function qg(t, e, n, r) { const s = "animation" + e; if (null != r) { const e = t.style[s]; if (e.length) { const t = e.split(","); t[r] = n, n = t.join(",") } } t.style[s] = n } function Wg(t, e) { return t.style["animation" + e] } class Qg { constructor(t, e, n, r, s, i, o, a) { this.element = t, this.keyframes = e, this.animationName = n, this._duration = r, this._delay = s, this._finalStyles = o, this._specialStyles = a, this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._started = !1, this.currentSnapshot = {}, this._state = 0, this.easing = i || "linear", this.totalTime = r + s, this._buildStyler() } onStart(t) { this._onStartFns.push(t) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } destroy() { this.init(), this._state >= 4 || (this._state = 4, this._styler.destroy(), this._flushStartFns(), this._flushDoneFns(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } _flushDoneFns() { this._onDoneFns.forEach(t => t()), this._onDoneFns = [] } _flushStartFns() { this._onStartFns.forEach(t => t()), this._onStartFns = [] } finish() { this.init(), this._state >= 3 || (this._state = 3, this._styler.finish(), this._flushStartFns(), this._specialStyles && this._specialStyles.finish(), this._flushDoneFns()) } setPosition(t) { this._styler.setPosition(t) } getPosition() { return this._styler.getPosition() } hasStarted() { return this._state >= 2 } init() { this._state >= 1 || (this._state = 1, this._styler.apply(), this._delay && this._styler.pause()) } play() { this.init(), this.hasStarted() || (this._flushStartFns(), this._state = 2, this._specialStyles && this._specialStyles.start()), this._styler.resume() } pause() { this.init(), this._styler.pause() } restart() { this.reset(), this.play() } reset() { this._styler.destroy(), this._buildStyler(), this._styler.apply() } _buildStyler() { this._styler = new Ug(this.element, this.animationName, this._duration, this._delay, this.easing, "forwards", () => this.finish()) } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(t => t()), e.length = 0 } beforeDestroy() { this.init(); const t = {}; if (this.hasStarted()) { const e = this._state >= 3; Object.keys(this._finalStyles).forEach(n => { "offset" != n && (t[n] = e ? this._finalStyles[n] : jm(this.element, n)) }) } this.currentSnapshot = t } } class Kg extends Xd { constructor(t, e) { super(), this.element = t, this._startingStyles = {}, this.__initialized = !1, this._styles = gm(e) } init() { !this.__initialized && this._startingStyles && (this.__initialized = !0, Object.keys(this._styles).forEach(t => { this._startingStyles[t] = this.element.style[t] }), super.init()) } play() { this._startingStyles && (this.init(), Object.keys(this._styles).forEach(t => this.element.style.setProperty(t, this._styles[t])), super.play()) } destroy() { this._startingStyles && (Object.keys(this._startingStyles).forEach(t => { const e = this._startingStyles[t]; e ? this.element.style.setProperty(t, e) : this.element.style.removeProperty(t) }), this._startingStyles = null, super.destroy()) } } class Zg { constructor() { this._count = 0, this._head = document.querySelector("head"), this._warningIssued = !1 } validateStyleProperty(t) { return dm(t) } matchesElement(t, e) { return pm(t, e) } containsElement(t, e) { return fm(t, e) } query(t, e, n) { return mm(t, e, n) } computeStyle(t, e, n) { return window.getComputedStyle(t)[e] } buildKeyframeElement(t, e, n) { n = n.map(t => gm(t)); let r = "@keyframes ".concat(e, " {\n"), s = ""; n.forEach(t => { s = " "; const e = parseFloat(t.offset); r += "".concat(s).concat(100 * e, "% {\n"), s += " ", Object.keys(t).forEach(e => { const n = t[e]; switch (e) { case "offset": return; case "easing": return void (n && (r += "".concat(s, "animation-timing-function: ").concat(n, ";\n"))); default: return void (r += "".concat(s).concat(e, ": ").concat(n, ";\n")) } }), r += "".concat(s, "}\n") }), r += "}\n"; const i = document.createElement("style"); return i.innerHTML = r, i } animate(t, e, n, r, s, i = [], o) { o && this._notifyFaultyScrubber(); const a = i.filter(t => t instanceof Qg), l = {}; Fm(n, r) && a.forEach(t => { let e = t.currentSnapshot; Object.keys(e).forEach(t => l[t] = e[t]) }); const c = function (t) { let e = {}; return t && (Array.isArray(t) ? t : [t]).forEach(t => { Object.keys(t).forEach(n => { "offset" != n && "easing" != n && (e[n] = t[n]) }) }), e }(e = Mm(t, e, l)); if (0 == n) return new Kg(t, c); const h = "gen_css_kf_".concat(this._count++), u = this.buildKeyframeElement(t, h, e); document.querySelector("head").appendChild(u); const d = Fg(t, e), p = new Qg(t, e, h, n, r, s, c, d); return p.onDestroy(() => { var t; (t = u).parentNode.removeChild(t) }), p } _notifyFaultyScrubber() { this._warningIssued || (console.warn("@angular/animations: please load the web-animations.js polyfill to allow programmatic access...\n", "  visit http://bit.ly/IWukam to learn more about using the web-animation-js polyfill."), this._warningIssued = !0) } } class Gg { constructor(t, e, n, r) { this.element = t, this.keyframes = e, this.options = n, this._specialStyles = r, this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._initialized = !1, this._finished = !1, this._started = !1, this._destroyed = !1, this.time = 0, this.parentPlayer = null, this.currentSnapshot = {}, this._duration = n.duration, this._delay = n.delay || 0, this.time = this._duration + this._delay } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = []) } init() { this._buildPlayer(), this._preparePlayerBeforeStart() } _buildPlayer() { if (this._initialized) return; this._initialized = !0; const t = this.keyframes; this.domPlayer = this._triggerWebAnimation(this.element, t, this.options), this._finalKeyframe = t.length ? t[t.length - 1] : {}, this.domPlayer.addEventListener("finish", () => this._onFinish()) } _preparePlayerBeforeStart() { this._delay ? this._resetDomPlayerState() : this.domPlayer.pause() } _triggerWebAnimation(t, e, n) { return t.animate(e, n) } onStart(t) { this._onStartFns.push(t) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } play() { this._buildPlayer(), this.hasStarted() || (this._onStartFns.forEach(t => t()), this._onStartFns = [], this._started = !0, this._specialStyles && this._specialStyles.start()), this.domPlayer.play() } pause() { this.init(), this.domPlayer.pause() } finish() { this.init(), this._specialStyles && this._specialStyles.finish(), this._onFinish(), this.domPlayer.finish() } reset() { this._resetDomPlayerState(), this._destroyed = !1, this._finished = !1, this._started = !1 } _resetDomPlayerState() { this.domPlayer && this.domPlayer.cancel() } restart() { this.reset(), this.play() } hasStarted() { return this._started } destroy() { this._destroyed || (this._destroyed = !0, this._resetDomPlayerState(), this._onFinish(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } setPosition(t) { this.domPlayer.currentTime = t * this.time } getPosition() { return this.domPlayer.currentTime / this.time } get totalTime() { return this._delay + this._duration } beforeDestroy() { const t = {}; this.hasStarted() && Object.keys(this._finalKeyframe).forEach(e => { "offset" != e && (t[e] = this._finished ? this._finalKeyframe[e] : jm(this.element, e)) }), this.currentSnapshot = t } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(t => t()), e.length = 0 } } class Yg { constructor() { this._isNativeImpl = /\{\s*\[native\s+code\]\s*\}/.test(Xg().toString()), this._cssKeyframesDriver = new Zg } validateStyleProperty(t) { return dm(t) } matchesElement(t, e) { return pm(t, e) } containsElement(t, e) { return fm(t, e) } query(t, e, n) { return mm(t, e, n) } computeStyle(t, e, n) { return window.getComputedStyle(t)[e] } overrideWebAnimationsSupport(t) { this._isNativeImpl = t } animate(t, e, n, r, s, i = [], o) { if (!o && !this._isNativeImpl) return this._cssKeyframesDriver.animate(t, e, n, r, s, i); const a = { duration: n, delay: r, fill: 0 == r ? "both" : "forwards" }; s && (a.easing = s); const l = {}, c = i.filter(t => t instanceof Gg); Fm(n, r) && c.forEach(t => { let e = t.currentSnapshot; Object.keys(e).forEach(t => l[t] = e[t]) }); const h = Fg(t, e = Mm(t, e = e.map(t => Em(t, !1)), l)); return new Gg(t, e, a, h) } } function Xg() { return "undefined" != typeof window && void 0 !== window.document && Element.prototype.animate || {} } class $g extends Kd { constructor(t, e) { super(), this._nextAnimationId = 0, this._renderer = t.createRenderer(e.body, { id: "0", encapsulation: Ht.None, styles: [], data: { animation: [] } }) } build(t) { const e = this._nextAnimationId.toString(); this._nextAnimationId++; const n = Array.isArray(t) ? Zd(t) : t; return ey(this._renderer, null, e, "register", [n]), new Jg(e, this._renderer) } } class Jg extends class { }{ constructor(t, e) { super(), this._id = t, this._renderer = e } create(t, e) { return new ty(this._id, t, e || {}, this._renderer) } } class ty { constructor(t, e, n, r) { this.id = t, this.element = e, this._renderer = r, this.parentPlayer = null, this._started = !1, this.totalTime = 0, this._command("create", n) } _listen(t, e) { return this._renderer.listen(this.element, "@@".concat(this.id, ":").concat(t), e) } _command(t, ...e) { return ey(this._renderer, this.element, this.id, t, e) } onDone(t) { this._listen("done", t) } onStart(t) { this._listen("start", t) } onDestroy(t) { this._listen("destroy", t) } init() { this._command("init") } hasStarted() { return this._started } play() { this._command("play"), this._started = !0 } pause() { this._command("pause") } restart() { this._command("restart") } finish() { this._command("finish") } destroy() { this._command("destroy") } reset() { this._command("reset") } setPosition(t) { this._command("setPosition", t) } getPosition() { return 0 } } function ey(t, e, n, r, s) { return t.setProperty(e, "@@".concat(n, ":").concat(r), s) } class ny { constructor(t, e, n) { this.delegate = t, this.engine = e, this._zone = n, this._currentId = 0, this._microtaskId = 1, this._animationCallbacksBuffer = [], this._rendererCache = new Map, this._cdRecurDepth = 0, this.promise = Promise.resolve(0), e.onRemovalComplete = (t, e) => { e && e.parentNode(t) && e.removeChild(t.parentNode, t) } } createRenderer(t, e) { const n = this.delegate.createRenderer(t, e); if (!(t && e && e.data && e.data.animation)) { let t = this._rendererCache.get(n); return t || (t = new ry("", n, this.engine), this._rendererCache.set(n, t)), t } const r = e.id, s = e.id + "-" + this._currentId; return this._currentId++, this.engine.register(s, t), e.data.animation.forEach(e => this.engine.registerTrigger(r, s, t, e.name, e)), new sy(this, s, n, this.engine) } begin() { this._cdRecurDepth++, this.delegate.begin && this.delegate.begin() } _scheduleCountTask() { this.promise.then(() => { this._microtaskId++ }) } scheduleListenerCallback(t, e, n) { t >= 0 && t < this._microtaskId ? this._zone.run(() => e(n)) : (0 == this._animationCallbacksBuffer.length && Promise.resolve(null).then(() => { this._zone.run(() => { this._animationCallbacksBuffer.forEach(t => { const [e, n] = t; e(n) }), this._animationCallbacksBuffer = [] }) }), this._animationCallbacksBuffer.push([e, n])) } end() { this._cdRecurDepth--, 0 == this._cdRecurDepth && this._zone.runOutsideAngular(() => { this._scheduleCountTask(), this.engine.flush(this._microtaskId) }), this.delegate.end && this.delegate.end() } whenRenderingDone() { return this.engine.whenRenderingDone() } } class ry { constructor(t, e, n) { this.namespaceId = t, this.delegate = e, this.engine = n, this.destroyNode = this.delegate.destroyNode ? t => e.destroyNode(t) : null } get data() { return this.delegate.data } destroy() { this.engine.destroy(this.namespaceId, this.delegate), this.delegate.destroy() } createElement(t, e) { return this.delegate.createElement(t, e) } createComment(t) { return this.delegate.createComment(t) } createText(t) { return this.delegate.createText(t) } appendChild(t, e) { this.delegate.appendChild(t, e), this.engine.onInsert(this.namespaceId, e, t, !1) } insertBefore(t, e, n) { this.delegate.insertBefore(t, e, n), this.engine.onInsert(this.namespaceId, e, t, !0) } removeChild(t, e, n) { this.engine.onRemove(this.namespaceId, e, this.delegate, n) } selectRootElement(t, e) { return this.delegate.selectRootElement(t, e) } parentNode(t) { return this.delegate.parentNode(t) } nextSibling(t) { return this.delegate.nextSibling(t) } setAttribute(t, e, n, r) { this.delegate.setAttribute(t, e, n, r) } removeAttribute(t, e, n) { this.delegate.removeAttribute(t, e, n) } addClass(t, e) { this.delegate.addClass(t, e) } removeClass(t, e) { this.delegate.removeClass(t, e) } setStyle(t, e, n, r) { this.delegate.setStyle(t, e, n, r) } removeStyle(t, e, n) { this.delegate.removeStyle(t, e, n) } setProperty(t, e, n) { "@" == e.charAt(0) && "@.disabled" == e ? this.disableAnimations(t, !!n) : this.delegate.setProperty(t, e, n) } setValue(t, e) { this.delegate.setValue(t, e) } listen(t, e, n) { return this.delegate.listen(t, e, n) } disableAnimations(t, e) { this.engine.disableAnimations(t, e) } } class sy extends ry { constructor(t, e, n, r) { super(e, n, r), this.factory = t, this.namespaceId = e } setProperty(t, e, n) { "@" == e.charAt(0) ? "." == e.charAt(1) && "@.disabled" == e ? this.disableAnimations(t, n = void 0 === n || !!n) : this.engine.process(this.namespaceId, t, e.substr(1), n) : this.delegate.setProperty(t, e, n) } listen(t, e, n) { if ("@" == e.charAt(0)) { const r = function (t) { switch (t) { case "body": return document.body; case "document": return document; case "window": return window; default: return t } }(t); let s = e.substr(1), i = ""; return "@" != s.charAt(0) && ([s, i] = function (t) { const e = t.indexOf("."); return [t.substring(0, e), t.substr(e + 1)] }(s)), this.engine.listen(this.namespaceId, r, s, i, t => { this.factory.scheduleListenerCallback(t._data || -1, n, t) }) } return this.delegate.listen(t, e, n) } } class iy extends Dg { constructor(t, e, n) { super(t.body, e, n) } } function oy() { return "function" == typeof Xg() ? new Yg : new Zg } function ay() { return new lg } function ly(t, e, n) { return new ny(t, e, n) } const cy = new Tt("AnimationModuleType"); class hy { } let uy = (() => { class t { create(t) { return "undefined" == typeof MutationObserver ? null : new MutationObserver(t) } } return t.ngInjectableDef = ft({ factory: function () { return new t }, token: t, providedIn: "root" }), t })(); class dy { } const py = new w(_); class fy { constructor(t, e) { this.delay = t, this.scheduler = e } call(t, e) { return e.subscribe(new my(t, this.delay, this.scheduler)) } } class my extends m { constructor(t, e, n) { super(t), this.delay = e, this.scheduler = n, this.queue = [], this.active = !1, this.errored = !1 } static dispatch(t) { const e = t.source, n = e.queue, r = t.scheduler, s = t.destination; for (; n.length > 0 && n[0].time - r.now() <= 0;)n.shift().notification.observe(s); if (n.length > 0) { const e = Math.max(0, n[0].time - r.now()); this.schedule(t, e) } else this.unsubscribe(), e.active = !1 } _schedule(t) { this.active = !0, this.destination.add(t.schedule(my.dispatch, this.delay, { source: this, destination: this.destination, scheduler: t })) } scheduleNotification(t) { if (!0 === this.errored) return; const e = this.scheduler, n = new gy(e.now() + this.delay, t); this.queue.push(n), !1 === this.active && this._schedule(e) } _next(t) { this.scheduleNotification(Ap.createNext(t)) } _error(t) { this.errored = !0, this.queue = [], this.destination.error(t), this.unsubscribe() } _complete() { this.scheduleNotification(Ap.createComplete()), this.unsubscribe() } } class gy { constructor(t, e) { this.time = t, this.notification = e } } const yy = "Service workers are disabled or not supported by this browser"; class _y { constructor(t) { if (this.serviceWorker = t, t) { const e = pp(t, "controllerchange").pipe(H(() => t.controller)), n = ol(Ra(() => Sa(t.controller)), e); this.worker = n.pipe(Ia(t => !!t)), this.registration = this.worker.pipe(rl(() => t.getRegistration())); const r = pp(t, "message").pipe(H(t => t.data)).pipe(Ia(t => t && t.type)).pipe(st(new k)); r.connect(), this.events = r } else this.worker = this.events = this.registration = Ra(() => xp(new Error("Service workers are disabled or not supported by this browser"))) } postMessage(t, e) { return this.worker.pipe(Xa(1), Ua(n => { n.postMessage(Object.assign({ action: t }, e)) })).toPromise().then(() => { }) } postMessageWithStatus(t, e, n) { const r = this.waitForStatus(n), s = this.postMessage(t, e); return Promise.all([r, s]).then(() => { }) } generateNonce() { return Math.round(1e7 * Math.random()) } eventsOfType(t) { return this.events.pipe(Ia(e => e.type === t)) } nextEventOfType(t) { return this.eventsOfType(t).pipe(Xa(1)) } waitForStatus(t) { return this.eventsOfType("STATUS").pipe(Ia(e => e.nonce === t), Xa(1), H(t => { if (!t.status) throw new Error(t.error) })).toPromise() } get isEnabled() { return !!this.serviceWorker } } class vy { constructor(t) { if (this.sw = t, this.subscriptionChanges = new k, !t.isEnabled) return this.messages = py, this.notificationClicks = py, void (this.subscription = py); this.messages = this.sw.eventsOfType("PUSH").pipe(H(t => t.data)), this.notificationClicks = this.sw.eventsOfType("NOTIFICATION_CLICK").pipe(H(t => t.data)), this.pushManager = this.sw.registration.pipe(H(t => t.pushManager)); const e = this.pushManager.pipe(rl(t => t.getSubscription())); this.subscription = X(e, this.subscriptionChanges) } get isEnabled() { return this.sw.isEnabled } requestSubscription(t) { if (!this.sw.isEnabled) return Promise.reject(new Error(yy)); const e = { userVisibleOnly: !0 }; let n = this.decodeBase64(t.serverPublicKey.replace(/_/g, "/").replace(/-/g, "+")), r = new Uint8Array(new ArrayBuffer(n.length)); for (let s = 0; s < n.length; s++)r[s] = n.charCodeAt(s); return e.applicationServerKey = r, this.pushManager.pipe(rl(t => t.subscribe(e)), Xa(1)).toPromise().then(t => (this.subscriptionChanges.next(t), t)) } unsubscribe() { return this.sw.isEnabled ? this.subscription.pipe(Xa(1), rl(t => { if (null === t) throw new Error("Not subscribed to push notifications."); return t.unsubscribe().then(t => { if (!t) throw new Error("Unsubscribe failed!"); this.subscriptionChanges.next(null) }) })).toPromise() : Promise.reject(new Error(yy)) } decodeBase64(t) { return atob(t) } } class by { constructor(t) { if (this.sw = t, !t.isEnabled) return this.available = py, void (this.activated = py); this.available = this.sw.eventsOfType("UPDATE_AVAILABLE"), this.activated = this.sw.eventsOfType("UPDATE_ACTIVATED") } get isEnabled() { return this.sw.isEnabled } checkForUpdate() { if (!this.sw.isEnabled) return Promise.reject(new Error(yy)); const t = this.sw.generateNonce(); return this.sw.postMessageWithStatus("CHECK_FOR_UPDATES", { statusNonce: t }, t) } activateUpdate() { if (!this.sw.isEnabled) return Promise.reject(new Error(yy)); const t = this.sw.generateNonce(); return this.sw.postMessageWithStatus("ACTIVATE_UPDATE", { statusNonce: t }, t) } } class wy { } const Sy = new Tt("NGSW_REGISTER_SCRIPT"); function Ey(t, e, n, r) { return () => { if (!(ga(r) && "serviceWorker" in navigator && !1 !== n.enabled)) return; let s; if (navigator.serviceWorker.addEventListener("controllerchange", () => { null !== navigator.serviceWorker.controller && navigator.serviceWorker.controller.postMessage({ action: "INITIALIZE" }) }), "function" == typeof n.registrationStrategy) s = n.registrationStrategy(); else { const [e, ...r] = (n.registrationStrategy || "registerWhenStable").split(":"); switch (e) { case "registerImmediately": s = Sa(null); break; case "registerWithDelay": s = Sa(null).pipe(function (t, e = yp) { var n; const r = (n = t) instanceof Date && !isNaN(+n) ? +t - e.now() : Math.abs(t); return t => t.lift(new fy(r, e)) }(+r[0] || 0)); break; case "registerWhenStable": s = t.get(li).isStable.pipe(Ia(t => t)); break; default: throw new Error("Unknown ServiceWorker registration strategy: ".concat(n.registrationStrategy)) } } s.pipe(Xa(1)).subscribe(() => navigator.serviceWorker.register(e, { scope: n.scope }).catch(t => console.error("Service worker registration failed with:", t))) } } function Cy(t, e) { return new _y(ga(e) && !1 !== t.enabled ? navigator.serviceWorker : void 0) } class xy { static register(t, e = {}) { return { ngModule: xy, providers: [{ provide: Sy, useValue: t }, { provide: wy, useValue: e }, { provide: _y, useFactory: Cy, deps: [wy, Ts] }, { provide: bs, useFactory: Ey, deps: [ke, Sy, wy, Ts], multi: !0 }] } } } class Ty { } class ky { } class Ay { } class Ry { } class Py { } class Iy { } class Oy { } var Ny = new Go(Yo, [Xo], (function (t) { return function (t) { const e = {}, n = []; let r = !1; for (let s = 0; s < t.length; s++) { const i = t[s]; i.token === xe && !0 === i.value && (r = !0), 1073741824 & i.flags && n.push(i.token), i.index = s, e[Hn(i.token)] = i } return { factory: null, providersByKey: e, providers: t, modules: n, isRoot: r } }([wr(512, Ye, Xe, [[8, [ld, Wd, wf, jf, Xf]], [3, Ye], Lt]), wr(5120, Rs, Ci, [[3, Rs]]), wr(4608, la, ca, [Rs, [2, aa]]), wr(5120, ds, xi, [Ws]), wr(5120, Ss, Es, []), wr(5120, vn, Si, []), wr(5120, bn, Ei, []), wr(4608, lc, cc, [ma]), wr(6144, _e, null, [lc]), wr(4608, ec, rc, []), wr(5120, Pl, (function (t, e, n, r, s, i, o, a) { return [new Jl(t, e, n), new ac(r), new sc(s, i, o, a)] }), [ma, Ws, Ts, ma, ma, ec, As, [2, nc]]), wr(4608, Il, Il, [Pl, Ws]), wr(135680, Dl, Dl, [ma]), wr(4608, Ul, Ul, [Il, Dl, Ss]), wr(5120, _m, oy, []), wr(5120, ag, ay, []), wr(4608, Dg, iy, [ma, _m, ag]), wr(5120, nn, ly, [Ul, Dg, Ws]), wr(6144, Nl, null, [Dl]), wr(4608, $s, $s, [Ws]), wr(5120, xh, ed, [Fu]), wr(4608, Vu, Vu, []), wr(6144, Bu, null, [Vu]), wr(135680, zu, zu, [Fu, hi, Fs, ke, Bu]), wr(4608, Hu, Hu, []), wr(5120, qu, Yu, [Fu, ya, Wu]), wr(5120, id, sd, [nd]), wr(5120, ks, (function (t) { return [t] }), [id]), wr(4608, Kd, $g, [nn, ma]), wr(4608, uy, uy, []), wr(4608, nf, nf, [Hp, Zp, Ye, tf, Kp, ke, Ws, ma, cp, [2, na]]), wr(5120, rf, sf, [nf]), wr(5120, ff, mf, [nf]), wr(135680, gf, gf, [nf, ke, [2, na], [2, pf], ff, [3, gf], Zp]), wr(4608, Md, Ld, [ma, Ts, Dd]), wr(4608, jd, jd, [Md, Fd]), wr(5120, Ad, (function (t) { return [t] }), [jd]), wr(4608, Od, Od, []), wr(6144, Id, null, [Od]), wr(4608, Nd, Nd, [Id]), wr(6144, ud, null, [Nd]), wr(4608, hd, Ud, [ud, ke]), wr(4608, Td, Td, [hd]), wr(5120, _y, Cy, [wy, Ts]), wr(4608, vy, vy, [_y]), wr(4608, by, by, [_y]), wr(4608, Vd, Vd, [Td]), wr(1073742336, fa, fa, []), wr(1024, Qt, yc, []), wr(1024, ri, (function () { return [Zu()] }), []), wr(512, nd, nd, [ke]), wr(256, Sy, "ngsw-worker.js", []), wr(256, wy, { enabled: !0 }, []), wr(1024, bs, (function (t, e, n, r, s, i) { return [(o = t, kl("probe", Rl), kl("coreTokens", Object.assign({}, Al, (o || []).reduce((t, e) => (t[e.name] = e.token, t), {}))), () => Rl), rd(e), Ey(n, r, s, i)]; var o }), [[2, ri], nd, ke, Sy, wy, Ts]), wr(512, ws, ws, [[2, bs]]), wr(131584, li, li, [Ws, As, ke, Qt, Ye, ws]), wr(1073742336, Ti, Ti, [li]), wr(1073742336, _c, _c, [[3, _c]]), wr(1024, Qu, $u, [[3, Fu]]), wr(512, rh, sh, []), wr(512, Lu, Lu, []), wr(256, Wu, {}, []), wr(1024, ta, Xu, [$o, [2, ea], Wu]), wr(512, na, na, [ta, $o]), wr(512, Fs, Fs, []), wr(512, hi, pi, [Fs, [2, ui]]), wr(1024, Au, (function () { return [[{ path: "img/:index", component: cd }, { path: "gallery", component: Qd }, { path: "", component: Qd }]] }), []), wr(1024, Fu, td, [li, rh, Lu, na, ke, hi, Fs, Au, Wu, [2, Pu], [2, Tu]]), wr(1073742336, Gu, Gu, [[2, Qu], [2, Fu]]), wr(1073742336, Ty, Ty, []), wr(1073742336, hy, hy, []), wr(1073742336, hp, hp, []), wr(1073742336, If, If, [[2, Pf], [2, nc]]), wr(1073742336, Pp, Pp, []), wr(1073742336, Df, Df, []), wr(1073742336, dy, dy, []), wr(1073742336, ky, ky, []), wr(1073742336, Ay, Ay, []), wr(1073742336, op, op, []), wr(1073742336, Af, Af, []), wr(1073742336, Ry, Ry, []), wr(1073742336, Nf, Nf, []), wr(1073742336, Py, Py, []), wr(1073742336, Iy, Iy, []), wr(1073742336, Oy, Oy, []), wr(1073742336, Op, Op, []), wr(1073742336, of, of, []), wr(1073742336, yf, yf, []), wr(1073742336, zf, zf, []), wr(1073742336, Bd, Bd, []), wr(1073742336, Hd, Hd, []), wr(1073742336, xy, xy, []), wr(1073742336, Yo, Yo, []), wr(256, xe, !0, []), wr(256, cy, "BrowserAnimations", []), wr(256, Dd, "XSRF-TOKEN", []), wr(256, Fd, "X-XSRF-TOKEN", [])]) })); (function () { if (Zt) throw new Error("Cannot enable prod mode after platform setup."); Kt = !1 })(), gc().bootstrapModuleFactory(Ny).catch(t => console.error(t)) }, zn8P: function (t, e) { function n(t) { return Promise.resolve().then((function () { var e = new Error("Cannot find module '" + t + "'"); throw e.code = "MODULE_NOT_FOUND", e })) } n.keys = function () { return [] }, n.resolve = n, t.exports = n, n.id = "zn8P" } }, [[0, 0]]]);
